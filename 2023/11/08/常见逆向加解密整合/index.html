
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>常见逆向加解密整合 | Moyao の小屋</title>
        <meta name="author" content="Moyao">
        <meta name="description" content="Write down something interesting I met
feel free to mail me if you have something wanted to talk about
mail: &lt;moyaoxue@outlook.com&gt;
">
        <meta name="keywords" content="">
        <link rel="icon" href="/images/head.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Moyao の小屋</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a target="_blank" rel="noopener" href="//tags/re/">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Moyao の小屋</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/tags/re/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        
<div class="article">
    <div>
        <h1>常见逆向加解密整合 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2023/11/8
        </span>
        
        
    </div>
    <div class="content" v-pre>
        <h6 id="preface：小做一点整理"><a href="#preface：小做一点整理" class="headerlink" title="preface：小做一点整理"></a>preface：小做一点整理</h6><span id="more"></span>

<h2 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h2><h4 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h4><p>魔改的点一般就是在里面加别的操作吧，异或之类的</p>
<pre><code class="python">class RC4:
    def __init__(self, key) -&gt; None:
        self.key = key
        self.S = 0
        self.__rc4_init__()
    def __rc4_init__(self):
        S = [i for i in range(256)]
        j = 0
        for i in range(256):
            j = (j + S[i] + key[i % len(key)]) % 256
            S[i], S[j] = S[j], S[i]
        self.S = S
    def rc4_encrypt(self, plain) -&gt; list:
        i = 0
        j = 0
        cipher = []
        for p in plain:
            i = (i + 1) % 256
            j = (j + self.S[i]) % 256
            self.S[i], self.S[j] = self.S[j], self.S[i]
            k = p ^ self.S[(self.S[i] + self.S[j]) % 256]
            cipher.append(k)
        return cipher

key = []
data = []
rc4 = RC4(key)
plain = rc4.rc4_encrypt(data)
for i in plain:
    print(chr(i),end = &quot;&quot;)
</code></pre>
<h4 id="Salsa20"><a href="#Salsa20" class="headerlink" title="Salsa20"></a>Salsa20</h4><p>需要注意nonce的初始填充</p>
<pre><code class="python">from Crypto.Cipher import Salsa20

key = b&#39;\x07\x05\x0B\x0D\x0F\x0D\x0B\x05\x07\x05\x1B\x1D\x1F\x1D\x1B\x05\x07\x05\x0B\x0D\x0F\x37\x35\x3B\x3D\x3F\x07\x05\x0B\x0D\x0F\x0D&#39;
nonce = b&#39;\x00\x00\x00\x00\x00\x00\x00\x00&#39;

plaintext = b&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_&quot;
cipher = Salsa20.new(key=key , nonce=nonce)
ciphertext = cipher.encrypt(plaintext)

a = [hex(i) for i in ciphertext]
print(a)
</code></pre>
<p>完整版</p>
<pre><code class="python">
class Salsa:
    def __init__(self, r=20):
        assert r &gt;= 0
        self._r = r  # number of rounds
        self._mask = 0xffffffff  # 32-bit mask

    def __call__(self, key=[0] * 32, nonce=[0] * 8, block_counter=[0] * 8):
        assert len(key) == 32
        assert len(nonce) == 8
        assert len(block_counter) == 8

        # init state
        k = [self._littleendian(key[4 * i:4 * i + 4]) for i in range(8)]
        n = [self._littleendian(nonce[4 * i:4 * i + 4]) for i in range(2)]
        b = [self._littleendian(block_counter[4 * i:4 * i + 4]) for i in range(2)]
        c = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]

        s = [c[0], k[0], k[1], k[2],
             k[3], c[1], n[0], n[1],
             b[0], b[1], c[2], k[4],
             k[5], k[6], k[7], c[3]]

        # the state
        self._s = s[:]

        for i in range(self._r):
            self._round()

        # add initial state to the final one
        self._s = [(self._s[i] + s[i]) &amp; self._mask for i in range(16)]

        return self._s

    def _littleendian(self, b):
        assert len(b) == 4
        return b[0] ^ (b[1] &lt;&lt; 8) ^ (b[2] &lt;&lt; 16) ^ (b[3] &lt;&lt; 24)

    def _round(self):
        # quarterround 1
        self._s[4] ^= self._rotl32((self._s[0] + self._s[12]) &amp; self._mask, 7)
        self._s[8] ^= self._rotl32((self._s[0] + self._s[4]) &amp; self._mask, 9)
        self._s[12] ^= self._rotl32((self._s[4] + self._s[8]) &amp; self._mask, 13)
        self._s[0] ^= self._rotl32((self._s[8] + self._s[12]) &amp; self._mask, 18)

        # quarterround 2
        self._s[9] ^= self._rotl32((self._s[1] + self._s[5]) &amp; self._mask, 7)
        self._s[13] ^= self._rotl32((self._s[5] + self._s[9]) &amp; self._mask, 9)
        self._s[1] ^= self._rotl32((self._s[9] + self._s[13]) &amp; self._mask, 13)
        self._s[5] ^= self._rotl32((self._s[1] + self._s[13]) &amp; self._mask, 18)

        # quarterround 3
        self._s[14] ^= self._rotl32((self._s[6] + self._s[10]) &amp; self._mask, 7)
        self._s[2] ^= self._rotl32((self._s[10] + self._s[14]) &amp; self._mask, 9)
        self._s[6] ^= self._rotl32((self._s[2] + self._s[14]) &amp; self._mask, 13)
        self._s[10] ^= self._rotl32((self._s[2] + self._s[6]) &amp; self._mask, 18)

        # quarterround 4
        self._s[3] ^= self._rotl32((self._s[11] + self._s[15]) &amp; self._mask, 7)
        self._s[7] ^= self._rotl32((self._s[3] + self._s[15]) &amp; self._mask, 9)
        self._s[11] ^= self._rotl32((self._s[3] + self._s[7]) &amp; self._mask, 13)
        self._s[15] ^= self._rotl32((self._s[7] + self._s[11]) &amp; self._mask, 18)

        # transpose
        self._s = [self._s[0], self._s[4], self._s[8], self._s[12],
                   self._s[1], self._s[5], self._s[9], self._s[13],
                   self._s[2], self._s[6], self._s[10], self._s[14],
                   self._s[3], self._s[7], self._s[11], self._s[15]]

    def _rotl32(self, w, r):
        # rotate left for 32-bits
        return (((w &lt;&lt; r) &amp; self._mask) | (w &gt;&gt; (32 - r)))


if __name__ == &#39;__main__&#39;:
    salsa20 = Salsa()

    # vectors = [
    #    [ [0]*32, [3,1,4,1,5,9,2,6], [7,0,0,0,0,0,0,0],     # 这里就是参数!!!
    #    [ 0xb9a205a3,0x0695e150,0xaa94881a,0xadb7b12c,
    #      0x798942d4,0x26107016,0x64edb1a4,0x2d27173f,
    #      0xb1c7f1fa,0x62066edc,0xe035fa23,0xc4496f04,
    #      0x2131e6b3,0x810bde28,0xf62cb407,0x6bdede3d ] ] ]
    vectors = [
        [[0] * 32, [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]]  # 这里就是参数!!!

    for i in range(len(vectors)):
        v = vectors[i]
        print(f&quot;key =&gt; &#123;v[0]&#125;&quot;)
        print(f&quot;nonce =&gt; &#123;v[1]&#125;&quot;)
        print(f&quot;block_counter =&gt; &#123;v[2]&#125;&quot;)
        s = salsa20(v[0], v[1], v[2])
        stream_key = []
        # for i in s:
        #   print(hex(i),end = &quot; &quot;)

        for i in range(len(s)):
            stream_key.append(s[i] &amp; 0xff)
            stream_key.append((s[i] &amp; 0xff00) &gt;&gt; 8)
            stream_key.append((s[i] &amp; 0xff0000) &gt;&gt; 16)
            stream_key.append((s[i] &amp; 0xff000000) &gt;&gt; 24)
        print()
        cybertext = [1,1,1,1]
        for i in range(len(stream_key)):
            print(chr(stream_key[i] ^ cybertext[i]), end=&quot;&quot;)
</code></pre>
<h4 id="chacha20"><a href="#chacha20" class="headerlink" title="chacha20"></a>chacha20</h4><pre><code class="python">
from Crypto.Cipher import ChaCha20
key = b&#39;\x07\x05\x0B\x0D\x0F\x0D\x0B\x05\x07\x05\x1B\x1D\x1F\x1D\x1B\x05\x07\x05\x0B\x0D\x0F\x37\x35\x3B\x3D\x3F\x07\x05\x0B\x0D\x0F\x0D&#39;
plaintext = b&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_&quot;
nonce = b&#39;\x00\x00\x00\x00\x00\x00\x00\x00&#39;
cipher = ChaCha20.new(key=key,nonce=nonce)
ciphertext = cipher.encrypt(plaintext)

# 获取 nonce（用于解密）
# nonce = cipher.nonce


# 解密
# cipher = ChaCha20.new(key=key, nonce=nonce)
# decrypted_text = cipher.decrypt(ciphertext)

a = [hex(i) for i in ciphertext]
print(a)
</code></pre>
<pre><code class="cpp">#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;bits/stdc++.h&gt;
static inline void u32t8le(uint32_t v, uint8_t p[4]) &#123;
    p[0] = v &amp; 0xff;
    p[1] = (v &gt;&gt; 8) &amp; 0xff;
    p[2] = (v &gt;&gt; 16) &amp; 0xff;
    p[3] = (v &gt;&gt; 24) &amp; 0xff;
&#125;

static inline uint32_t u8t32le(uint8_t p[4]) &#123;
    uint32_t value = p[3];
    
    value = (value &lt;&lt; 8) | p[2];
    value = (value &lt;&lt; 8) | p[1];
    value = (value &lt;&lt; 8) | p[0];
    
    return value;
&#125;

static inline uint32_t rotl32(uint32_t x, int n) &#123;
    // http://blog.regehr.org/archives/1063
    return x &lt;&lt; n | (x &gt;&gt; (-n &amp; 31));
&#125;

// https://tools.ietf.org/html/rfc7539##section-2.1
static void chacha20_quarterround(uint32_t *x, int a, int b, int c, int d) &#123;
    x[a] += x[b]; x[d] = rotl32(x[d] ^ x[a], 16);
    x[c] += x[d]; x[b] = rotl32(x[b] ^ x[c], 12);
    x[a] += x[b]; x[d] = rotl32(x[d] ^ x[a],  8);
    x[c] += x[d]; x[b] = rotl32(x[b] ^ x[c],  7);
&#125;

static void chacha20_serialize(uint32_t in[16], uint8_t output[64]) &#123;
    int i;
    for (i = 0; i &lt; 16; i++) &#123;
        u32t8le(in[i], output + (i &lt;&lt; 2));
    &#125;
&#125;

static void chacha20_block(uint32_t in[16], uint8_t out[64], int num_rounds) &#123; // num_rounds 一般为20 
    int i;
    uint32_t x[16];
    
    memcpy(x, in, sizeof(uint32_t) * 16);
    
    for (i = num_rounds; i &gt; 0; i -= 2) &#123;    
        //odd round
        chacha20_quarterround(x, 0, 4,  8, 12);
        chacha20_quarterround(x, 1, 5,  9, 13);
        chacha20_quarterround(x, 2, 6, 10, 14);
        chacha20_quarterround(x, 3, 7, 11, 15);
        //even round 
        chacha20_quarterround(x, 0, 5, 10, 15);
        chacha20_quarterround(x, 1, 6, 11, 12);
        chacha20_quarterround(x, 2, 7,  8, 13);
        chacha20_quarterround(x, 3, 4,  9, 14);
    &#125;
    
    for (i = 0; i &lt; 16; i++) &#123;
        x[i] += in[i];
    &#125;
    
    chacha20_serialize(x, out);
&#125;

// https://tools.ietf.org/html/rfc7539##section-2.3
static void chacha20_init_state(uint32_t s[16], uint8_t key[32], uint32_t counter, uint8_t nonce[12]) &#123;
    int i;
    
    // refer: https://dxr.mozilla.org/mozilla-beta/source/security/nss/lib/freebl/chacha20.c
    // convert magic number to string: &quot;expand 32-byte k&quot;
    s[0] = 0x61707865;
    s[1] = 0x3320646e;
    s[2] = 0x79622d32;
    s[3] = 0x6b206574;
    
    for (i = 0; i &lt; 8; i++) &#123;
        s[4 + i] = u8t32le(key + i * 4);
    &#125;
    
    s[12] = counter;
    
    for (i = 0; i &lt; 3; i++) &#123;
        s[13 + i] = u8t32le(nonce + i * 4);
    &#125;
&#125;

void ChaCha20XOR(uint8_t key[32], uint32_t counter, uint8_t nonce[12], uint8_t *in, uint8_t *out, int inlen) &#123;
    int i, j;
    
    uint32_t s[16];
    uint8_t block[64];
    
    chacha20_init_state(s, key, counter, nonce);
    
    for (i = 0; i &lt; inlen; i += 64) &#123;
        chacha20_block(s, block, 20);
        s[12]++;
        
        for (j = i; j &lt; i + 64; j++) &#123;
            if (j &gt;= inlen) &#123;
                break;
            &#125;
            out[j] = in[j] ^ block[j - i];
        &#125;
    &#125;
&#125;

int main() &#123;
    int i;
    
    uint8_t key[] = &#123;
        0x00, 0x01, 0x02, 0x03,
        0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b,
        0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13,
        0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b,
        0x1c, 0x1d, 0x1e, 0x1f
    &#125;;
    
    uint8_t nonce[] = &#123;                // 随机数 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    &#125;;
    
    uint8_t input[114] = &#123;
        0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74, 0x6c
    &#125;;
    
    uint8_t encrypt[114];
    uint8_t decrypt[114];
    
    int counter = 1;
    
    ChaCha20XOR(key, counter, nonce, input, encrypt, 114);             
    ChaCha20XOR(key, counter, nonce, encrypt, decrypt, 114);
    
    printf(&quot;\nkey:&quot;);
    for (i = 0; i &lt; 32; i++) &#123;
        if (!(i % 16)) &#123;
            printf(&quot;\n&quot;);
        &#125;
        printf(&quot;%02x &quot;, key[i]);
    &#125;
    
    printf(&quot;\n\nnonce:\n&quot;);
    for (i = 0; i &lt; 12; i++) &#123;
        printf(&quot;%02x &quot;, nonce[i]);
    &#125;
    
    printf(&quot;\n\nplaintext:&quot;);
    for (i = 0; i &lt; 114; i++) &#123;
        if (!(i % 16)) &#123;
            printf(&quot;\n&quot;);
        &#125;
        printf(&quot;%02x &quot;, input[i]);
    &#125;
    
    printf(&quot;\n\nencrypted:&quot;);
    for (i = 0; i &lt; 114; i++) &#123;
        if (!(i % 16)) &#123;
            printf(&quot;\n&quot;);
        &#125;
        printf(&quot;%02x &quot;, encrypt[i]);
    &#125;
    
    printf(&quot;\n\ndecrypted:&quot;);
    for (i = 0; i &lt; 114; i++) &#123;
        if (!(i % 16)) &#123;
            printf(&quot;\n&quot;);
        &#125;
        printf(&quot;%02x &quot;, decrypt[i]);
    &#125;
    
    printf(&quot;\n&quot;);
    return 0;
&#125;
</code></pre>
<h4 id="ZUC"><a href="#ZUC" class="headerlink" title="ZUC"></a>ZUC</h4><p>未测试过，没找到合适的标准库</p>
<pre><code class="python">from math import ceil
 
S0 = [
    0x3E, 0x72, 0x5B, 0x47, 0xCA, 0xE0, 0x00, 0x33, 0x04, 0xD1, 0x54, 0x98, 0x09, 0xB9, 0x6D, 0xCB,
    0x7B, 0x1B, 0xF9, 0x32, 0xAF, 0x9D, 0x6A, 0xA5, 0xB8, 0x2D, 0xFC, 0x1D, 0x08, 0x53, 0x03, 0x90,
    0x4D, 0x4E, 0x84, 0x99, 0xE4, 0xCE, 0xD9, 0x91, 0xDD, 0xB6, 0x85, 0x48, 0x8B, 0x29, 0x6E, 0xAC,
    0xCD, 0xC1, 0xF8, 0x1E, 0x73, 0x43, 0x69, 0xC6, 0xB5, 0xBD, 0xFD, 0x39, 0x63, 0x20, 0xD4, 0x38,
    0x76, 0x7D, 0xB2, 0xA7, 0xCF, 0xED, 0x57, 0xC5, 0xF3, 0x2C, 0xBB, 0x14, 0x21, 0x06, 0x55, 0x9B,
    0xE3, 0xEF, 0x5E, 0x31, 0x4F, 0x7F, 0x5A, 0xA4, 0x0D, 0x82, 0x51, 0x49, 0x5F, 0xBA, 0x58, 0x1C,
    0x4A, 0x16, 0xD5, 0x17, 0xA8, 0x92, 0x24, 0x1F, 0x8C, 0xFF, 0xD8, 0xAE, 0x2E, 0x01, 0xD3, 0xAD,
    0x3B, 0x4B, 0xDA, 0x46, 0xEB, 0xC9, 0xDE, 0x9A, 0x8F, 0x87, 0xD7, 0x3A, 0x80, 0x6F, 0x2F, 0xC8,
    0xB1, 0xB4, 0x37, 0xF7, 0x0A, 0x22, 0x13, 0x28, 0x7C, 0xCC, 0x3C, 0x89, 0xC7, 0xC3, 0x96, 0x56,
    0x07, 0xBF, 0x7E, 0xF0, 0x0B, 0x2B, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xA6, 0x4C, 0x10, 0xFE,
    0xBC, 0x26, 0x95, 0x88, 0x8A, 0xB0, 0xA3, 0xFB, 0xC0, 0x18, 0x94, 0xF2, 0xE1, 0xE5, 0xE9, 0x5D,
    0xD0, 0xDC, 0x11, 0x66, 0x64, 0x5C, 0xEC, 0x59, 0x42, 0x75, 0x12, 0xF5, 0x74, 0x9C, 0xAA, 0x23,
    0x0E, 0x86, 0xAB, 0xBE, 0x2A, 0x02, 0xE7, 0x67, 0xE6, 0x44, 0xA2, 0x6C, 0xC2, 0x93, 0x9F, 0xF1,
    0xF6, 0xFA, 0x36, 0xD2, 0x50, 0x68, 0x9E, 0x62, 0x71, 0x15, 0x3D, 0xD6, 0x40, 0xC4, 0xE2, 0x0F,
    0x8E, 0x83, 0x77, 0x6B, 0x25, 0x05, 0x3F, 0x0C, 0x30, 0xEA, 0x70, 0xB7, 0xA1, 0xE8, 0xA9, 0x65,
    0x8D, 0x27, 0x1A, 0xDB, 0x81, 0xB3, 0xA0, 0xF4, 0x45, 0x7A, 0x19, 0xDF, 0xEE, 0x78, 0x34, 0x60
]
 
S1 = [
    0x55, 0xC2, 0x63, 0x71, 0x3B, 0xC8, 0x47, 0x86, 0x9F, 0x3C, 0xDA, 0x5B, 0x29, 0xAA, 0xFD, 0x77,
    0x8C, 0xC5, 0x94, 0x0C, 0xA6, 0x1A, 0x13, 0x00, 0xE3, 0xA8, 0x16, 0x72, 0x40, 0xF9, 0xF8, 0x42,
    0x44, 0x26, 0x68, 0x96, 0x81, 0xD9, 0x45, 0x3E, 0x10, 0x76, 0xC6, 0xA7, 0x8B, 0x39, 0x43, 0xE1,
    0x3A, 0xB5, 0x56, 0x2A, 0xC0, 0x6D, 0xB3, 0x05, 0x22, 0x66, 0xBF, 0xDC, 0x0B, 0xFA, 0x62, 0x48,
    0xDD, 0x20, 0x11, 0x06, 0x36, 0xC9, 0xC1, 0xCF, 0xF6, 0x27, 0x52, 0xBB, 0x69, 0xF5, 0xD4, 0x87,
    0x7F, 0x84, 0x4C, 0xD2, 0x9C, 0x57, 0xA4, 0xBC, 0x4F, 0x9A, 0xDF, 0xFE, 0xD6, 0x8D, 0x7A, 0xEB,
    0x2B, 0x53, 0xD8, 0x5C, 0xA1, 0x14, 0x17, 0xFB, 0x23, 0xD5, 0x7D, 0x30, 0x67, 0x73, 0x08, 0x09,
    0xEE, 0xB7, 0x70, 0x3F, 0x61, 0xB2, 0x19, 0x8E, 0x4E, 0xE5, 0x4B, 0x93, 0x8F, 0x5D, 0xDB, 0xA9,
    0xAD, 0xF1, 0xAE, 0x2E, 0xCB, 0x0D, 0xFC, 0xF4, 0x2D, 0x46, 0x6E, 0x1D, 0x97, 0xE8, 0xD1, 0xE9,
    0x4D, 0x37, 0xA5, 0x75, 0x5E, 0x83, 0x9E, 0xAB, 0x82, 0x9D, 0xB9, 0x1C, 0xE0, 0xCD, 0x49, 0x89,
    0x01, 0xB6, 0xBD, 0x58, 0x24, 0xA2, 0x5F, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xB8, 0x95, 0xE4,
    0xD0, 0x91, 0xC7, 0xCE, 0xED, 0x0F, 0xB4, 0x6F, 0xA0, 0xCC, 0xF0, 0x02, 0x4A, 0x79, 0xC3, 0xDE,
    0xA3, 0xEF, 0xEA, 0x51, 0xE6, 0x6B, 0x18, 0xEC, 0x1B, 0x2C, 0x80, 0xF7, 0x74, 0xE7, 0xFF, 0x21,
    0x5A, 0x6A, 0x54, 0x1E, 0x41, 0x31, 0x92, 0x35, 0xC4, 0x33, 0x07, 0x0A, 0xBA, 0x7E, 0x0E, 0x34,
    0x88, 0xB1, 0x98, 0x7C, 0xF3, 0x3D, 0x60, 0x6C, 0x7B, 0xCA, 0xD3, 0x1F, 0x32, 0x65, 0x04, 0x28,
    0x64, 0xBE, 0x85, 0x9B, 0x2F, 0x59, 0x8A, 0xD7, 0xB0, 0x25, 0xAC, 0xAF, 0x12, 0x03, 0xE2, 0xF2
]
 
D = [
    0x44D7, 0x26BC, 0x626B, 0x135E, 0x5789, 0x35E2, 0x7135, 0x09AF,
    0x4D78, 0x2F13, 0x6BC4, 0x1AF1, 0x5E26, 0x3C4D, 0x789A, 0x47AC
]
 
 
def addition_uint31(a, b):
    c = a + b
    return (c &amp; 0x7FFFFFFF) + (c &gt;&gt; 31)
 
 
def rotl_uint31(a, shift):
    return ((a &lt;&lt; shift) | (a &gt;&gt; (31 - shift))) &amp; 0x7FFFFFFF
 
 
def rotl_uint32(a, shift):
    return ((a &lt;&lt; shift) | (a &gt;&gt; (32 - shift))) &amp; 0xFFFFFFFF
 
 
def l1(x):
    return (x ^ rotl_uint32(x, 2) ^ rotl_uint32(x, 10) ^ rotl_uint32(x, 18) ^ rotl_uint32(x, 24))
 
 
def l2(x):
    return (x ^ rotl_uint32(x, 8) ^ rotl_uint32(x, 14) ^ rotl_uint32(x, 22) ^ rotl_uint32(x, 30))
 
 
def make_uint32(a, b, c, d):
    return ((a &lt;&lt; 24) &amp; 0xffffffff) | ((b &lt;&lt; 16) &amp; 0xffffffff) | ((c &lt;&lt; 8) &amp; 0xffffffff) | d
 
 
def make_uint31(a, b, c):
    return ((a &lt;&lt; 23) &amp; 0x7fffffff) | ((b &lt;&lt; 8) &amp; 0x7fffffff) | c
 
 
class ZUC(object):
    def __init__(self, key, iv):
        self.r = [0, 0]
        self.lfsr = [0 for _ in range(16)]
        self.x = [0, 0, 0, 0]
        self.zuc_init(key, iv)
 
    def bit_reorganization(self):
        self.x[0] = ((self.lfsr[15] &amp; 0x7FFF8000) &lt;&lt; 1) | (self.lfsr[14] &amp; 0xFFFF)
        self.x[1] = ((self.lfsr[11] &amp; 0xFFFF) &lt;&lt; 16) | (self.lfsr[9] &gt;&gt; 15)
        self.x[2] = ((self.lfsr[7] &amp; 0xFFFF) &lt;&lt; 16) | (self.lfsr[5] &gt;&gt; 15)
        self.x[3] = ((self.lfsr[2] &amp; 0xFFFF) &lt;&lt; 16) | (self.lfsr[0] &gt;&gt; 15)
 
    def lfsr_next(self):
        f = self.lfsr[0]
        v = rotl_uint31(self.lfsr[0], 8)
        f = addition_uint31(f, v)
        v = rotl_uint31(self.lfsr[4], 20)
        f = addition_uint31(f, v)
        v = rotl_uint31(self.lfsr[10], 21)
        f = addition_uint31(f, v)
        v = rotl_uint31(self.lfsr[13], 17)
        f = addition_uint31(f, v)
        v = rotl_uint31(self.lfsr[15], 15)
        f = addition_uint31(f, v)
        return f
 
    def lfsr_append(self, f):
        self.lfsr.append(f)
        if len(self.lfsr) &gt; 16:
            self.lfsr.pop(0)
 
    def lfsr_init(self, u):
        self.lfsr_append(addition_uint31(self.lfsr_next(), u))
 
    def lfsr_shift(self):
        self.lfsr_append(self.lfsr_next())
 
    def f(self):
        W = ((self.x[0] ^ self.r[0]) + self.r[1]) &amp; 0xffffffff
        W1 = (self.r[0] + self.x[1]) &amp; 0xffffffff
        W2 = self.r[1] ^ self.x[2]
        u = l1(((W1 &amp; 0x0000ffff) &lt;&lt; 16) | (W2 &gt;&gt; 16))
        v = l2(((W2 &amp; 0x0000ffff) &lt;&lt; 16) | (W1 &gt;&gt; 16))
        self.r = [make_uint32(S0[u &gt;&gt; 24], S1[(u &gt;&gt; 16) &amp; 0xFF],
                              S0[(u &gt;&gt; 8) &amp; 0xFF], S1[u &amp; 0xFF]),
                  make_uint32(S0[v &gt;&gt; 24], S1[(v &gt;&gt; 16) &amp; 0xFF],
                              S0[(v &gt;&gt; 8) &amp; 0xFF], S1[v &amp; 0xFF])]
        return W
 
    def zuc_init(self, key, iv):
        # Expand key.
        self.lfsr = [make_uint31(key[i], D[i], iv[i]) for i in range(16)]
        self.r = [0, 0]
        for i in range(32):
            self.bit_reorganization()
            w = self.f()
            self.lfsr_init(w &gt;&gt; 1)
 
    def zuc_generate_keystream(self, length):
        keystream_buffer = []
        self.bit_reorganization()
        self.f()  # Discard the output of F.
 
        def itor():
            self.lfsr_shift()
            self.bit_reorganization()
            return self.f() ^ self.x[-1]
 
        keystream_buffer = [itor() for _ in range(length)]
        self.lfsr_shift()
        return keystream_buffer
 
    def zuc_encrypt(self, input):
        length = len(input)
        key_stream = self.zuc_generate_keystream(length)
        return [inp ^ key_stream[i] for i, inp in enumerate(input)]
 
 
if &#39;__main__&#39; == __name__:
    key = [0x00] * 16
    iv = [0x00] * 16
    zuc = ZUC(key, iv)
    # 加密过程
    out = zuc.zuc_encrypt(b&quot;i love u&quot;)
    print(&quot;加密得到的字流&quot;, [&quot;%08x&quot; % e for e in out])
    # 解密过程
    zuc2 = ZUC(key, iv)
    out2 = zuc2.zuc_encrypt(out)
    print(&quot;解密得到的字流&quot;, [&quot;%08x&quot; % e for e in out2])
    print(bytes(out2))
</code></pre>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><h3 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h3><h4 id="TEA-1"><a href="#TEA-1" class="headerlink" title="TEA"></a>TEA</h4><pre><code class="c">#define uint unsigned int
void encrypt(uint *v, uint *key)
&#123;
    uint l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9;
    for (int i = 1; i &lt;= 32; ++i)
    &#123;
        sum += delta;
        l += ((r &lt;&lt; 4) + key[0]) ^ (r + sum) ^ ((r &gt;&gt; 5) + key[1]);
        r += ((l &lt;&lt; 4) + key[2]) ^ (l + sum) ^ ((l &gt;&gt; 5) + key[3]);
    &#125;
    v[0] = l, v[1] = r;
&#125;
void decrypt(uint *v, uint *key)
&#123;
    uint l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9;
    sum = delta * 32;
    for (int i = 1; i &lt;= 32; ++i)
    &#123;
        r -= ((l &lt;&lt; 4) + key[2]) ^ (l + sum) ^ ((l &gt;&gt; 5) + key[3]);
        l -= ((r &lt;&lt; 4) + key[0]) ^ (r + sum) ^ ((r &gt;&gt; 5) + key[1]);
        sum -= delta;
    &#125;
    v[0] = l, v[1] = r;
&#125;
</code></pre>
<h4 id="XTEA"><a href="#XTEA" class="headerlink" title="XTEA"></a>XTEA</h4><pre><code class="c">#define uint unsigned int
void encrypt(uint *v, uint *key)
&#123;
    uint l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9;
    for (int i = 1; i &lt;= 32; ++i)
    &#123;
        l += (((r &lt;&lt; 4) ^ (r &gt;&gt; 5)) + r) ^ (sum + key[sum &amp; 3]);
        sum += delta;
        r += (((l &lt;&lt; 4) ^ (l &gt;&gt; 5)) + l) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);
    &#125;
    v[0] = l;
    v[1] = r;
&#125;

void decrypt(uint *v, uint *key)
&#123;
    uint l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9;
    sum = delta * 32;
    for (int i = 1; i &lt;= 32; ++i)
    &#123;
        r -= (((l &lt;&lt; 4) ^ (l &gt;&gt; 5)) + l) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);
        sum -= delta;
        l -= (((r &lt;&lt; 4) ^ (r &gt;&gt; 5)) + r) ^ (sum + key[sum &amp; 3]);
    &#125;
    v[0] = l;
    v[1] = r;
&#125;
</code></pre>
<h4 id="XXTEA"><a href="#XXTEA" class="headerlink" title="XXTEA"></a>XXTEA</h4><pre><code class="c">#include &lt;cstdio&gt;
#define uint unsigned int
#define MX (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (k[(i &amp; 3) ^ e] ^ z)))
void xxtea(uint *v, int n, uint *k)  
&#123;
    uint y, z, sum, i, t, e, delta = 0x9e3779b9;;
    if (n &gt; 1) // encrypt
    &#123;
        t = 6 + 52 / n, sum = 0, z = v[n - 1];
        while (t--)
        &#123;
            sum += delta, e = (sum &gt;&gt; 2) &amp; 3;
            for (i = 0; i &lt; n - 1; ++i)
            &#123;
                y = v[i + 1];
                z = v[i] += MX;
            &#125;
            y = v[0];
            z = v[n - 1] += MX;
        &#125;
    &#125;
    else if (n &lt; -1) // decrypt
    &#123;
        n = -n, t = 6 + 52 / n, sum = t * delta, y = v[0];
        while (t--)
        &#123;
            e = (sum &gt;&gt; 2) &amp; 3;
            for (i = n - 1; i &gt; 0; --i)
            &#123;
                z = v[i - 1];
                y = v[i] -= MX;
            &#125;
            z = v[n - 1];
            y = v[0] -= MX;
            sum -= delta;
        &#125;
    &#125;
&#125;
int main()
&#123;
    uint v[2]= &#123;1,2&#125;, k[4]= &#123;2,2,3,4&#125;;
    int n = 2; // abs(n) = strlen(v)
    printf(&quot;data: %u %u\n&quot;,v[0],v[1]);
    xxtea(v, n, k);
    printf(&quot;encrypt:%u %u\n&quot;,v[0],v[1]);
    xxtea(v, -n, k);
    printf(&quot;decrypt: %u %u\n&quot;,v[0],v[1]);
    return 0;
&#125;
</code></pre>
<pre><code class="python">from ctypes import *


def MX(z, y, total, key, p, e):
    temp1 = (z.value &gt;&gt; 5 ^ y.value &lt;&lt; 2) + (y.value &gt;&gt; 3 ^ z.value &lt;&lt; 4)
    temp2 = (total.value ^ y.value) + (key[(p &amp; 3) ^ e.value] ^ z.value)

    return c_uint32(temp1 ^ temp2)


def encrypt(n, v, key):
    delta = 0x9e3779b9
    rounds = 6 + 52 // n

    total = c_uint32(0)
    z = c_uint32(v[n - 1])
    e = c_uint32(0)

    while rounds &gt; 0:
        total.value += delta
        e.value = (total.value &gt;&gt; 2) &amp; 3
        for p in range(n - 1):
            y = c_uint32(v[p + 1])
            v[p] = c_uint32(v[p] + MX(z, y, total, key, p, e).value).value
            z.value = v[p]
        y = c_uint32(v[0])
        v[n - 1] = c_uint32(v[n - 1] + MX(z, y, total, key, n - 1, e).value).value
        z.value = v[n - 1]
        rounds -= 1

    return v


def decrypt(n, v, key):
    delta = 0x9e3779b9
    rounds = 6 + 52 // n

    total = c_uint32(rounds * delta)
    y = c_uint32(v[0])
    e = c_uint32(0)

    while rounds &gt; 0:
        e.value = (total.value &gt;&gt; 2) &amp; 3
        for p in range(n - 1, 0, -1):
            z = c_uint32(v[p - 1])
            v[p] = c_uint32((v[p] - MX(z, y, total, key, p, e).value)).value
            y.value = v[p]
        z = c_uint32(v[n - 1])
        v[0] = c_uint32(v[0] - MX(z, y, total, key, 0, e).value).value
        y.value = v[0]
        total.value -= delta
        rounds -= 1

    return v


#  test
if __name__ == &quot;__main__&quot;:
    # 该算法中每次可加密不只64bit的数据，并且加密的轮数由加密数据长度决定
    v = [1374278842, 2136006540, 4191056815, 3248881376]
    k = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]
    n = 4

    res = decrypt(n, v, k)
    # print(&quot;Data is : &quot;, hex(v[0]), hex(v[1]))
    # res = encrypt(n, v, k)
    # print(&quot;Encrypted data is : &quot;, hex(res[0]), hex(res[1]))
    # res = decrypt(n, res, k)
    print(&quot;Decrypted data is : &quot;, hex(res[0]), hex(res[1]), hex(res[2]), hex(res[3]))
&quot;&quot;&quot;
Data is :  0x12345678 0x78563412
Encrypted data is :  0xef86c2bb 0x25f31b5e
Decrypted data is :  0x12345678 0x78563412
&quot;&quot;&quot;
</code></pre>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h4><pre><code class="cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;

void encryption(unsigned char * plaintext,unsigned char * ciphertext);
void decryption(unsigned char * ciphertext,unsigned char * plaintext);

void ip_replace(unsigned char * in,unsigned char *out);
void fp_replace(unsigned char * in,unsigned char *out);
void byte2Bit(unsigned char *in,unsigned char *out,int len);
void bit2Byte(unsigned char *in,unsigned char *out,int len);

void f_func(unsigned char *in,unsigned char * out,unsigned char *ki);
void get_subkey(unsigned char *key);

void byteXOR(unsigned char *a,unsigned char *b,int len);
void e_expand(unsigned char * in,unsigned char * out);
void s_replace(unsigned char * in,unsigned char * out);
void p_replace(unsigned char * in,unsigned char * out);

void pc1_replace(unsigned char * in,unsigned char * out);
void pc2_replace(unsigned char *in,unsigned char *out);

const char IP_Table[64]= &#123;
        58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
        62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
        57, 49, 41, 33, 25, 17,  9, 1, 59, 51, 43, 35, 27, 19, 11, 3,
        61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7
&#125;;

const char IPR_Table[64] = &#123;
        40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31,
        38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29,
        36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27,
        34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41,  9, 49, 17, 57, 25
&#125;;

const char E_Table[48] = &#123;
        32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,
        8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
        16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
        24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1
&#125;;

const char P_Table[32] = &#123;
        16, 7, 20, 21, 29, 12, 28, 17, 1,  15, 23, 26, 5,  18, 31, 10,
        2,  8, 24, 14, 32, 27, 3,  9,  19, 13, 30, 6,  22, 11, 4,  25
&#125;;

const char PC1_Table[56] = &#123;
        57, 49, 41, 33, 25, 17,  9,  1, 58, 50, 42, 34, 26, 18,
        10,  2, 59, 51, 43, 35, 27, 19, 11,  3, 60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15,  7, 62, 54, 46, 38, 30, 22,
        14,  6, 61, 53, 45, 37, 29, 21, 13,  5, 28, 20, 12,  4
&#125;;
const char PC2_Table[48] = &#123;
        14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,
        23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,
        41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
&#125;;

const char LOOP_Table[16] = &#123;
    1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1
&#125;;
const char S_Box[8][4][16] = &#123;
        // S1
        14, 4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,
        0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,
        4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,
        15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13,
        // S2
        15, 1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,
        3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,
        0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,
        13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9,
        // S3
        10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,
        13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,
        13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,
        1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12,
        // S4
        7,  13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,
        13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,
        10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,
        3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14,
        // S5
        2,  12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,
        14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,
        4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,
        11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3,
        // S6
        12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,
        10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,
        9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,
        4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13,
        // S7
        4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,
        13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,
        1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,
        6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12,
        // S8
        13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,
        1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,
        7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,
        2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11
&#125;;

unsigned char subkey[16][48];

unsigned char result[]=&#123;0xef,0x34,0xd4,0xa3,0xc6,0x84,0xe4,0x23&#125;;

int main()
&#123;
    unsigned char key[9] = &quot;DE3_En1C&quot;;

    unsigned char plaintext[20];
    //HarDd3s?
    unsigned char ciphertext[8];
    int i=0;

    puts(&quot;give me a string to encrypt:&quot;);

    scanf(&quot;%s&quot;,plaintext);

    if(strlen((const char *)plaintext)!=8)&#123;
        system(&quot;pause&quot;);
        return -1;
    &#125;


    //to generate 16 round subkey
    get_subkey(key);

    //to encrypt plaintext
    encryption(plaintext,ciphertext);

    for(i=0;i&lt;8;++i)&#123;
        if(ciphertext[i]!=result[i])&#123;
            puts(&quot;Wrong!!&quot;);
            system(&quot;pause&quot;);
            return -1;
        &#125;
    &#125;
    puts(&quot;G00d Job!!&quot;);
    system(&quot;pause&quot;);
    return 0;
&#125;

void encryption(unsigned char * plaintext,unsigned char * ciphertext)&#123;
    int i;
    unsigned char array_plaintext[64];
    unsigned char f_result[32];
    unsigned char left_array[32];
    unsigned char right_array[32];

    byte2Bit(plaintext,array_plaintext,8);
    ip_replace(array_plaintext,array_plaintext);

    memcpy(left_array,array_plaintext,32);
    memcpy(right_array,array_plaintext+32,32);

    for(i=0;i&lt;15;++i)&#123;
        f_func(right_array,f_result,&amp;subkey[i][0]);
        byteXOR(f_result,left_array,32);
        memcpy(left_array,right_array,32);
        memcpy(right_array,f_result,32);
    &#125;

    f_func(right_array,f_result,&amp;subkey[i][0]);
    byteXOR(left_array,f_result,32);

    memcpy(array_plaintext,left_array,32);
    memcpy(array_plaintext+32,right_array,32);

    fp_replace(array_plaintext,array_plaintext);
    bit2Byte(array_plaintext,ciphertext,8);

&#125;


void byte2Bit(unsigned char *in,unsigned char *out,int len)&#123;
    int i,j;
    for(i=0;i&lt;len;++i)
        for(j=0;j&lt;8;++j)&#123;
            out[i*8+j] = (in[i]&gt;&gt;(7-j))&amp;0x1;
            &#125;
&#125;

void bit2Byte(unsigned char *in,unsigned char *out,int len)&#123;
    int i,j;
    unsigned char temp;
    for(i=0;i&lt;len;++i)&#123;
        temp = in[i*8]&amp;0x1;
        for(j=1;j&lt;8;++j)&#123;
            temp = temp&lt;&lt;1;
            temp = temp+(in[i*8+j]&amp;0x1);
        &#125;
        out[i]=temp;
    &#125;
&#125;

//change the input 64 bit data to 64 bytes array, use ip table to replace 64 bytes array
void ip_replace(unsigned char * in,unsigned char *out)&#123;
    int i;
    unsigned char temp[64];
    memcpy(temp,in,64);
    //use ip table to replace 64 bytes(bit) array
    for(i=0;i&lt;64;++i)&#123;
        out[i] = temp[IP_Table[i]-1];
        //printf(&quot;%x &quot;,out[i]);
    &#125;
&#125;

void fp_replace(unsigned char *in,unsigned char* out)&#123;
    int i;
    unsigned char temp[64];

    memcpy(temp,in,64);
    for(i=0;i&lt;64;++i)
        out[i] = temp[IPR_Table[i]-1];
&#125;

void e_expand(unsigned char * in, unsigned char *out)&#123;
    unsigned char temp[48];
    int i;

    memcpy(temp,in,48);
    for(i=0;i&lt;48;++i)
        out[i] = temp[E_Table[i]-1];
&#125;

void s_replace(unsigned char * in,unsigned char *out)&#123;
    int i,j;
    int raw,col;
    char temp;
    for(i=0,j=0;i&lt;8;++i)&#123;
        raw = ((in[i*6]&lt;&lt;1)|(in[i*6+5]))&amp;0x3;
        col = ((in[i*6+1]&lt;&lt;3)|(in[i*6+2]&lt;&lt;2)|(in[i*6+3]&lt;&lt;1)|(in[i*6+4]))&amp;0xF;
        temp = S_Box[i][raw][col]&amp;0xF;
        out[j] = (temp&gt;&gt;3)&amp;0x1;
        out[j+1] = (temp&gt;&gt;2)&amp;0x1;
        out[j+2] = (temp&gt;&gt;1)&amp;0x1;
        out[j+3] = (temp)&amp;0x1;
        j+=4;
    &#125;
&#125;

void p_replace(unsigned char * in,unsigned char * out)&#123;
    unsigned char temp[32];
    int i;

    memcpy(temp,in,32);
    for(i=0;i&lt;32;++i)&#123;
        out[i] = temp[P_Table[i]-1];
    &#125;
&#125;

void byteXOR(unsigned char *a,unsigned char *b,int len)&#123;
    int i;
    for(i=0;i&lt;len;++i)&#123;
        a[i] = (a[i]+b[i])&amp;0x1;
    &#125;
&#125;

void f_func(unsigned char * in,unsigned char * out,unsigned char * ki)&#123;
    unsigned char expand_result[48];
    unsigned char replace_result[32];

    e_expand(in,expand_result);
    byteXOR(expand_result,ki,48);
    s_replace(expand_result,replace_result);
    p_replace(replace_result,replace_result);
    memcpy(out,replace_result,32);
&#125;

void pc1_replace(unsigned char * in,unsigned char * out)&#123;
    int i;
    for(i=0;i&lt;56;++i)
        out[i]=in[PC1_Table[i]-1];
&#125;

void pc2_replace(unsigned char *in,unsigned char *out)&#123;
    int i;
    for(i=0;i&lt;48;++i)
        out[i] = in[PC2_Table[i]-1];
&#125;

void shift_left(unsigned char *in,unsigned char *out,int len)&#123;
    unsigned char temp[28];
    int i,j;

    memcpy(temp,in,28);
    for(i=len,j=0;i&lt;28;++i)
        out[j++]=temp[i];
    for(i=0;i&lt;len;++i)
        out[j++]=temp[i];
&#125;
//use user&#39;s input key to generate 16 subkey
void get_subkey(unsigned char *key)&#123;
    unsigned char key_temp[64];
    unsigned char pc1_result[56];
    unsigned char pc2_result[48];
    int i;

    byte2Bit(key,key_temp,8);
    pc1_replace(key_temp,pc1_result);

    for(i=0;i&lt;16;++i)&#123;
        shift_left(pc1_result,pc1_result,LOOP_Table[i]);
        shift_left(pc1_result+28,pc1_result+28,LOOP_Table[i]);
        pc2_replace(pc1_result,pc2_result);
        memcpy(&amp;subkey[i][0],pc2_result,48);
    &#125;
&#125;
</code></pre>
<h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;memory.h&gt;
/****************************************************************************************************************/
typedef enum &#123;
    AES_CYPHER_128,
    AES_CYPHER_192,
    AES_CYPHER_256,
&#125; AES_CYPHER_T;
/****************************************************************************************************************/
/*
* Encryption Rounds
*/
int g_aes_key_bits[] = &#123;
    /* AES_CYPHER_128 */ 128,
    /* AES_CYPHER_192 */ 192,
    /* AES_CYPHER_256 */ 256,
&#125;;
int g_aes_rounds[] = &#123;
    /* AES_CYPHER_128 */  10,
    /* AES_CYPHER_192 */  12,
    /* AES_CYPHER_256 */  14,
&#125;;
int g_aes_nk[] = &#123;
    /* AES_CYPHER_128 */  4,
    /* AES_CYPHER_192 */  6,
    /* AES_CYPHER_256 */  8,
&#125;;
int g_aes_nb[] = &#123;
    /* AES_CYPHER_128 */  4,
    /* AES_CYPHER_192 */  4,
    /* AES_CYPHER_256 */  4,
&#125;;
/****************************************************************************************************************/
/*
* aes Rcon:
*
* WARNING: Rcon is designed starting from 1 to 15, not 0 to 14.
*          FIPS-197 Page 9: &quot;note that i starts at 1, not 0&quot;
*
* i    |   0     1     2     3     4     5     6     7     8     9    10    11    12    13    14
* -----+------------------------------------------------------------------------------------------
*      | [01]  [02]  [04]  [08]  [10]  [20]  [40]  [80]  [1b]  [36]  [6c]  [d8]  [ab]  [4d]  [9a]
* RCON | [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]
*      | [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]
*      | [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]
*/
static const uint32_t g_aes_rcon[] = &#123;
    0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000,
    0x1b000000, 0x36000000, 0x6c000000, 0xd8000000, 0xab000000, 0xed000000, 0x9a000000
&#125;;
/****************************************************************************************************************/
/*
* aes sbox and invert-sbox
*/
static const uint8_t g_aes_sbox[256] = &#123;
    /* 0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
&#125;;
static const uint8_t g_inv_sbox[256] = &#123;
    /* 0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
&#125;;
/****************************************************************************************************************/
uint8_t aes_sub_sbox(uint8_t val)
&#123;
    return g_aes_sbox[val];
&#125;
/****************************************************************************************************************/
uint32_t aes_sub_dword(uint32_t val)
&#123;
    uint32_t tmp = 0;

    tmp |= ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 0) &amp; 0xFF))) &lt;&lt; 0;
    tmp |= ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 8) &amp; 0xFF))) &lt;&lt; 8;
    tmp |= ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 16) &amp; 0xFF))) &lt;&lt; 16;
    tmp |= ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 24) &amp; 0xFF))) &lt;&lt; 24;

    return tmp;
&#125;
/****************************************************************************************************************/
uint32_t aes_rot_dword(uint32_t val)
&#123;
    uint32_t tmp = val;

    return (val &gt;&gt; 8) | ((tmp &amp; 0xFF) &lt;&lt; 24);
&#125;
/****************************************************************************************************************/
uint32_t aes_swap_dword(uint32_t val)
&#123;
    return (((val &amp; 0x000000FF) &lt;&lt; 24) |
        ((val &amp; 0x0000FF00) &lt;&lt; 8) |
        ((val &amp; 0x00FF0000) &gt;&gt; 8) |
        ((val &amp; 0xFF000000) &gt;&gt; 24));
&#125;
/****************************************************************************************************************/
/*
* nr: number of rounds
* nb: number of columns comprising the state, nb = 4 dwords (16 bytes)
* nk: number of 32-bit words comprising cipher key, nk = 4, 6, 8 (KeyLength/(4*8))
*/
void aes_key_expansion(AES_CYPHER_T mode, uint8_t *key, uint8_t *round)
&#123;
    uint32_t *w = (uint32_t *)round;
    uint32_t  t;
    int      i = 0;

    do &#123;
        w[i] = *((uint32_t *)&amp;key[i * 4 + 0]);
    &#125; while (++i &lt; g_aes_nk[mode]);

    do &#123;
        if ((i % g_aes_nk[mode]) == 0) &#123;
            t = aes_rot_dword(w[i - 1]);
            t = aes_sub_dword(t);
            t = t ^ aes_swap_dword(g_aes_rcon[i / g_aes_nk[mode] - 1]);
        &#125;
        else if (g_aes_nk[mode] &gt; 6 &amp;&amp; (i % g_aes_nk[mode]) == 4) &#123;
            t = aes_sub_dword(w[i - 1]);
        &#125;
        else &#123;
            t = w[i - 1];
        &#125;
        w[i] = w[i - g_aes_nk[mode]] ^ t;
    &#125; while (++i &lt; g_aes_nb[mode] * (g_aes_rounds[mode] + 1));
&#125;
/****************************************************************************************************************/
void aes_add_round_key(AES_CYPHER_T mode, uint8_t *state,
    uint8_t *round, int nr)
&#123;
    uint32_t *w = (uint32_t *)round;
    uint32_t *s = (uint32_t *)state;
    int i;

    for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123;
        s[i] ^= w[nr * g_aes_nb[mode] + i];
    &#125;
&#125;
/****************************************************************************************************************/
void aes_sub_bytes(AES_CYPHER_T mode, uint8_t *state)
&#123;
    int i, j;

    for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123;
        for (j = 0; j &lt; 4; j++) &#123;
            state[i * 4 + j] = aes_sub_sbox(state[i * 4 + j]);
        &#125;
    &#125;
&#125;
/****************************************************************************************************************/
void aes_shift_rows(AES_CYPHER_T mode, uint8_t *state)
&#123;
    uint8_t *s = (uint8_t *)state;
    int i, j, r;

    for (i = 1; i &lt; g_aes_nb[mode]; i++) &#123;
        for (j = 0; j &lt; i; j++) &#123;
            uint8_t tmp = s[i];
            for (r = 0; r &lt; g_aes_nb[mode]; r++) &#123;
                s[i + r * 4] = s[i + (r + 1) * 4];
            &#125;
            s[i + (g_aes_nb[mode] - 1) * 4] = tmp;
        &#125;
    &#125;
&#125;
/****************************************************************************************************************/
uint8_t aes_xtime(uint8_t x)
&#123;
    return ((x &lt;&lt; 1) ^ (((x &gt;&gt; 7) &amp; 1) * 0x1b));
&#125;
/****************************************************************************************************************/
uint8_t aes_xtimes(uint8_t x, int ts)
&#123;
    while (ts-- &gt; 0) &#123;
        x = aes_xtime(x);
    &#125;

    return x;
&#125;
/****************************************************************************************************************/
uint8_t aes_mul(uint8_t x, uint8_t y)
&#123;
    /*
    * encrypt: y has only 2 bits: can be 1, 2 or 3
    * decrypt: y could be any value of 9, b, d, or e
    */

    return ((((y &gt;&gt; 0) &amp; 1) * aes_xtimes(x, 0)) ^
        (((y &gt;&gt; 1) &amp; 1) * aes_xtimes(x, 1)) ^
        (((y &gt;&gt; 2) &amp; 1) * aes_xtimes(x, 2)) ^
        (((y &gt;&gt; 3) &amp; 1) * aes_xtimes(x, 3)) ^
        (((y &gt;&gt; 4) &amp; 1) * aes_xtimes(x, 4)) ^
        (((y &gt;&gt; 5) &amp; 1) * aes_xtimes(x, 5)) ^
        (((y &gt;&gt; 6) &amp; 1) * aes_xtimes(x, 6)) ^
        (((y &gt;&gt; 7) &amp; 1) * aes_xtimes(x, 7)));
&#125;
/****************************************************************************************************************/
void aes_mix_columns(AES_CYPHER_T mode, uint8_t *state)
&#123;
    uint8_t y[16] = &#123; 2, 3, 1, 1,  1, 2, 3, 1,  1, 1, 2, 3,  3, 1, 1, 2 &#125;;
    uint8_t s[4];
    int i, j, r;

    for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123;
        for (r = 0; r &lt; 4; r++) &#123;
            s[r] = 0;
            for (j = 0; j &lt; 4; j++) &#123;
                s[r] = s[r] ^ aes_mul(state[i * 4 + j], y[r * 4 + j]);
            &#125;
        &#125;
        for (r = 0; r &lt; 4; r++) &#123;
            state[i * 4 + r] = s[r];
        &#125;
    &#125;
&#125;
/****************************************************************************************************************/
int aes_encrypt(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key)
&#123;
    uint8_t w[4 * 4 * 15] = &#123; 0 &#125;; /* round key */
    uint8_t s[4 * 4] = &#123; 0 &#125;; /* state */

    int nr, i, j;

    /* key expansion */
    aes_key_expansion(mode, key, w);

    /* start data cypher loop over input buffer */
    for (i = 0; i &lt; len; i += 4 * g_aes_nb[mode]) &#123;

        /* init state from user buffer (plaintext) */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            s[j] = data[i + j];

        /* start AES cypher loop over all AES rounds */
        for (nr = 0; nr &lt;= g_aes_rounds[mode]; nr++) &#123;

            if (nr &gt; 0) &#123;

                /* do SubBytes */
                aes_sub_bytes(mode, s);

                /* do ShiftRows */
                aes_shift_rows(mode, s);

                if (nr &lt; g_aes_rounds[mode]) &#123;
                    /* do MixColumns */
                    aes_mix_columns(mode, s);
                &#125;
            &#125;

            /* do AddRoundKey */
            aes_add_round_key(mode, s, w, nr);
        &#125;

        /* save state (cypher) to user buffer */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            data[i + j] = s[j];
    &#125;

    return 0;
&#125;
/****************************************************************************************************************/
int aes_encrypt_ecb(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key)
&#123;
    return aes_encrypt(mode, data, len, key);
&#125;
/****************************************************************************************************************/
int aes_encrypt_cbc(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key, uint8_t *iv)
&#123;
    uint8_t w[4 * 4 * 15] = &#123; 0 &#125;; /* round key */
    uint8_t s[4 * 4] = &#123; 0 &#125;; /* state */
    uint8_t v[4 * 4] = &#123; 0 &#125;; /* iv */

    int nr, i, j;


    /* key expansion */
    aes_key_expansion(mode, key, w);

    memcpy(v, iv, sizeof(v));

    /* start data cypher loop over input buffer */
    for (i = 0; i &lt; len; i += 4 * g_aes_nb[mode]) &#123;

        /* init state from user buffer (plaintext) */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            s[j] = data[i + j] ^ v[j];

        /* start AES cypher loop over all AES rounds */
        for (nr = 0; nr &lt;= g_aes_rounds[mode]; nr++) &#123;

            if (nr &gt; 0) &#123;

                /* do SubBytes */
                aes_sub_bytes(mode, s);

                /* do ShiftRows */
                aes_shift_rows(mode, s);

                if (nr &lt; g_aes_rounds[mode]) &#123;
                    /* do MixColumns */
                    aes_mix_columns(mode, s);
                &#125;
            &#125;

            /* do AddRoundKey */
            aes_add_round_key(mode, s, w, nr);
        &#125;

        /* save state (cypher) to user buffer */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            data[i + j] = v[j] = s[j];
    &#125;

    return 0;
&#125;
/****************************************************************************************************************/
void inv_shift_rows(AES_CYPHER_T mode, uint8_t *state)
&#123;
    uint8_t *s = (uint8_t *)state;
    int i, j, r;

    for (i = 1; i &lt; g_aes_nb[mode]; i++) &#123;
        for (j = 0; j &lt; g_aes_nb[mode] - i; j++) &#123;
            uint8_t tmp = s[i];
            for (r = 0; r &lt; g_aes_nb[mode]; r++) &#123;
                s[i + r * 4] = s[i + (r + 1) * 4];
            &#125;
            s[i + (g_aes_nb[mode] - 1) * 4] = tmp;
        &#125;
    &#125;
&#125;
/****************************************************************************************************************/
uint8_t inv_sub_sbox(uint8_t val)
&#123;
    return g_inv_sbox[val];
&#125;
/****************************************************************************************************************/
void inv_sub_bytes(AES_CYPHER_T mode, uint8_t *state)
&#123;
    int i, j;

    for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123;
        for (j = 0; j &lt; 4; j++) &#123;
            state[i * 4 + j] = inv_sub_sbox(state[i * 4 + j]);
        &#125;
    &#125;
&#125;
/****************************************************************************************************************/
void inv_mix_columns(AES_CYPHER_T mode, uint8_t *state)
&#123;
    uint8_t y[16] = &#123; 0x0e, 0x0b, 0x0d, 0x09,  0x09, 0x0e, 0x0b, 0x0d,
        0x0d, 0x09, 0x0e, 0x0b,  0x0b, 0x0d, 0x09, 0x0e &#125;;
    uint8_t s[4];
    int i, j, r;

    for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123;
        for (r = 0; r &lt; 4; r++) &#123;
            s[r] = 0;
            for (j = 0; j &lt; 4; j++) &#123;
                s[r] = s[r] ^ aes_mul(state[i * 4 + j], y[r * 4 + j]);
            &#125;
        &#125;
        for (r = 0; r &lt; 4; r++) &#123;
            state[i * 4 + r] = s[r];
        &#125;
    &#125;
&#125;
/****************************************************************************************************************/
int aes_decrypt(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key)
&#123;
    uint8_t w[4 * 4 * 15] = &#123; 0 &#125;; /* round key */
    uint8_t s[4 * 4] = &#123; 0 &#125;; /* state */

    int nr, i, j;

    /* key expansion */
    aes_key_expansion(mode, key, w);

    /* start data cypher loop over input buffer */
    for (i = 0; i &lt; len; i += 4 * g_aes_nb[mode]) &#123;

        /* init state from user buffer (cyphertext) */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            s[j] = data[i + j];

        /* start AES cypher loop over all AES rounds */
        for (nr = g_aes_rounds[mode]; nr &gt;= 0; nr--) &#123;

            /* do AddRoundKey */
            aes_add_round_key(mode, s, w, nr);

            if (nr &gt; 0) &#123;

                if (nr &lt; g_aes_rounds[mode]) &#123;
                    /* do MixColumns */
                    inv_mix_columns(mode, s);
                &#125;

                /* do ShiftRows */
                inv_shift_rows(mode, s);

                /* do SubBytes */
                inv_sub_bytes(mode, s);
            &#125;
        &#125;

        /* save state (cypher) to user buffer */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            data[i + j] = s[j];
    &#125;

    return 0;
&#125;
/****************************************************************************************************************/
int aes_decrypt_ecb(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key)
&#123;
    return aes_decrypt(mode, data, len, key);
&#125;
/****************************************************************************************************************/
int aes_decrypt_cbc(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key, uint8_t *iv)
&#123;
    uint8_t w[4 * 4 * 15] = &#123; 0 &#125;; /* round key */
    uint8_t s[4 * 4] = &#123; 0 &#125;; /* state */
    uint8_t v[4 * 4] = &#123; 0 &#125;; /* iv */


    int nr, i, j;

    /* key expansion */
    aes_key_expansion(mode, key, w);

    memcpy(v, iv, sizeof(v));

    /* start data cypher loop over input buffer */
    for (i = 0; i &lt; len; i += 4 * g_aes_nb[mode]) &#123;


        /* init state from user buffer (cyphertext) */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            s[j] = data[i + j];

        /* start AES cypher loop over all AES rounds */
        for (nr = g_aes_rounds[mode]; nr &gt;= 0; nr--) &#123;

            /* do AddRoundKey */
            aes_add_round_key(mode, s, w, nr);

            if (nr &gt; 0) &#123;

                if (nr &lt; g_aes_rounds[mode]) &#123;
                    /* do MixColumns */
                    inv_mix_columns(mode, s);
                &#125;

                /* do ShiftRows */
                inv_shift_rows(mode, s);

                /* do SubBytes */
                inv_sub_bytes(mode, s);
            &#125;
        &#125;

        /* save state (cypher) to user buffer */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++) &#123;
            uint8_t p = s[j] ^ v[j];
            v[j] = data[i + j];
            data[i + j] = p;
        &#125;
    &#125;

    return 0;
&#125;
/****************************************************************************************************************/
void aes_cypher_128_test()
&#123;
#if 1
    uint8_t buf[] = &#123; 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff &#125;;
    uint8_t key[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f &#125;;
#else
    uint8_t buf[] = &#123; 0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d,
        0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34 &#125;;
    uint8_t key[] = &#123; 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c &#125;;
#endif

    aes_encrypt(AES_CYPHER_128, buf, sizeof(buf), key);

    aes_decrypt(AES_CYPHER_128, buf, sizeof(buf), key);
&#125;
/****************************************************************************************************************/
void aes_cypher_192_test()
&#123;
    uint8_t buf[] = &#123; 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff &#125;;
    uint8_t key[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 &#125;;

    aes_encrypt(AES_CYPHER_192, buf, sizeof(buf), key);

    aes_decrypt(AES_CYPHER_192, buf, sizeof(buf), key);
&#125;
/****************************************************************************************************************/
void aes_cypher_256_test()
&#123;
    uint8_t buf[] = &#123; 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff &#125;;
    uint8_t key[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f &#125;;

    aes_encrypt(AES_CYPHER_256, buf, sizeof(buf), key);

    aes_decrypt(AES_CYPHER_256, buf, sizeof(buf), key);
&#125;
/****************************************************************************************************************/
int main()
&#123;
    //数据
    uint8_t buf[] = &#123; 78, 204, 144, 217, 57, 62, 169, 79, 165, 219, 206, 216, 180, 137, 206, 138 &#125;;
    //密钥
    uint8_t key[] = &#123; 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112 &#125;;
    //向量
    //uint8_t iv[] = &#123;&#125;;
    switch (sizeof(key))
    &#123;
    //ECB
    case 16:aes_decrypt(AES_CYPHER_128, buf, sizeof(buf), key); break;
    case 24:aes_decrypt(AES_CYPHER_192, buf, sizeof(buf), key); break;
    case 32:aes_decrypt(AES_CYPHER_256, buf, sizeof(buf), key); break;
    //CBC
    /*
    case 16:aes_decrypt_cbc(AES_CYPHER_128, buf, sizeof(buf), key, iv); break;
    case 24:aes_decrypt_cbc(AES_CYPHER_192, buf, sizeof(buf), key, iv); break;
    case 32:aes_decrypt_cbc(AES_CYPHER_256, buf, sizeof(buf), key, iv); break;
    */
    &#125;
    for (int i = 0; i &lt; sizeof(buf); i++)
    &#123;
        printf(&quot;%c&quot;, buf[i] &amp; 0xFF);
    &#125;
    printf(&quot;\n&quot;);
    return 0;
&#125;
</code></pre>
<pre><code class="python">from Crypto.Cipher import AES
from binascii import b2a_hex, a2b_hex

def add_to_16(text):
    if len(text.encode(&#39;utf-8&#39;)) % 16:
        add = 16 - (len(text.encode(&#39;utf-8&#39;)) % 16)
    else:
        add = 0
    text = text + (&#39;\0&#39; * add)
    return text.encode(&#39;utf-8&#39;)

def encrypt(text):
    key = &#39;\x4D\x4C\x57\x4E\x46\x7C\x19\x0A\x4D\x4C\x57\x4E\x46\x7C\x7B\x67&#39;.encode(&#39;utf-8&#39;)
    mode = AES.MODE_ECB
    text = add_to_16(text)
    cryptos = AES.new(key, mode)
    cipher_text = cryptos.encrypt(text)
    return cipher_text

def decrypt(text):
    key = &#39;\x4D\x4C\x57\x4E\x46\x7C\x19\x0A\x4D\x4C\x57\x4E\x46\x7C\x7B\x67&#39;.encode(&#39;utf-8&#39;)
    mode = AES.MODE_ECB
    cryptor = AES.new(key, mode)
    plain_text = cryptor.decrypt(a2b_hex(text))
    return bytes.decode(plain_text).rstrip(&#39;\0&#39;)

data = b&#39;\x96\x7f\x37\x7c\x26\x30\x03\xeb\x61\x6d\xa3\xda\x0c\x77\x3e\x7c\xdf\x18\x5d\x4e\xd9\xbe\x0a\x5c\x02\x36\x87\x37\xb4\x2f\xb1\x9f&#39;
data = b2a_hex(data)
ans = decrypt(data)
print(ans)
</code></pre>
<h4 id="RC5"><a href="#RC5" class="headerlink" title="RC5"></a>RC5</h4><h4 id="RC6"><a href="#RC6" class="headerlink" title="RC6"></a>RC6</h4><h4 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h4><pre><code class="cpp">#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#ifndef GET_ULONG_BE
#define GET_ULONG_BE(n,b,i) \
    &#123; \
        (n) = ( (unsigned long) (b)[(i) ] &lt;&lt; 24 ) \
              | ( (unsigned long) (b)[(i) + 1] &lt;&lt; 16 ) \
              | ( (unsigned long) (b)[(i) + 2] &lt;&lt; 8 ) \
              | ( (unsigned long) (b)[(i) + 3] ); \
    &#125;
#endif

#ifndef PUT_ULONG_BE
#define PUT_ULONG_BE(n,b,i) \
    &#123; \
        (b)[(i) ] = (unsigned char) ( (n) &gt;&gt; 24 ); \
        (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 16 ); \
        (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 8 ); \
        (b)[(i) + 3] = (unsigned char) ( (n) ); \
    &#125;
#endif

#define SHL(x,n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)
#define ROTL(x,n) (SHL((x),n) | ((x) &gt;&gt; (32 - n)))

#define SWAP(a,b) &#123; unsigned long t = a; a = b; b = t; t = 0; &#125;

static const unsigned char SboxTable[16][16] = &#123;
    &#123;0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05&#125;,
    &#123;0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99&#125;,
    &#123;0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62&#125;,
    &#123;0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6&#125;,
    &#123;0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8&#125;,
    &#123;0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35&#125;,
    &#123;0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87&#125;,
    &#123;0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e&#125;,
    &#123;0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1&#125;,
    &#123;0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3&#125;,
    &#123;0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f&#125;,
    &#123;0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51&#125;,
    &#123;0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8&#125;,
    &#123;0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0&#125;,
    &#123;0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84&#125;,
    &#123;0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48&#125;
&#125;;

static const unsigned long FK[4] = &#123;0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc&#125;;

static const unsigned long CK[32] = &#123;
    0x00070e15,0x1c232a31,0x383f464d,0x545b6269,
    0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,
    0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,
    0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,
    0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,
    0x30373e45,0x4c535a61,0x686f767d,0x848b9299,
    0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,
    0x10171e25,0x2c333a41,0x484f565d,0x646b7279
&#125;;

static unsigned char sm4Sbox(unsigned char inch) &#123;
    unsigned char *pTable = (unsigned char *)SboxTable;
    unsigned char retVal = (unsigned char)(pTable[inch]);
    return retVal;
&#125;

static unsigned long sm4Lt(unsigned long ka) &#123;
    unsigned long bb = 0;
    unsigned long c = 0;
    unsigned char a[4];
    unsigned char b[4];
    PUT_ULONG_BE(ka,a,0)
    b[0] = sm4Sbox(a[0]);
    b[1] = sm4Sbox(a[1]);
    b[2] = sm4Sbox(a[2]);
    b[3] = sm4Sbox(a[3]);
    GET_ULONG_BE(bb,b,0)
    c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24));
    return c;
&#125;

static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk) &#123;
    return (x0^sm4Lt(x1^x2^x3^rk));
&#125;



static void sm4_one_round( unsigned long sk[32],
                           unsigned char input[16],
                           unsigned char output[16] ) &#123;
    unsigned long i = 0;
    unsigned long ulbuf[36];

    memset(ulbuf, 0, sizeof(ulbuf));
    GET_ULONG_BE( ulbuf[0], input, 0 )
    GET_ULONG_BE( ulbuf[1], input, 4 )
    GET_ULONG_BE( ulbuf[2], input, 8 )
    GET_ULONG_BE( ulbuf[3], input, 12 )
    while(i&lt;32) &#123;
        ulbuf[i+4] = sm4F(ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3], sk[i]);
        i++;
    &#125;
    PUT_ULONG_BE(ulbuf[35],output,0);
    PUT_ULONG_BE(ulbuf[34],output,4);
    PUT_ULONG_BE(ulbuf[33],output,8);
    PUT_ULONG_BE(ulbuf[32],output,12);
&#125;

static unsigned long sm4CalciRK(unsigned long ka) &#123;
    unsigned long bb = 0;
    unsigned long rk = 0;
    unsigned char a[4];
    unsigned char b[4];
    PUT_ULONG_BE(ka,a,0)
    b[0] = sm4Sbox(a[0]);
    b[1] = sm4Sbox(a[1]);
    b[2] = sm4Sbox(a[2]);
    b[3] = sm4Sbox(a[3]);
    GET_ULONG_BE(bb,b,0)
    rk = bb^(ROTL(bb, 13))^(ROTL(bb, 23));
    return rk;
&#125;

static void sm4_setkey( unsigned long sk[32], unsigned char key[16] ) &#123;
    unsigned long MK[4];
    unsigned long k[36];
    unsigned long i = 0;

    GET_ULONG_BE( MK[0], key, 0 );
    GET_ULONG_BE( MK[1], key, 4 );
    GET_ULONG_BE( MK[2], key, 8 );
    GET_ULONG_BE( MK[3], key, 12 );
    k[0] = MK[0]^FK[0];
    k[1] = MK[1]^FK[1];
    k[2] = MK[2]^FK[2];
    k[3] = MK[3]^FK[3];
    for(; i&lt;32; i++) &#123;
        k[i+4] = k[i] ^ (sm4CalciRK(k[i+1]^k[i+2]^k[i+3]^CK[i]));
        sk[i] = k[i+4];
    &#125;
&#125;

int main() &#123;
    unsigned char key[16] = &#123;0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10&#125;;
    unsigned char input[16] = &#123;0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10&#125;;
    unsigned char output[16];
    unsigned long sk[32];
    unsigned long i;

    sm4_setkey(sk,key);

    sm4_one_round(sk, input,output);

    for(i=0; i&lt;16; i++)
        printf(&quot;%02x &quot;, output[i]);
    printf(&quot;\n&quot;);

    return 0;
&#125;
</code></pre>
<h4 id="Blowfish"><a href="#Blowfish" class="headerlink" title="Blowfish"></a>Blowfish</h4><h4 id="Twofish"><a href="#Twofish" class="headerlink" title="Twofish"></a>Twofish</h4><h4 id="Serpent"><a href="#Serpent" class="headerlink" title="Serpent"></a>Serpent</h4><p>在线工具请：<br><a target="_blank" rel="noopener" href="http://serpent.online-domain-tools.com/">http://serpent.online-domain-tools.com/</a></p>
<h4 id="PRESENT"><a href="#PRESENT" class="headerlink" title="PRESENT"></a>PRESENT</h4><pre><code class="python">Sbox = [12, 5, 6, 11, 9, 0, 10, 13, 3, 14, 15, 8, 4, 7, 1, 2]

Sbox_inv = [Sbox.index(x) for x in range(16)]

PBox = [
    0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,
    4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,
    8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,
    12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63
]

PBox_inv = [PBox.index(x) for x in range(64)]


def addRoundKey(state, roundkey):
    return state ^ roundkey


def sBoxLayer(state):
    output = 0
    for i in range(16):
        output += Sbox[(state &gt;&gt; (i * 4)) &amp; 15] &lt;&lt; (i * 4)
    return output


def pLayer(state):
    output = 0
    for i in range(64):
        output += ((state &gt;&gt; i) &amp; 1) &lt;&lt; PBox[i]
    return output


def string2number(i):
    return sum([(ord(i[c]) &lt;&lt; (8 * c)) for c in range(8)])


def generateRoundkeys80(key, rounds):
    roundkeys = []
    for i in range(1, rounds + 1):
        roundkeys.append(key &gt;&gt; 16)

        key = ((key &amp; 524287) &lt;&lt; 61) + (key &gt;&gt; 19)

        key = (Sbox[key &gt;&gt; 76] &lt;&lt; 76) + (key &amp; ((2 ** 76) - 1))

        key ^= i &lt;&lt; 15
    return roundkeys


def encrypt(blocks):
    rounds = 32
    roundkeys = generateRoundkeys80(85354531916197809168417, rounds)
    out = []

    for block in blocks:
        state = string2number(block)

        for i in range(rounds - 1):
            state = addRoundKey(state, roundkeys[i])
            state = sBoxLayer(state)
            state = pLayer(state)

        cipher = addRoundKey(state, roundkeys[-1])
        out.append(cipher)

    return out


inp = input(&#39;pls input ur flag:&#39;)

if len(inp) != 32:
    print(&#39;wrong!&#39;)
    exit(0)

blocks = [inp[:8], inp[8:16], inp[16:24], inp[24:32]]

out_blocks = encrypt(blocks)

解密脚本直接逆着写就行，这里的输入是32位的，然后分块。
```python
Sbox = [12, 5, 6, 11, 9, 0, 10, 13, 3, 14, 15, 8, 4, 7, 1, 2]

Sbox_inv = [Sbox.index(x) for x in range(16)]

PBox = [
    0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,
    4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,
    8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,
    12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63
]

PBox_inv = [PBox.index(x) for x in range(64)]


def addRoundKey(state, roundkey):
    return state ^ roundkey


def generateRoundkeys80(key, rounds):
    roundkeys = []
    for i in range(1, rounds + 1):
        roundkeys.append(key &gt;&gt; 16)

        key = ((key &amp; 524287) &lt;&lt; 61) + (key &gt;&gt; 19)

        key = (Sbox[key &gt;&gt; 76] &lt;&lt; 76) + (key &amp; ((2 ** 76) - 1))

        key ^= (i &lt;&lt; 15)
    return roundkeys


def inv_sBoxLayer(state):
    output = 0
    for i in range(16):
        output += Sbox_inv[(state &gt;&gt; (i * 4)) &amp; 15] &lt;&lt; (i * 4)
    return output


def inv_pLayer(state):
    output = 0
    for i in range(64):
        output += ((state &gt;&gt; i) &amp; 1) &lt;&lt; PBox_inv[i]
    return output


def number2string(n):
    chars = []
    for i in range(8):
        chars.append(chr((n &gt;&gt; (i * 8)) &amp; 0xFF))
    return &#39;&#39;.join(chars)


def decrypt(ciphers):
    rounds = 32
    roundkeys = generateRoundkeys80(85354531916197809168417, rounds)
    out = []

    for cipher in ciphers:
        state = cipher

        for i in range(rounds - 1, 0, -1):
            state = addRoundKey(state, roundkeys[i])
            state = inv_pLayer(state)
            state = inv_sBoxLayer(state)

        block = addRoundKey(state, roundkeys[0])
        out.append(number2string(block))

    return &#39;&#39;.join(out)


cmps = [120617461261311902, 16357837616839286114, 312508749794633008, 1843701600916795272]

decrypted_flag = decrypt(cmps)
print(decrypted_flag)

## 非对称

#### RSA

```python
import gmpy2
from Crypto.Util.number import long_to_bytes
e = 65537
n = 36618139579386063246087882054063631367923586826293230665209915187491823328978276724908066032487515386697740611819366867179565337532194305783987450587518624526250530134446397
c = 3053043969587277731075013823380664207370991627277672374256662715889363487017560381573682876563907215099359894935326265406537547932246927604121814198201993671878573628633125
p=[521,521,521,541,547,557,557,577,587,593,601,607,631,631,631,631,641,643,683,701,701,719,727,727,727,733,739,739,743,757,761,769,773,787,787,809,821,821,821,863,877,877,881,907,907,907,907,907,919,919,929,937,953,953,967,967,991,997,997,1019]

p.append(521)
phi=1
a=0
for i in p:
    if (a==i):
        phi*=i
    phi*=i-1
    a=i

# phi = (p - 1) * (q - 1)
# n = p * q
d = gmpy2.invert(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
</code></pre>
<h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><h4 id="sha系列"><a href="#sha系列" class="headerlink" title="sha系列"></a>sha系列</h4><p>cyberchef本地请</p>
<pre><code class="cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include &lt;math.h&gt;

#define GROUP_SIZE 64 
#define MAX_SIZE 1024

unsigned int const K[64] =&#123;
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,  
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,  
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,  
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,  
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,  
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,  
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,  
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2  
   &#125;;


unsigned int ROR(unsigned int x, unsigned int n);
unsigned int SHR(unsigned int x,unsigned int n);
unsigned int Ch(unsigned int E,unsigned int F,unsigned int G);
unsigned int Maj(unsigned int A,unsigned int B,unsigned int C);
unsigned int Lsigma_0(unsigned int A);
unsigned int Lsigma_1(unsigned int E);
unsigned int Ssigma_0(unsigned int x);
unsigned int Ssigma_1(unsigned int x);

void sha_init(unsigned int *A,unsigned int *B,unsigned int *C,unsigned int *D,unsigned int *E,unsigned int *F,unsigned int *G,unsigned int *H);
size_t sha_update(unsigned char **out, char const *input, size_t inLen);
void sha_transform(unsigned int *out,  char *input);
void data_round(unsigned int *A,unsigned int *B,unsigned int *C,unsigned int *D,unsigned int *E,unsigned int *F,unsigned int *G,unsigned int *H,unsigned int const *M);
void sha_calc(char *out, char const *input, size_t inLen);
</code></pre>
<h4 id="CRC32"><a href="#CRC32" class="headerlink" title="CRC32"></a>CRC32</h4><pre><code class="cpp">uint32_t crc32(const void* buf, size_t size) &#123;
    const uint8_t* p = buf;
    uint32_t crc = ~0U;
    while (size--) &#123;
        crc = crc32_tab[(crc ^ *p++) &amp; 0xFF] ^ (crc &gt;&gt; 8);
    &#125;
    return ~crc;
&#125;
uint crc32(byte *data, int size)
&#123;
    uint r = ~0; byte *end = data + size;
    while(data &lt; end)
    &#123;
        r ^= *data++;
        for(int i = 0; i &lt; 8; i++)
        &#123;
            uint t = ~((r&amp;1) — 1); r = (r&gt;&gt;1) ^ (0xEDB88320 &amp; t);
        &#125;
    &#125;
    return ~r;
&#125;
</code></pre>
<h4 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h4><p>cyberchef本地请</p>
<pre><code class="cpp">
#include &quot;md5.h&quot;


unsigned int ROTATE_LEFT(unsigned int x, unsigned int n) &#123;
    return ((x &lt;&lt; n) | (x &gt;&gt; (32 - n)));
&#125;

unsigned int F(unsigned int X, unsigned int Y, unsigned int Z) &#123;
    return (X &amp; Y) | ((~X) &amp; Z);
&#125;

unsigned int G(unsigned int X, unsigned int Y, unsigned int Z) &#123;
    return (X &amp; Z) | (Y &amp; (~Z));
&#125;

unsigned int H(unsigned int X, unsigned int Y, unsigned int Z) &#123;
    return (X ^ Y ^ Z);
&#125;

unsigned int I(unsigned int X, unsigned int Y, unsigned int Z) &#123;
    return (Y ^ (X | (~Z)));
&#125;

void FF(unsigned int *a,unsigned int b,unsigned int c,unsigned int d,unsigned int m,unsigned int const t,unsigned int s)&#123;
    *a += F(b,c,d) + m + t;
    *a = ROTATE_LEFT(*a,s);
    *a += b;
    
    return;
&#125;

void GG(unsigned int *a,unsigned int b,unsigned int c,unsigned int d,unsigned int m,unsigned int const t,unsigned int s)&#123;
    *a += G(b,c,d) + m + t;
    *a = ROTATE_LEFT(*a,s);
    *a += b;
    
    return;
&#125;

void HH(unsigned int *a,unsigned int b,unsigned int c,unsigned int d,unsigned int m,unsigned int const t,unsigned int s)&#123;
    *a += H(b,c,d) + m + t;
    *a = ROTATE_LEFT(*a,s);
    *a += b;
    
    return;
&#125;

void II(unsigned int *a,unsigned int b,unsigned int c,unsigned int d,unsigned int m,unsigned int const t,unsigned int s)&#123;
    *a += I(b,c,d) + m + t;
    *a = ROTATE_LEFT(*a,s);
    *a += b;
    
    return;
&#125;

unsigned int shift(unsigned int a)&#123;
    unsigned int t1,t2,t3,t4;
    t1 = (a &amp; 0xFF) &lt;&lt; 24;
    t2 = (a &amp; 0xFF00) &lt;&lt; 8;
    t3 = (a &gt;&gt; 8) &amp; 0xFF00;
    t4 = (a &gt;&gt; 24) &amp; 0xFF;
    //printf(&quot;%x\n&quot;,t1 + t2 + t3 + t4);
    return (t1 + t2 + t3 + t4);
&#125;
    


/* MD5 initialization */
void md5_init(unsigned int *A,unsigned int *B,unsigned int *C,unsigned int *D)&#123;
    unsigned char data[] = &#123;
        0x01, 0x23, 0x45, 0x67,
        0x89, 0xAB, 0xCD, 0xEF,
        0xFE, 0xDC, 0xBA, 0x98,
        0x76, 0x54, 0x32, 0x10
    &#125;;

    memcpy(A, data, 4);
    memcpy(B, data + 4, 4);
    memcpy(C, data + 8, 4);
    memcpy(D, data + 12, 4);
    return;
&#125;

size_t md5_update(char **out, char const *input, size_t inLen)&#123;
    int i;
    int j;

    size_t bitLen = inLen * 8; // the bit length of input
    //size_t fillLen = 64 - (inLen - 56) % 64;  // the length of padding 
    //printf(&quot;len:%d\n&quot;,fillLen);
    size_t fillLen = 56 - (inLen % 64);
    //printf(&quot;temp:%d\n&quot;,temp);
    size_t filledLen = inLen + fillLen + 8; // the length after padding

    char *outBuf = (char*)calloc(filledLen, sizeof(char));
    memcpy(outBuf, input, inLen);
    outBuf[inLen] = 0x80;// padding 1
    

    j = sizeof(inLen);  // the length of input_lengh
    for (i = 0; i &lt; j; i++) &#123;
        memcpy(outBuf + filledLen - 8 + i, (char*)(&amp;bitLen) + i, 1); // LittleEndian
        //memcpy(outBuf + filledLen - 4 + i, (char*)(&amp;bitLen) + j - 1 - i, 1);
        
    &#125;

    *out = outBuf;  // the data after padding
    return filledLen; 
&#125;


void md5_transform(unsigned int *out,  char *input)&#123;
    memcpy(out,input,GROUP_SIZE);
    return;

&#125;




void data_round(unsigned int *A, unsigned int *B, unsigned int *C, unsigned int *D, unsigned int const *m)&#123;
    //int k;
    unsigned int a = *A;
    unsigned int b = *B;
    unsigned int c = *C;
    unsigned int d = *D;

    /* round 1 */
    FF(&amp;a,b,c,d,m[0],T[0],S[0]);
    FF(&amp;d,a,b,c,m[1],T[1],S[1]);
    FF(&amp;c,d,a,b,m[2],T[2],S[2]);
    FF(&amp;b,c,d,a,m[3],T[3],S[3]);
    FF(&amp;a,b,c,d,m[4],T[4],S[0]);
    FF(&amp;d,a,b,c,m[5],T[5],S[1]);
    FF(&amp;c,d,a,b,m[6],T[6],S[2]);
    FF(&amp;b,c,d,a,m[7],T[7],S[3]);	
    FF(&amp;a,b,c,d,m[8],T[8],S[0]);
    FF(&amp;d,a,b,c,m[9],T[9],S[1]);
    FF(&amp;c,d,a,b,m[10],T[10],S[2]);
    FF(&amp;b,c,d,a,m[11],T[11],S[3]);
    FF(&amp;a,b,c,d,m[12],T[12],S[0]);
    FF(&amp;d,a,b,c,m[13],T[13],S[1]);
    FF(&amp;c,d,a,b,m[14],T[14],S[2]);
    FF(&amp;b,c,d,a,m[15],T[15],S[3]);
    
    /* round 2 */
    GG(&amp;a,b,c,d,m[1],T[16],S[4]);
    GG(&amp;d,a,b,c,m[6],T[17],S[5]);
    GG(&amp;c,d,a,b,m[11],T[18],S[6]);
    GG(&amp;b,c,d,a,m[0],T[19],S[7]);
    GG(&amp;a,b,c,d,m[5],T[20],S[4]);
    GG(&amp;d,a,b,c,m[10],T[21],S[5]);
    GG(&amp;c,d,a,b,m[15],T[22],S[6]);
    GG(&amp;b,c,d,a,m[4],T[23],S[7]);
    GG(&amp;a,b,c,d,m[9],T[24],S[4]);
    GG(&amp;d,a,b,c,m[14],T[25],S[5]);
    GG(&amp;c,d,a,b,m[3],T[26],S[6]);
    GG(&amp;b,c,d,a,m[8],T[27],S[7]);
    GG(&amp;a,b,c,d,m[13],T[28],S[4]);
    GG(&amp;d,a,b,c,m[2],T[29],S[5]);
    GG(&amp;c,d,a,b,m[7],T[30],S[6]);
    GG(&amp;b,c,d,a,m[12],T[31],S[7]);

    /* round 3 */
     HH(&amp;a,b,c,d,m[5],T[32],S[8]);
     HH(&amp;d,a,b,c,m[8],T[33],S[9]);
     HH(&amp;c,d,a,b,m[11],T[34],S[10]);
     HH(&amp;b,c,d,a,m[14],T[35],S[11]);
     HH(&amp;a,b,c,d,m[1],T[36],S[8]);
     HH(&amp;d,a,b,c,m[4],T[37],S[9]);
     HH(&amp;c,d,a,b,m[7],T[38],S[10]);
     HH(&amp;b,c,d,a,m[10],T[39],S[11]);
     HH(&amp;a,b,c,d,m[13],T[40],S[8]);
     HH(&amp;d,a,b,c,m[0],T[41],S[9]);
     HH(&amp;c,d,a,b,m[3],T[42],S[10]);
     HH(&amp;b,c,d,a,m[6],T[43],S[11]);
     HH(&amp;a,b,c,d,m[9],T[44],S[8]);
     HH(&amp;d,a,b,c,m[12],T[45],S[9]);
     HH(&amp;c,d,a,b,m[15],T[46],S[10]);
     HH(&amp;b,c,d,a,m[2],T[47],S[11]);
  
    /* round 4 */
    II(&amp;a,b,c,d,m[0],T[48],S[12]);
    II(&amp;d,a,b,c,m[7],T[49],S[13]);
    II(&amp;c,d,a,b,m[14],T[50],S[14]);
    II(&amp;b,c,d,a,m[5],T[51],S[15]);
    II(&amp;a,b,c,d,m[12],T[52],S[12]);
    II(&amp;d,a,b,c,m[3],T[53],S[13]);
    II(&amp;c,d,a,b,m[10],T[54],S[14]);
    II(&amp;b,c,d,a,m[1],T[55],S[15]);
    II(&amp;a,b,c,d,m[8],T[56],S[12]);
    II(&amp;d,a,b,c,m[15],T[57],S[13]);
    II(&amp;c,d,a,b,m[6],T[58],S[14]);
    II(&amp;b,c,d,a,m[13],T[59],S[15]);
    II(&amp;a,b,c,d,m[4],T[60],S[12]);
    II(&amp;d,a,b,c,m[11],T[61],S[13]);
    II(&amp;c,d,a,b,m[2],T[62],S[14]);
    II(&amp;b,c,d,a,m[9],T[63],S[15]);

    *A += a;
    *B += b;
    *C += c;
    *D += d;
&#125;


void md5_calc(char *out, char const *input, size_t inLen)&#123;
    int i;
    size_t filledLen;
    char *filledData; 
    unsigned int A,B,C,D;
    unsigned int *M = (unsigned int*)malloc(GROUP_SIZE);

    filledLen = md5_update(&amp;filledData,input,inLen);  

    //printf(&quot;input:%s\n&quot;,input);
    
    md5_init(&amp;A,&amp;B,&amp;C,&amp;D);
    //printf(&quot;%x\n%x\n%x\n%x\n&quot;,A,B,C,D);

    for(i = 0;i &lt; filledLen / GROUP_SIZE;i++)&#123;
        md5_transform(M, filledData + i * 64);  //char to int 
        data_round(&amp;A,&amp;B,&amp;C,&amp;D,M);
    &#125;

    //printf(&quot;%x\n%x\n%x\n%x\n&quot;,A,B,C,D); 

    sprintf(out,&quot;%08x%08x%08x%08x&quot;,shift(A),shift(B),shift(C),shift(D));

    free(M);
    M = NULL;
    free(filledData);
    filledData = NULL;

    return;

&#125;
</code></pre>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="大数计算"><a href="#大数计算" class="headerlink" title="大数计算"></a>大数计算</h3><h3 id="base系列"><a href="#base系列" class="headerlink" title="base系列"></a>base系列</h3><h4 id="base64换表"><a href="#base64换表" class="headerlink" title="base64换表"></a>base64换表</h4><pre><code class="python">&quot;&quot;&quot;
Customized base64 algorithm
You can set you own indexing string using the config() method.
Usage:
    b = CusBase64()
    b.encode(&#39;binary\x00string&#39;)  # Output: YmluYXJ5AHN0cmluZw==
    b.decode(&#39;YmluYXJ5AHN0cmluZw==&#39;) # Output: binary\x00string
    b.config(&#39;aABCDEFGHIJKLMNOPQRSTUVWXYZbcdefghijklmnopqrstuvwxyz0123456789+/&#39;)
    b.decode(&#39;c2UsYi1kYWM0cnUjdFlvbiAjb21wbFU0YP==&#39;) # Output: self-destruction complete
&quot;&quot;&quot;
class CusBase64(object):
    DEFAULT = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;

    def __init__(self):
        self.idx_str = CusBase64.DEFAULT

    def encode(self, str):
        &quot;&quot;&quot;
        Encode string using the customized indexing string.
        - args:
            str: String to be encoded
        &quot;&quot;&quot;
        # Get the binary string
        binary = &#39;&#39;.join([format(ord(c),&#39;0&gt;8b&#39;) for c in str])
        # Add additional zero
        binary = self.padding(binary)
        # Get the index in indexing string
        idxs = [int(binary[6*i:6*i+6], 2) for i in range(len(binary)//6)]

        result = &#39;&#39;.join([self.idx_str[i] for i in idxs])
        # add &#39;=&#39;
        if len(str)%3 != 0:
            result = result + (3-len(str)%3)*&#39;=&#39;

        print(&quot;%r&quot; % result)


    def decode(self, str):
        &quot;&quot;&quot;
        Decode string using the customized indexing string.
        - args:
            str: String to be decoded
        &quot;&quot;&quot;
        if len(str) == 0:
            return

        # remove &#39;=&#39;
        while str[-1]==&#39;=&#39;:
            str = str[:-1]
        try:
            # Get the binary string
            binary = &#39;&#39;.join([format(self.idx_str.index(c), &#39;0&gt;6b&#39;) for c in str])

            # Remove additional zero
            binary = self.remove(binary)

            result = &#39;&#39;.join([chr(int(binary[8*i:8*i+8], 2)) for i in range(len(binary)//8)])
        except ValueError:
            result = &quot;Please check again!&quot;

        print(&quot;%r&quot; % result)

    def remove(self, binary):
        &quot;&quot;&quot;
        Remove additional zero while decoding string.
        - args:
            binary: Binary format of the index.
        - returns:
            Binary string without additional zero.
        &quot;&quot;&quot;
        if len(binary)%8 == 0:
            return binary
        else:
            return binary[:-(len(binary)%8)]

    def padding(self, binary):
        &quot;&quot;&quot;
        Add additional zero while encoding string.
        - args:
            binary: Binary format of the string.
        - returns:
            Binary string with additional zero.
        &quot;&quot;&quot;
        if len(binary)%6 == 0:
            return binary
        n = 6 - len(binary)%6
        binary = binary + n * &#39;0&#39;
        return binary


    def config(self, str):
        &quot;&quot;&quot;
        Set customized indexing string.
        &quot;&quot;&quot;
        self.idx_str = str
        print(&quot;New indexing string is %r&quot; % self.idx_str)

b = CusBase64()
b.config(&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;)
b.encode(&#39;flag&#123;this_is_a_sample_flag&#125;&#39;)
b.decode(&#39;mg6CITV6GEaFDTYnObFmENOAVjKcQmGncF90WhqvCFyhhsyqq1s=&#39;)
</code></pre>
<h4 id="base58"><a href="#base58" class="headerlink" title="base58"></a>base58</h4><pre><code class="go">package main

import (
    &quot;bytes&quot;
    &quot;math/big&quot;
)

var b58Alphabet = []byte(&quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;)

func Base58Encode(input []byte) []byte &#123;
    var result []byte

    x := big.NewInt(0).SetBytes(input)

    base := big.NewInt(int64(len(b58Alphabet)))
    zero := big.NewInt(0)
    mod := &amp;big.Int&#123;&#125;

    for x.Cmp(zero) != 0 &#123;
        x.DivMod(x, base, mod)
        result = append(result, b58Alphabet[mod.Int64()])
    &#125;

    ReverseBytes(result)

    for _, b := range input &#123;
        if b == 0x00 &#123;
            result = append([]byte&#123;b58Alphabet[0]&#125;, result...)

        &#125; else &#123;
            break
        &#125;
    &#125;

    return result

&#125;

func Base58Decode(input []byte) []byte &#123;
    result := big.NewInt(0)
    zeroBytes := 0

    for _, b := range input &#123;
        if b != b58Alphabet[0] &#123;
            break
        &#125;

        zeroBytes++
    &#125;

    payload := input[zeroBytes:]
    for _, b := range payload &#123;
        charIndex := bytes.IndexByte(b58Alphabet, b)
        result.Mul(result, big.NewInt(int64(len(b58Alphabet))))
        result.Add(result, big.NewInt(int64(charIndex)))
    &#125;

    decoded := result.Bytes()
    decoded = append(bytes.Repeat([]byte&#123;byte(0x00)&#125;, zeroBytes), decoded...)

    return decoded
&#125;

</code></pre>

    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2024 Moyao の小屋
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Moyao
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>