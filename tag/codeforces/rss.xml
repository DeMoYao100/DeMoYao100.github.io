<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Moyao の小屋 • Posts by &#34;codeforces&#34; tag</title>
        <link>https://demoyao100.github.io</link>
        <description>Write down something interesting I met&lt;br /&gt;
Feel free to mail me if you have something wanted to talk about, plz
mail: &amp;lt;moyaoxue@outlook.com&amp;gt;
</description>
        <language>en</language>
        <pubDate>Fri, 02 Sep 2022 23:11:43 +0800</pubDate>
        <lastBuildDate>Fri, 02 Sep 2022 23:11:43 +0800</lastBuildDate>
        <category>re</category>
        <category>Android</category>
        <category>开发</category>
        <category>codeforces</category>
        <category>cv</category>
        <category>docker</category>
        <category>驱动</category>
        <category>electron</category>
        <category>ios</category>
        <category>杂文</category>
        <category>web</category>
        <category>jail</category>
        <category>IOT</category>
        <category>re Android linux</category>
        <category>web shiro</category>
        <category>python</category>
        <category>hexo</category>
        <category>pentesting</category>
        <category>car</category>
        <item>
            <guid isPermalink="true">https://demoyao100.github.io/codeforce-817E/</guid>
            <title>codeforce-817E</title>
            <link>https://demoyao100.github.io/codeforce-817E/</link>
            <category>codeforces</category>
            <pubDate>Fri, 02 Sep 2022 23:11:43 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;codeforces-817e&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#codeforces-817e&#34;&gt;#&lt;/a&gt; codeforces 817E&lt;/h1&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h3 id=&#34;the-problem&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#the-problem&#34;&gt;#&lt;/a&gt; The problem&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;E. Counting Rectangles&lt;br&gt;
time limit per test6 seconds&lt;br&gt;
memory limit per test256 megabytes&lt;br&gt;
inputstandard input&lt;br&gt;
outputstandard output&lt;br&gt;
You have n rectangles, the i-th rectangle has height hi and width wi.&lt;br&gt;
You are asked q queries of the form hs ws hb wb.&lt;br&gt;
For each query output, the total area of rectangles you own that can fit a rectangle of height hs and width ws while also fitting in a rectangle of height hb and width wb. In other words, print ∑hi⋅wi for i such that hs&amp;lt;hi&amp;lt;hb and ws&amp;lt;wi&amp;lt;wb.&lt;br&gt;
Please note, that if two rectangles have the same height or the same width, then they cannot fit inside each other. Also note that you cannot rotate rectangles.&lt;br&gt;
Please note that the answer for some test cases won’t fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for C++).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input&lt;br&gt;
The first line of the input contains an integer t (1≤t≤100) — the number of test cases.&lt;br&gt;
The first line of each test case two integers n,q (1≤n≤105; 1≤q≤105) — the number of rectangles you own and the number of queries.&lt;br&gt;
Then n lines follow, each containing two integers hi,wi (1≤hi,wi≤1000) — the height and width of the i-th rectangle.&lt;br&gt;
Then q lines follow, each containing four integers hs,ws,hb,wb (1≤hs&amp;lt;hb, ws&amp;lt;wb≤1000) — the description of each query.&lt;br&gt;
The sum of q over all test cases does not exceed 105, and the sum of n over all test cases does not exceed 105.&lt;br&gt;
Output&lt;br&gt;
For each test case, output q lines, the i-th line containing the answer to the i-th query.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Example&lt;br&gt;
inputCopy&lt;br&gt;
3&lt;br&gt;
2 1&lt;br&gt;
2 3&lt;br&gt;
3 2&lt;br&gt;
1 1 3 4&lt;br&gt;
5 5&lt;br&gt;
1 1&lt;br&gt;
2 2&lt;br&gt;
3 3&lt;br&gt;
4 4&lt;br&gt;
5 5&lt;br&gt;
3 3 6 6&lt;br&gt;
2 1 4 5&lt;br&gt;
1 1 2 10&lt;br&gt;
1 1 100 100&lt;br&gt;
1 1 3 3&lt;br&gt;
3 1&lt;br&gt;
999 999&lt;br&gt;
999 999&lt;br&gt;
999 998&lt;br&gt;
1 1 1000 1000&lt;br&gt;
outputCopy&lt;br&gt;
6&lt;br&gt;
41&lt;br&gt;
9&lt;br&gt;
0&lt;br&gt;
54&lt;br&gt;
4&lt;br&gt;
2993004&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;note&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#note&#34;&gt;#&lt;/a&gt; Note&lt;/h5&gt;
&lt;h5 id=&#34;in-the-first-test-case-there-is-only-one-query-we-need-to-find-the-sum-of-areas-of-all-rectangles-that-can-fit-a-11-rectangle-inside-of-it-and-fit-into-a-34-rectangle&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#in-the-first-test-case-there-is-only-one-query-we-need-to-find-the-sum-of-areas-of-all-rectangles-that-can-fit-a-11-rectangle-inside-of-it-and-fit-into-a-34-rectangle&#34;&gt;#&lt;/a&gt; In the first test case, there is only one query. We need to find the sum of areas of all rectangles that can fit a 1×1 rectangle inside of it and fit into a 3×4 rectangle.&lt;/h5&gt;
&lt;h5 id=&#34;only-the-23-rectangle-works-because-12-comparing-heights-and-13-comparing-widths-so-the-11-rectangle-fits-inside-and-23-comparing-heights-and-34-comparing-widths-so-it-fits-inside-the-34-rectangle-color&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#only-the-23-rectangle-works-because-12-comparing-heights-and-13-comparing-widths-so-the-11-rectangle-fits-inside-and-23-comparing-heights-and-34-comparing-widths-so-it-fits-inside-the-34-rectangle-color&#34;&gt;#&lt;/a&gt; Only the 2×3 rectangle works, because 1&amp;lt;2 (comparing heights) and 1&amp;lt;3 (comparing widths), so the 1×1 rectangle fits inside, and 2&amp;lt;3 (comparing heights) and 3&amp;lt;4 (comparing widths), so it fits inside the 3×4 rectangle. $\color&lt;/h5&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://demoyao100.github.io/codeforce-1719C/</guid>
            <title>codeforce-1719C</title>
            <link>https://demoyao100.github.io/codeforce-1719C/</link>
            <category>codeforces</category>
            <pubDate>Mon, 29 Aug 2022 11:24:57 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;codeforces-1719c&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#codeforces-1719c&#34;&gt;#&lt;/a&gt; codeforces 1719C&lt;/h1&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h3 id=&#34;the-problem&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#the-problem&#34;&gt;#&lt;/a&gt; The problem&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;C. Fighting Tournament&lt;br&gt;
time limit per test2 seconds&lt;br&gt;
memory limit per test256 megabytes&lt;br&gt;
inputstandard input&lt;br&gt;
outputstandard output&lt;br&gt;
Burenka is about to watch the most interesting sporting event of the year — a fighting tournament organized by her friend Tonya.&lt;br&gt;
n athletes participate in the tournament, numbered from 1 to n. Burenka determined the strength of the i-th athlete as an integer ai, where 1≤ai≤n. All the strength values are different, that is, the array a is a permutation of length n. We know that in a fight, if ai&amp;gt;aj, then the i-th participant always wins the j-th.&lt;br&gt;
The tournament goes like this: initially, all n athletes line up in ascending order of their ids, and then there are infinitely many fighting rounds. In each round there is exactly one fight: the first two people in line come out and fight. The winner goes back to the front of the line, and the loser goes to the back.&lt;br&gt;
Burenka decided to ask Tonya q questions. In each question, Burenka asks how many victories the i-th participant gets in the first k rounds of the competition for some given numbers i and k. Tonya is not very good at analytics, so he asks you to help him answer all the questions.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input&lt;br&gt;
The first line contains one integer t (1≤t≤104) — the number of test cases. Description of the test cases follows.&lt;br&gt;
The first line of each test case contains two integers n and q (2≤n≤105, 1≤q≤105) — the number of tournament participants and the number of questions.&lt;br&gt;
The second line of each test case contains n integers a1,a2,…,an (1≤ai≤n) — the array a, which is a permutation.&lt;br&gt;
The next q lines of a test case contain questions. Each line contains two integers i and k (1≤i≤n, 1≤k≤109) — the number of the participant and the number of rounds.&lt;br&gt;
It is guaranteed that the sum of n and the sum of q over all test cases do not exceed 105.&lt;br&gt;
Output&lt;br&gt;
For each Burenka’s question, print a single line containing one integer — the answer to the question.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;!--more--&gt;
&lt;h4 id=&#34;preface&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#preface&#34;&gt;#&lt;/a&gt; Preface&lt;/h4&gt;
&lt;h5 id=&#34;its-not-a-very-hard-problem-but-contains-many-details-this-is-the-record-when-i-tried&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#its-not-a-very-hard-problem-but-contains-many-details-this-is-the-record-when-i-tried&#34;&gt;#&lt;/a&gt; It’s not a very hard problem, but contains many details. This is the record when I tried:&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;/codeforce-1719C/1719C.png&#34; alt&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&#34;the-basic-solution-for-this-problem-is-to-find-out-if-there-are-numbers-bigger-then-ai-if-so-the-guy-with-the-number-i-can-not-win-anybody-else-tried-to-find-the-number-of-the-guys-after-him-with-smaller-a-this-number-is-the-biggest-number-of-his-victories-you-might-notices-if-the-guy-is-the-best-in-the-whole-queue-then-he-can-win-any-guys-he-metdepend-how-big-the-k-is-others-can-not-because-they-may-met-this-guy-and-his-game-can-be-called-over&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#the-basic-solution-for-this-problem-is-to-find-out-if-there-are-numbers-bigger-then-ai-if-so-the-guy-with-the-number-i-can-not-win-anybody-else-tried-to-find-the-number-of-the-guys-after-him-with-smaller-a-this-number-is-the-biggest-number-of-his-victories-you-might-notices-if-the-guy-is-the-best-in-the-whole-queue-then-he-can-win-any-guys-he-metdepend-how-big-the-k-is-others-can-not-because-they-may-met-this-guy-and-his-game-can-be-called-over&#34;&gt;#&lt;/a&gt; The basic solution for this problem is to find out if there are numbers bigger then a[i], if so, the guy with the number i CAN NOT WIN ANYBODY, else, tried to find the number of the guys AFTER HIM with smaller a[]. This number is the BIGGEST number of his victories. You might notices, if the guy is the best in the whole queue, then he can win any guys he met(depend how big the k is), others can not because they may met this guy and his game can be called “over”.&lt;/h5&gt;
&lt;h4 id=&#34;details&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#details&#34;&gt;#&lt;/a&gt; DETAILS&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h5 id=&#34;the-first-and-second-guy-is-special-they-fight-each-other-you-can-see-that-i2-can-use-the-same-formula-so-you-shall-judge-i1-specially-the-biggest-a-shall-also-be-judge-specially-with-those-you-answer-shall-be-right&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#the-first-and-second-guy-is-special-they-fight-each-other-you-can-see-that-i2-can-use-the-same-formula-so-you-shall-judge-i1-specially-the-biggest-a-shall-also-be-judge-specially-with-those-you-answer-shall-be-right&#34;&gt;#&lt;/a&gt; The first and second guy is special. They fight each other. You can see that (i&amp;gt;=2) can use the same formula. So you shall judge (i==1) specially. The biggest a[] shall also be judge specially. With those, you answer shall be right.&lt;/h5&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;however-you-might-get-a-tlewelli-did-this-is-how-i-wrote-previously&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#however-you-might-get-a-tlewelli-did-this-is-how-i-wrote-previously&#34;&gt;#&lt;/a&gt; However, you might get a “TLE”(Well,I did). This is how I wrote previously:&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;//		for (i=1;i&amp;lt;=n;i++)&amp;#123;&lt;/code&gt; 	&lt;br&gt;
 &lt;code&gt;//			if (a[i]==maxn) continue;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//			for (j=i+1;j&amp;lt;=n;j++)&amp;#123;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//				if (a[j]&amp;gt;=a[i]) break;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//				b[i]++;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//&amp;#125;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//			b[i]++;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//			if (i==1) b[i]--;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//			for (j=1;j&amp;lt;i;j++)&amp;#123;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//				if (a[j]&amp;gt;a[i])&amp;#123;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//					b[i]=0;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//					break;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//				&amp;#125;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//			&amp;#125;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;//		&amp;#125;&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;clearly-on2-is-too-slow-so-i-tried-to-find-another-way&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#clearly-on2-is-too-slow-so-i-tried-to-find-another-way&#34;&gt;#&lt;/a&gt; Clearly, O(n^2) is too slow. So I tried to find another way.&lt;/h5&gt;
&lt;h5 id=&#34;we-can-find-that-the-whole-work-can-be-done-in-linear-time-like-this&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#we-can-find-that-the-whole-work-can-be-done-in-linear-time-like-this&#34;&gt;#&lt;/a&gt; We can find that the whole work can be done in LINEAR TIME. Like this:&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;		int lld=1;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;		for (i=1;i&amp;lt;n;i++)&amp;#123;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;			if (a[i]&amp;gt;a[i+1])&amp;#123;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;				b[lld]++;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;				a[i+1]=a[i];&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;			&amp;#125;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;			else&amp;#123;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;				lld=i+1;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;				b[lld]++;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;			&amp;#125;&lt;/code&gt; &lt;br&gt;
 &lt;code&gt;		&amp;#125;&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;its-not-hard-to-understand-but-effective-just-read-it-oncein-on-the-work-is-done&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#its-not-hard-to-understand-but-effective-just-read-it-oncein-on-the-work-is-done&#34;&gt;#&lt;/a&gt; It’s not hard to understand, but effective. Just read it once(in O(n)), the work is done.&lt;/h5&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://demoyao100.github.io/codeforce-1720C/</guid>
            <title>codeforce:1720C</title>
            <link>https://demoyao100.github.io/codeforce-1720C/</link>
            <category>codeforces</category>
            <pubDate>Sun, 28 Aug 2022 09:37:21 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;codeforces-1720c&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#codeforces-1720c&#34;&gt;#&lt;/a&gt; codeforces 1720C&lt;/h1&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h3 id=&#34;the-problem&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#the-problem&#34;&gt;#&lt;/a&gt; The problem&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;C. Corners&lt;br&gt;
time limit per test1 second&lt;br&gt;
memory limit per test256 megabytes&lt;br&gt;
inputstandard input&lt;br&gt;
outputstandard output&lt;br&gt;
You are given a matrix consisting of n rows and m columns. Each cell of this matrix contains 0 or 1.&lt;br&gt;
Let’s call a square of size 2×2 without one corner cell an L-shape figure. In one operation you can take one L-shape figure, with at least one cell containing 1 and replace all numbers in it with zeroes.&lt;br&gt;
Find the maximum number of operations that you can do with the given matrix.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Input&lt;br&gt;
The first line contains one integer t (1≤t≤500) — the number of test cases. Then follow the descriptions of each test case.&lt;br&gt;
The first line of each test case contains two integers n and m (2≤n,m≤500) — the size of the matrix.&lt;br&gt;
Each of the following n lines contains a binary string of length m — the description of the matrix.&lt;br&gt;
It is guaranteed that the sum of n and the sum of m over all test cases does not exceed 1000.&lt;br&gt;
Output&lt;br&gt;
For each test case output the maximum number of operations you can do with the given matrix.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;!--more--&gt;
&lt;h5 id=&#34;at-first-i-didnt-have-a-clue-so-i-tried-to-do-a-brute-force-didnt-work-out-of-coursethe-data-volume-is-too-large-so-i-was-wondering-whether-it-could-be-solved-by-dynamic-programing-i-tried-this&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#at-first-i-didnt-have-a-clue-so-i-tried-to-do-a-brute-force-didnt-work-out-of-coursethe-data-volume-is-too-large-so-i-was-wondering-whether-it-could-be-solved-by-dynamic-programing-i-tried-this&#34;&gt;#&lt;/a&gt; At first, I didn’t have a clue. So I tried to do a brute force. Didn’t work out of course.The data volume is too large. So I was wondering whether it could be solved by dynamic programing. I tried this:&lt;/h5&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;sum[x][y]=max(sum[x-1][y-1]+b[x][y]-b[x-1][y-1],sum[x-2][y-2]+b[x][y]-b[x-2][y-2])&lt;/code&gt;&lt;/p&gt;
&lt;h6 id=&#34;sum-stands-for-the-maximum-number-we-need-to-solve-and-bxy-stands-for-the-sum-of-a1~x1~y&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#sum-stands-for-the-maximum-number-we-need-to-solve-and-bxy-stands-for-the-sum-of-a1~x1~y&#34;&gt;#&lt;/a&gt; sum[][] stands for the maximum number we need to solve, and b[x][y] stands for the sum of a[1~x][1~y].&lt;/h6&gt;
&lt;h5 id=&#34;it-seemed-closed-but-got-a-wa-well-the-initial-square-was-harder-to-define-then-i-thought-after-a-few-tried-i-decided-to-abandon-this-dp-method&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#it-seemed-closed-but-got-a-wa-well-the-initial-square-was-harder-to-define-then-i-thought-after-a-few-tried-i-decided-to-abandon-this-dp-method&#34;&gt;#&lt;/a&gt; It seemed closed, but got a WA. Well, the initial square was harder to define then I thought. After a few tried, I decided to abandon this dp method.&lt;/h5&gt;
&lt;h5 id=&#34;it-was-some-time-before-the-right-answer-occur-to-me-its-actually-pretty-easy&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#it-was-some-time-before-the-right-answer-occur-to-me-its-actually-pretty-easy&#34;&gt;#&lt;/a&gt; It was some time before the right answer occur to me. It’s actually pretty easy.&lt;/h5&gt;
&lt;h5 id=&#34;search-every-square-of-size-22-if-exists-one-square-contains-at-least-two-0then-the-maximum-number-is-the-number-of-1-else-the-maximun-number-is-the-number-of-1-1if-there-contains-0-or-the-maximun-number-is-the-number-of-1-2if-the-whole-square-is-1&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#search-every-square-of-size-22-if-exists-one-square-contains-at-least-two-0then-the-maximum-number-is-the-number-of-1-else-the-maximun-number-is-the-number-of-1-1if-there-contains-0-or-the-maximun-number-is-the-number-of-1-2if-the-whole-square-is-1&#34;&gt;#&lt;/a&gt; Search every square of size 2*2, if exists one square contains at least two ‘0’,then the maximum number is the number of ‘1’, else the maximun number is the number of ‘1’- 1(if there contains ‘0’) or the maximun number is the number of ‘1’- 2(if the whole square is ‘1’)&lt;/h5&gt;
 ]]></description>
        </item>
    </channel>
</rss>
