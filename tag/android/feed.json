{
    "version": "https://jsonfeed.org/version/1",
    "title": "Moyao の小屋 • All posts by \"android\" tag",
    "description": "Write down something interesting I met<br />\nFeel free to mail me if you have something wanted to talk about, plz\nmail: &lt;moyaoxue@outlook.com&gt;\n",
    "home_page_url": "https://demoyao100.github.io",
    "items": [
        {
            "id": "https://demoyao100.github.io/%E4%B8%8D%E5%90%8C%E7%9A%84android-hook%E5%A7%BF%E5%8A%BF/",
            "url": "https://demoyao100.github.io/%E4%B8%8D%E5%90%8C%E7%9A%84android-hook%E5%A7%BF%E5%8A%BF/",
            "title": "不同的android hook姿势",
            "date_published": "2024-05-03T10:55:01.000Z",
            "content_html": "<p>PREFACE：被拷打一排甚至没听过，之前确实一点不懂这个，爬来快速过一下</p>\n<span id=\"more\"></span>\n<h3 id=\"一-got表hook\"><a class=\"markdownIt-Anchor\" href=\"#一-got表hook\">#</a> 一、GOT 表 HOOK</h3>\n<p>参考：<a href=\"https://zhuanlan.zhihu.com/p/269441842\">PLT HOOK - 知乎 (zhihu.com)</a></p>\n<p>仅能 hook got 表中引用的函数，替换某个 SO 的外部调用，通过将外部函数调用跳转成我们的目标函数。</p>\n<p>当需要使用一个 Native 库（.so 文件）的时候，我们需要调用 dlopen (“<a href=\"http://libname.so\">libname.so</a>”) 来加载这个库。在我们调用了 dlopen (“<a href=\"http://libname.so\">libname.so</a>”) 之后，系统首先会检查缓存中已加载的 ELF 文件列表。如果未加载则执行加载过程，如果已加载则计数加一，忽略该调用。然后系统会用从 <a href=\"http://libname.so\">libname.so</a> 的 dynamic 节区中读取其所依赖的库，按照相同的加载逻辑，把未在缓存中的库加入加载列表。</p>\n<p><img src=\"/%E4%B8%8D%E5%90%8C%E7%9A%84android-hook%E5%A7%BF%E5%8A%BF/Untitled.png\" alt=\"Untitled\"></p>\n<ul>\n<li><strong>Relocation Outputs（输出）</strong></li>\n</ul>\n<ol>\n<li>.got.plt - 外部函数的绝对地址。</li>\n<li>.data，.data.rel.ro - 外部数据（包括函数指针）的绝对地址。</li>\n</ol>\n<ul>\n<li><strong>Relocation Tables（基本信息）</strong></li>\n</ul>\n<ol>\n<li>.rel.plt，.rela.plt 用于 “关联”.dynsym 和.got.plt。</li>\n<li>.rel.dyn，.rela.dyn，.rel.dyn.aps2，.rela.dyn.aps2 用于 “关联”.dynsym 和.data，.data.rel.ro。</li>\n<li>.relr.dyn 是 Android 11 新增的，仅用于 ELF 的内部相对 relocation（基地址重写）</li>\n</ol>\n<ul>\n<li><strong>符号信息（.dynsym 和 .dynstr）</strong></li>\n</ul>\n<ol>\n<li>.dynstr 是 “字符串池”，保存了动态链接过程中用到的所有字符串信息，比如：函数名，全局变量名。</li>\n<li>.dynsym 中包含了与符号关联的各种 “索引” 信息，起到 “关联” 和 “描述（符号类型 func/ifunc/object 等等）” 的作用。</li>\n<li>.dynsym 中的符号分为 “导入符号” 和 “导出符号”。SHN_UNDEF == st_shndx 为导入符号，SHN_UNDEF != st_shndx 为导出符号。</li>\n</ol>\n<p>加载 ELF 文件：</p>\n<ol>\n<li>读 ELF 的程序头部表，把所有 PT_LOAD 的节区 mmap 到内存中。</li>\n<li>从 “.dynamic” 中读取各信息项，计算并保存所有节区的虚拟地址，然后执行重定位操作。</li>\n<li>最后 ELF 加载成功，引用计数加一。</li>\n</ol>\n<p><strong>重定位：</strong></p>\n<ul>\n<li><strong>The Global Offset Table (GOT)</strong>。简单来说就是在数据段的地址表，假定我们有一些代码段的指令引用一些地址变量，编译器会引用 GOT 表来替代直接引用绝对地址，因为绝对地址在编译期是无法知道的，只有重定位后才会得到 ，GOT 自己本身将会包含函数引用的绝对地址。</li>\n<li><strong>The Procedure Linkage Table (PLT)</strong>。PLT 不同于 GOT，它位于代码段，动态库的每一个外部函数都会在 PLT 中有一条记录，每一条 PLT 记录都是一小段可执行代码。 一般来说，外部代码都是在调用 PLT 表里的记录，然后 PLT 的相应记录会负责调用实际的函数。我们一般把这种设定叫作 “蹦床”（Trampoline）。</li>\n</ul>\n<p>PLT 和 GOT 记录是一一对应的，并且 GOT 表第一次解析后会包含调用函数的实际地址。既然这样，那 PLT 的意义究竟是什么呢？PLT 从某种意义上赋予我们一种懒加载的能力。当动态库首次被加载时，所有的函数地址并没有被解析。</p>\n<p>![Untitled (1)](不同的 android-hook 姿势 / Untitled (1).png)</p>\n<h5 id=\"实现待自行探究\"><a class=\"markdownIt-Anchor\" href=\"#实现待自行探究\">#</a> 实现（待自行探究）</h5>\n<p>**（1）** 在内存中找到目标 ELF</p>\n<p><strong>方法 1：dl_iterate_phdr</strong></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>Linux 的标准 dl API，NDK 提供了支持，使用方便。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>arm32 中，Android version &gt;= 5.0（API level 21）时 NDK 才支持。</li>\n<li>Android 5.0 和 5.1（API level 21 和 22），dl_iterate_phdr 的实现不持 linker 全局锁，需要自己找 linker 的符号（__dl__ZL10g_dl_mutex）自己加锁。</li>\n<li>x86 平台 Android 4.x 的 dl_iterate_phdr () 也不持锁，而且 Android 4.x 的 linker 全局锁符号未导出。</li>\n<li>Android &lt; 8.1（API level 27）时，不能通过 dl_iterate_phdr 遍历到 linker /linker64。（aosp 从 8.0 开始已经包含了 linker/linker64，但是大量的其他厂商的设备是从 Android 8.1 开始包含 linker/linker64 的）</li>\n<li>部分 Android 4.x 和 Android 5.x 设备的 dl_iterate_phdr 只能返回 ELF 的 basename，而不是 pathname。</li>\n</ul>\n<p><strong>方法 2：dlopen (“<a href=\"http://libdl.so\">libdl.so</a>”) 返回 linker 内部的 struct soinfo list header，自己遍历</strong></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>能支持 Android 4.x。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>Android 4.x 的 linker 全局锁（gDlMutex）没有符号导出，直接遍历 struct soinfo list 容易挂。</li>\n<li>有一定的兼容性风险。</li>\n<li>部分 Android 4.x 和 Android 5.x 设备只能返回 ELF 的 basename，而不是 pathname。</li>\n</ul>\n<p><strong>方法 3：读 maps 自己解析 （/proc/self/maps）</strong></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>不用考虑 Android 4.x linker 全局锁的问题。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>有一定的兼容性风险。</li>\n</ul>\n<p><strong>最佳实践</strong></p>\n<p>Android 4.x：</p>\n<ul>\n<li>解析 maps，使用 “权限 r-xp” + “offset == 0” 来过滤，再检查 ELF magic header。（4.x 上 ELF 结构还是比较保守的，目前没有发现 r-xp 判定失败的情况）</li>\n<li>也可以先使用 dlopen (“<a href=\"http://libdl.so\">libdl.so</a>”) 的方式，但是兼容性需要更多的测试，如果读取失败，需要回到读 maps 的方式来处理。</li>\n</ul>\n<p>Android &gt;=5.0：</p>\n<ul>\n<li>使用 dl_iterate_phdr。</li>\n<li>对于 5.0/5.1，自己用__dl__ZL10g_dl_mutex 加锁。</li>\n<li>发现 ELF 名称为 basename 时，读 maps，从 maps 中查找对应的 pathname。</li>\n<li>需要 linker/linker64 的话，&lt; 8.1 时需要从 maps 中读取。</li>\n</ul>\n<ol>\n<li>hook 导入表，即 “调用方”。如果需要 hook 进程中对于某个函数的所有调用，这种方法是比较麻烦的，需要逐个 hook 内存中已经加载的所有 ELF，还需要监控 dlopen 和 android_dlopen_ext（以便感知到新加载的 ELF，再对它执行导入表 hook）。</li>\n<li>hook 导出表，即修改被调用方对应函数符号的 offset 值（.dynsym 中对应表项的 st_value），使 linker 通过修改后的新 st_value 来查找对应函数符号的内存绝对地址时，实际查找到的是内存中外部 ELF 的 hook 函数的地址，这样 linker 对新加载的 ELF 执行完 relocation 操作后，新 ELF 的相应调用就自然被 hook 到了我们指定的函数。</li>\n</ol>\n<ul>\n<li><strong>查找导入表符号的方法</strong></li>\n</ul>\n<p>当存在 SYSV hash 时，先尝试通过 SYSV hash 来查找。先后按顺序尝试查找：</p>\n<pre><code>.hash -&gt; .dynsym -&gt; .dynstr，时间复杂度：O(x) + O(1) + O(1) .dynsym -&gt; .dynstr，时间复杂度：O(n) + O(1)\n</code></pre>\n<ul>\n<li><strong>查找导出表符号的方法</strong></li>\n</ul>\n<p>优先使用 GNU hash，比 SYSV hash 更高效。先后按顺序尝试查找：</p>\n<pre><code>.gnu.hash -&gt; .dynsym -&gt; .dynstr，时间复杂度：O(x) + O(1) + O(1) .hash -&gt; .dynsym -&gt; .dynstr，时间复杂度：O(x) + O(1) + O(1)\n</code></pre>\n<ul>\n<li><strong>查找 .got.plt 中函数地址的方法</strong></li>\n</ul>\n<ol>\n<li>逐项遍历 .rel.plt 和.rela.plt 表，用上面已经找到的符号信息去比对，对应到即找到了地址的 offset（r_offset 项）</li>\n<li>将 r_offset 加上 ELF 的 “内存加载基地址”（load_bias）即为所得。</li>\n</ol>\n<ul>\n<li><strong>查找 .data 和 .data.rel.ro 中数据地址的方法</strong></li>\n</ul>\n<ol>\n<li>与上面查找 .got.plt 的过程相同，只是改为了遍历 .rel.dyn 和 .rela.dyn，以及 .rel.dyn.aps2 和 .rela.dyn.aps2。</li>\n</ol>\n<ul>\n<li><strong>修改数据（hook）</strong></li>\n</ul>\n<ol>\n<li>修改内存权限：使用 mprotect 将目标地址所在内存页改为可读可写</li>\n<li>修改数据：</li>\n</ol>\n<p>** 方法 1：** 直接赋值，再使用 __builtin___clear_cache 清除目标地址的 CPU cache。</p>\n<p>** 方法 2：** 使用 atomic 方式来赋值，比如：__atomic_store_n ((uintptr_t *) got_addr, (uintptr_t) new_func, __ATOMIC_SEQ_CST);</p>\n<h3 id=\"二-ldpreload_hook\"><a class=\"markdownIt-Anchor\" href=\"#二-ldpreload_hook\">#</a> 二、LDPRELOAD_HOOK</h3>\n<p>虚假的导入函数</p>\n<h3 id=\"三-inline-hook\"><a class=\"markdownIt-Anchor\" href=\"#三-inline-hook\">#</a> 三、inline hook</h3>\n<p>这个在 frida 源码里面看的比较多，这里简单看一下怎么检测</p>\n<h5 id=\"检测手段\"><a class=\"markdownIt-Anchor\" href=\"#检测手段\">#</a> 检测手段</h5>\n<p>CRC 校验：inline hook 会改函数写跳板，这样的话一个常见的思路就是对函数</p>\n<h3 id=\"四-异常-hook\"><a class=\"markdownIt-Anchor\" href=\"#四-异常-hook\">#</a> 四、异常 hook</h3>\n<h3 id=\"五-依赖库篡改-hook\"><a class=\"markdownIt-Anchor\" href=\"#五-依赖库篡改-hook\">#</a> 五、依赖库篡改 hook</h3>\n<h3 id=\"六-linker-hook\"><a class=\"markdownIt-Anchor\" href=\"#六-linker-hook\">#</a> 六、linker hook</h3>\n<h3 id=\"七-unicor\"><a class=\"markdownIt-Anchor\" href=\"#七-unicor\">#</a> 七、UNICOR</h3>\n<p><a href=\"https://github.com/acbocai/vergil\">https://github.com/acbocai/vergil</a></p>\n<p>参考：<a href=\"https://zhuanlan.zhihu.com/p/269441842\">PLT HOOK - 知乎 (zhihu.com)</a></p>\n<p>[<a href=\"https://bbs.kanxue.com/thread-254853.htm\">原创] 7 种 Android Native Anti Hook 的实现思路 - Android 安全 - 看雪 - 安全社区 | 安全招聘 | kanxue.com</a></p>\n",
            "tags": [
                "re",
                "Android"
            ]
        },
        {
            "id": "https://demoyao100.github.io/ACTF-flutter%E5%A4%8D%E7%8E%B0/",
            "url": "https://demoyao100.github.io/ACTF-flutter%E5%A4%8D%E7%8E%B0/",
            "title": "ACTF flutter复现",
            "date_published": "2024-03-28T12:57:57.000Z",
            "content_html": "<h6 id=\"rpeface写一个flutter程序以后自己逆逆呗一看刚好有个高版本flutter的题没复现~\"><a class=\"markdownIt-Anchor\" href=\"#rpeface写一个flutter程序以后自己逆逆呗一看刚好有个高版本flutter的题没复现~\">#</a> RPEFACE：写一个 flutter 程序以后自己逆逆呗，一看刚好有个高版本 flutter 的题没复现～</h6>\n<span id=\"more\"></span>\n<p>TO BE CONTINUE</p>\n",
            "tags": [
                "re",
                "Android"
            ]
        },
        {
            "id": "https://demoyao100.github.io/arm%E5%88%9D%E6%8E%A2/",
            "url": "https://demoyao100.github.io/arm%E5%88%9D%E6%8E%A2/",
            "title": "arm初探",
            "date_published": "2023-11-29T06:24:57.000Z",
            "content_html": "<h6 id=\"preface之前猜猜查查的感觉不彳亍了这下不得不和arm爆了\"><a class=\"markdownIt-Anchor\" href=\"#preface之前猜猜查查的感觉不彳亍了这下不得不和arm爆了\">#</a> PREFACE：之前猜猜查查的，感觉不彳亍了，这下不得不和 arm 爆了！</h6>\n<span id=\"more\"></span>\n<h3 id=\"架构介绍\"><a class=\"markdownIt-Anchor\" href=\"#架构介绍\">#</a> 架构介绍</h3>\n<p><img src=\"/arm%E5%88%9D%E6%8E%A2/V5_to_V8_Architecture.jpg\" alt=\"img\"></p>\n<p><img src=\"/arm%E5%88%9D%E6%8E%A2/evolution_arm_arch.png\" alt=\"img\"></p>\n<h5 id=\"架构层级\"><a class=\"markdownIt-Anchor\" href=\"#架构层级\">#</a> 架构层级</h5>\n<ul>\n<li>EL0: 无特权模式 (unprivileged)</li>\n<li>EL1: 作业系統核心模式 (OS kernel mode)</li>\n<li>EL2: 虚拟机器监视器模式 (Hypervisor mode)</li>\n<li>EL3: TrustZone(monitor mode)</li>\n</ul>\n<p>要提升到较高层级需要透过 exceptions (如：中断、page faults 等)。</p>\n<ul>\n<li>EL0 =&gt; EL1: SVC (system call)</li>\n<li>EL1 =&gt; EL2: HVC (hypervisor call)</li>\n<li>EL2 =&gt; EL3: SMC (secure monitor call)</li>\n</ul>\n<p>在转换时会将返回地址 (return address) 记录在例外连结寄存器 ELR (Exception-Link-Register)。</p>\n<p>每个 EL 会有个别的 SP (stack pointer)</p>\n<p>根据目前架构，由下层系統的 Execution State 決定上层系统所在模式</p>\n<p>若下层系統为 32bits 則上层只能为 32bits，反之若为 64bits 則上层可为 32bits or 64bits</p>\n<h5 id=\"安全性状态-security-state\"><a class=\"markdownIt-Anchor\" href=\"#安全性状态-security-state\">#</a> 安全性状态 (Security state)</h5>\n<p>ARMv8-A 架构提供两种安全性状态，他们有个别的实体记忆体定址空间 (Secure physical address space)。</p>\n<p>安全状态 (Secure state): PE 可以存取安全及不安全的实体定址空间，有 EL0.EL1.EL3</p>\n<p>不安全状态 (Non-Secure state): 只能存取不安全的实体定址空间，有 EL0.EL1.EL2</p>\n<h5 id=\"虚拟化-virtualization\"><a class=\"markdownIt-Anchor\" href=\"#虚拟化-virtualization\">#</a> 虚拟化 (Virtualization)</h5>\n<p>这边提到的虚拟化为有实现 EL2 架构的系统。以下为其基础模型: (manual D1.5 Virtualization)</p>\n<p>一个跑在 EL2 的 Hypervisor 负责切换跑在 EL1、EL0 的 virtual machines 一些跑在 virtual machines 上 (在 EL1 中) 的 Guest OS 每个 Guest OS 上跑在 EL0 的应用程序 每个 VM 会被 Hypervisor 指定一个 VMID。</p>\n<p>EL2 只会实现在 Non-secure state，并负责:</p>\n<p>提供虚拟值给少数特定的暂存器 (1)。Guest OS 或其上的应用程序读取这些暂存器时会得到虚拟的值。 Trapping: 当在做记忆体管理及存取其他大多数的暂存器 ((1) 之外的) 时会产生 exception 并由 EL2 处理。 Routing interrupt: 将中断分配给 现在的 Guest OS 现在没在执行的 Guest OS hypervisor (以上会在各别的章节特别探讨) 实现 EL2 包含以下实作:</p>\n<p>Hypervisor Call (HVC) exception Traps to EL2 虚拟中断：包括: Virtual SError Virtual IRQ Virtual FIQ 所有虚拟中断会由 EL1 处理 每个虚拟中断可由 EL2 各别启用 每个虚拟中断都会有其对应的实体中断 当一个虚拟中断被启用时，其对应的实体中断会由 EL2 处理 (除非 EL3 指定他要处理)</p>\n<p>偷了个，基本上简单入门够了</p>\n<h6 id=\"arm内核寄存器以及常用汇编指令分析-知乎-zhihucom\"><a class=\"markdownIt-Anchor\" href=\"#arm内核寄存器以及常用汇编指令分析-知乎-zhihucom\">#</a> <a href=\"https://zhuanlan.zhihu.com/p/102395838\">【ARM】内核寄存器以及常用汇编指令分析 - 知乎 (zhihu.com)</a></h6>\n<p><a href=\"https://azeria-labs.com/arm-data-types-and-registers-part-2/\">ARM Data Types and Registers (Part 2) | Azeria Labs (azeria-labs.com)</a></p>\n<p><a href=\"http://wiki.csie.ncku.edu.tw/embedded/ARMv8\">Wiki - ARMv8 (ncku.edu.tw)</a> ： 这个讲的挺底层的</p>\n<p><a href=\"https://hackmd.io/@owlfox/Bkcen7LeL/https%3A%2F%2Fhackmd.io%2Fs%2FBkGRdKmsg\">ARM 指令 - HackMD</a>：这个主要偏移动设备</p>\n<h3 id=\"常见寄存器\"><a class=\"markdownIt-Anchor\" href=\"#常见寄存器\">#</a> 常见寄存器</h3>\n<h5 id=\"基本寄存器结构\"><a class=\"markdownIt-Anchor\" href=\"#基本寄存器结构\">#</a> 基本寄存器结构</h5>\n<p><img src=\"/arm%E5%88%9D%E6%8E%A2/v2-eea3bf670b65918c3ff16d0d8c9fa552_1440w.webp\" alt=\"img\"></p>\n<h5 id=\"r13堆栈指针stack-pointer\"><a class=\"markdownIt-Anchor\" href=\"#r13堆栈指针stack-pointer\">#</a> R13，堆栈指针 (Stack Pointer)</h5>\n<p>R13 寄存器中存放的是堆栈的栈顶指针，CM3 中有两个堆栈指针，也就支持两个堆栈。分别是：主堆栈指针 (Main Stack Pointer)，进程堆栈指针 (Process Stack Pointer)。</p>\n<p>堆栈主要是通过 POP，PUSH 指令来进行操作。在执行 PUSH 和 POP 操作时，那个通常被称为 SP 的地址寄存器，会自动被调整，以避免后续的操作破坏先前的数据。</p>\n<h5 id=\"r14-连接寄存器link-register\"><a class=\"markdownIt-Anchor\" href=\"#r14-连接寄存器link-register\">#</a> R14 ，连接寄存器 (Link Register)</h5>\n<p>在一个汇编程序中， LR 用于在调用子程序时存储返回地址。例如，在使用 BL (分支并连接， Branch and Link) 指令时，就自动填充 LR 的值 (执行函数调用的下一指令)，进而在函数退出时，正确返回并执行下一指令。</p>\n<p>如果函数中又调用了其他函数，那么 LR 将会被覆盖，所以需要先将 LR 寄存器入栈 PUSH，保护起来。</p>\n<h5 id=\"r15程序计数器program-count\"><a class=\"markdownIt-Anchor\" href=\"#r15程序计数器program-count\">#</a> R15，程序计数器 (Program Count)</h5>\n<p>因为 CM3 内部使用了指令流水线，读 PC 时返回的值是当前指令的地址 + 4</p>\n<h5 id=\"特殊功能寄存器组\"><a class=\"markdownIt-Anchor\" href=\"#特殊功能寄存器组\">#</a> 特殊功能寄存器组</h5>\n<p>Cortex‐M3 中的特殊功能寄存器包括：</p>\n<p>程序状态寄存器组（ xPSR），存放当前 CPU 的状态</p>\n<p>中断屏蔽寄存器组（ PRIMASK, FAULTMASK, 以及 BASEPRI），用于控制异常的使能和除能</p>\n<p>控制寄存器（ CONTROL），用于定义特权级别，以及选择当前使用堆栈指针 (PSP/MSP?)。</p>\n<h5 id=\"cm3的操作模式\"><a class=\"markdownIt-Anchor\" href=\"#cm3的操作模式\">#</a> CM3 的操作模式</h5>\n<p>为了架构的安全性和健壮性，CM3 支持 2 个模式 (线程模式，handler 模式)，以及 2 个特权等级 (特权级，用户级)。<strong>handler 模式下只能是特权级。</strong></p>\n<p><img src=\"/arm%E5%88%9D%E6%8E%A2/v2-a2b2ab0c1ca1dd2ccdd63d31086c51bd_1440w.webp\" alt=\"img\"></p>\n<h5 id=\"复位序列\"><a class=\"markdownIt-Anchor\" href=\"#复位序列\">#</a> 复位序列</h5>\n<p>在进入复位状态后， CM3 做的第一件事就是读取下列两个 32 位整数的值：</p>\n<p>从地址 0x0000,0000 处取出 MSP 的初始值。(<strong>初始化 MSP，为后续的代码执行创造环境</strong>)</p>\n<p>从地址 0x0000,0004 处取出 PC 的初始值 — 这个值是复位向量。(<strong>启动引导代码</strong>)</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-75518ed58d8fc3d6b0689f0dc0f30e59_1440w.webp\" alt=\"img\"></p>\n<p><img src=\"/arm%E5%88%9D%E6%8E%A2/v2-b05eeba8cc7c4cbded074a0aee4ebcdb_1440w.webp\" alt=\"img\"></p>\n<h3 id=\"arm汇编指令集\"><a class=\"markdownIt-Anchor\" href=\"#arm汇编指令集\">#</a> ARM 汇编指令集</h3>\n<p><strong>ARM 指令集可以分为跳转指令、数据处理指令、程序状态寄存器 (PSR) 处理指令、加载 / 存储指令、协处理器指令和异常产生指令六大类</strong>。</p>\n<p>跳转指令：B,BL,BX,BXL (<em>用于函数调用时的跳转，分为带 / 不带 返回地址 / 状态 的跳转</em>)</p>\n<p>数据处理指令：MOV,ADD,SUB,DIV,MUL,AND,ORR,CMP…(<em>赋值，加减乘除，与或逻辑，比较</em>)</p>\n<p>程序状态寄存器 (PSR) 处理指令：MSR,MRS (<em>用于查询或设置状态寄存器 / 特殊寄存器的数据</em>)</p>\n<p>加载 / 存储指令: LDR,STR…(* 用于寄存器与内存之间的数据交换，<strong>一般为间接寻址</strong>)</p>\n<p>异常产生指令：SWI (<em>用于产生软件中断</em>)</p>\n",
            "tags": [
                "re",
                "Android"
            ]
        },
        {
            "id": "https://demoyao100.github.io/%E5%AE%89%E5%8D%93hook%E5%88%9D%E6%8E%A2/",
            "url": "https://demoyao100.github.io/%E5%AE%89%E5%8D%93hook%E5%88%9D%E6%8E%A2/",
            "title": "安卓hook初探",
            "date_published": "2023-08-28T02:49:54.000Z",
            "content_html": "<h6 id=\"preface-隐约记得之前弄过一次但是这次换了个环境折腾了一整天吧还挺麻烦的总之记录一下后面搞起来方便\"><a class=\"markdownIt-Anchor\" href=\"#preface-隐约记得之前弄过一次但是这次换了个环境折腾了一整天吧还挺麻烦的总之记录一下后面搞起来方便\">#</a> preface: 隐约记得之前弄过一次，但是这次换了个环境折腾了一整天吧还挺麻烦的，总之记录一下后面搞起来方便.</h6>\n<span id=\"more\"></span>\n<hr>\n<h5 id=\"环境mumu12模拟器\"><a class=\"markdownIt-Anchor\" href=\"#环境mumu12模拟器\">#</a> 环境：mumu12 模拟器</h5>\n<h6 id=\"adb连接\"><a class=\"markdownIt-Anchor\" href=\"#adb连接\">#</a> adb 连接：</h6>\n<p><img src=\"/%E5%AE%89%E5%8D%93hook%E5%88%9D%E6%8E%A2/image-20230828105143258.png\" alt=\"image-20230828105143258\"></p>\n<h5 id=\"连接adbexe-connect-127001-断开adbexe-disconnect-127001\"><a class=\"markdownIt-Anchor\" href=\"#连接adbexe-connect-127001-断开adbexe-disconnect-127001\">#</a> 连接： <code>adb.exe connect 127.0.0.1:*****</code>   断开： <code>adb.exe disconnect 127.0.0.1:*****</code></h5>\n<h5 id=\"检查设备adbexe-devices\"><a class=\"markdownIt-Anchor\" href=\"#检查设备adbexe-devices\">#</a> 检查设备： <code>adb.exe devices</code></h5>\n<h5 id=\"shell-adb-s-127001-shell-或-adb-shell\"><a class=\"markdownIt-Anchor\" href=\"#shell-adb-s-127001-shell-或-adb-shell\">#</a> shell:  <code>adb -s 127.0.0.1:***** shell</code>  或  <code>adb shell</code></h5>\n<hr>\n<h5 id=\"查看手机cpu架构-getprop-roproductcpuabi\"><a class=\"markdownIt-Anchor\" href=\"#查看手机cpu架构-getprop-roproductcpuabi\">#</a> 查看手机 CPU 架构 ：  <code>getprop ro.product.cpu.abi</code></h5>\n<h5 id=\"找到对应frida-server-frida-version检查本机frida版本releases-fridafrida-githubcom\"><a class=\"markdownIt-Anchor\" href=\"#找到对应frida-server-frida-version检查本机frida版本releases-fridafrida-githubcom\">#</a> 找到对应 frida server：  <code>frida version</code>  检查本机 frida 版本<a href=\"https://github.com/frida/frida/releases\"> Releases・frida/frida (github.com)</a></h5>\n<h5 id=\"运行frida-server-adb-push-frida-server-datalocaltmp\"><a class=\"markdownIt-Anchor\" href=\"#运行frida-server-adb-push-frida-server-datalocaltmp\">#</a> 运行 frida server:  <code>adb push frida-server /data/local/tmp/</code></h5>\n<h5 id=\"cd-datalocaltmp\"><a class=\"markdownIt-Anchor\" href=\"#cd-datalocaltmp\">#</a>  <code>cd /data/local/tmp</code></h5>\n<h5 id=\"frida-server\"><a class=\"markdownIt-Anchor\" href=\"#frida-server\">#</a>  <code>./frida-server</code></h5>\n<h5 id=\"电脑查看手机正在运行的进程firda-ps-u\"><a class=\"markdownIt-Anchor\" href=\"#电脑查看手机正在运行的进程firda-ps-u\">#</a> 电脑查看手机正在运行的进程： <code>firda-ps -U</code></h5>\n<h5 id=\"端口转发-adb-forward-tcp27042-tcp27042\"><a class=\"markdownIt-Anchor\" href=\"#端口转发-adb-forward-tcp27042-tcp27042\">#</a> 端口转发:  <code>adb forward tcp:27042 tcp:27042</code></h5>\n<h5 id=\"查看包名\"><a class=\"markdownIt-Anchor\" href=\"#查看包名\">#</a> 查看包名：</h5>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>#查看进程中的信息</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>#process = frida.get_usb_device().enumerate_processes()</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>#print(process)</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>1.新开一个shell输入命令：</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>adb shell am monitor</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>2.启动需要获取包名的应用</pre></td></tr></table></figure><hr>\n<h5 id=\"运行frida脚本frida-u-l-your-scriptjs-f-comyourapppackage\"><a class=\"markdownIt-Anchor\" href=\"#运行frida脚本frida-u-l-your-scriptjs-f-comyourapppackage\">#</a> 运行 frida 脚本: <code>frida -U -l your-script.js -f com.yourapp.package</code></h5>\n<h5 id=\"frida检查包名adb-shell-pm-list-packages-grep\"><a class=\"markdownIt-Anchor\" href=\"#frida检查包名adb-shell-pm-list-packages-grep\">#</a> frida 检查包名： <code>adb shell pm list packages | grep ***</code></h5>\n<hr>\n<h5 id=\"gg修改器-httpsgameguardiannetforumfilesfile2-gameguardian\"><a class=\"markdownIt-Anchor\" href=\"#gg修改器-httpsgameguardiannetforumfilesfile2-gameguardian\">#</a> gg 修改器:    <a href=\"https://gameguardian.net/forum/files/file/2-gameguardian/\">https://gameguardian.net/forum/files/file/2-gameguardian/</a></h5>\n",
            "tags": [
                "re",
                "Android"
            ]
        },
        {
            "id": "https://demoyao100.github.io/%E5%88%9D%E6%8E%A2flutter/",
            "url": "https://demoyao100.github.io/%E5%88%9D%E6%8E%A2flutter/",
            "title": "初探flutter",
            "date_published": "2023-08-23T00:59:47.000Z",
            "content_html": "<h6 id=\"preface-起因是wmctf2023有个anticheat2是基于flutter开发的中间也得用到相关知识-题目是一下子被队里师傅秒了555队里师傅秒题太快哩毫无存在感属于是但是总归还是得来补补功课啥也不学还是啥也不会-虽然这会我的安卓环境还是不太彳亍容错很低当时比赛的时候就没有环境跑这个题\"><a class=\"markdownIt-Anchor\" href=\"#preface-起因是wmctf2023有个anticheat2是基于flutter开发的中间也得用到相关知识-题目是一下子被队里师傅秒了555队里师傅秒题太快哩毫无存在感属于是但是总归还是得来补补功课啥也不学还是啥也不会-虽然这会我的安卓环境还是不太彳亍容错很低当时比赛的时候就没有环境跑这个题\">#</a> preface: 起因是 WMCTF2023 有个 anticheat2 是基于 flutter 开发的，中间也得用到相关知识。题目是一下子被队里师傅秒了（<s>555 队里师傅秒题太快哩毫无存在感属于是</s>）但是总归还是得来补补功课，啥也不学还是啥也不会。（<s>虽然这会我的安卓环境还是不太彳亍容错很低当时比赛的时候就没有环境跑这个题</s>）</h6>\n<span id=\"more\"></span>\n<h5 id=\"文档flutter-架构概览-flutter-中文文档-flutter-中文开发者网站-flutter\"><a class=\"markdownIt-Anchor\" href=\"#文档flutter-架构概览-flutter-中文文档-flutter-中文开发者网站-flutter\">#</a> 文档：<a href=\"https://flutter.cn/docs/resources/architectural-overview\">Flutter 架构概览 - Flutter 中文文档 - Flutter 中文开发者网站 - Flutter</a></h5>\n<h5 id=\"参考文章reverse-engineering-flutter-apps-part-1-tstsh\"><a class=\"markdownIt-Anchor\" href=\"#参考文章reverse-engineering-flutter-apps-part-1-tstsh\">#</a> 参考文章：<a href=\"https://blog.tst.sh/reverse-engineering-flutter-apps-part-1/\">Reverse engineering Flutter apps (Part 1) (tst.sh)</a></h5>\n<h5 id=\"reverse-engineering-flutter-apps-part-2-tstsh\"><a class=\"markdownIt-Anchor\" href=\"#reverse-engineering-flutter-apps-part-2-tstsh\">#</a> <a href=\"https://blog.tst.sh/reverse-engineering-flutter-apps-part-2/\">Reverse engineering Flutter apps (Part 2) (tst.sh)</a></h5>\n<h5 id=\"todo工具\"><a class=\"markdownIt-Anchor\" href=\"#todo工具\">#</a> TODO：<a href=\"https://bbs.kanxue.com/thread-275287.htm\">工具</a></h5>\n<h5 id=\"flutter逆向初探-2023国赛ctf的flutterror_1mmorta1的博客-csdn博客\"><a class=\"markdownIt-Anchor\" href=\"#flutter逆向初探-2023国赛ctf的flutterror_1mmorta1的博客-csdn博客\">#</a> <a href=\"https://blog.csdn.net/qq_41866334/article/details/131032273\">flutter 逆向初探 -- 2023 国赛 ctf 的 flutterror_1mmorta1 的博客 - CSDN 博客</a></h5>\n<h5 id=\"reverse-engineering-flutter-apps-guardsquare\"><a class=\"markdownIt-Anchor\" href=\"#reverse-engineering-flutter-apps-guardsquare\">#</a> <a href=\"https://www.guardsquare.com/blog/current-state-and-future-of-reversing-flutter-apps\">Reverse Engineering Flutter Apps | Guardsquare</a></h5>\n<h5 id=\"flutter架构分层系统上层组件依赖下层组件组件层间不可越权且各个部分可选可替代类似层与层间透明\"><a class=\"markdownIt-Anchor\" href=\"#flutter架构分层系统上层组件依赖下层组件组件层间不可越权且各个部分可选可替代类似层与层间透明\">#</a> Flutter 架构：分层系统，上层组件依赖下层组件，组件层间不可越权且各个部分可选可替代（类似层与层间透明）</h5>\n<h5 id=\"archdiagram\"><a class=\"markdownIt-Anchor\" href=\"#archdiagram\">#</a> <img src=\"/%E5%88%9D%E6%8E%A2flutter/archdiagram.webp\" alt=\"archdiagram\"></h5>\n<h6 id=\"对于底层操作系统而言flutter-应用程序的包装方式与其他原生应用相同-在每一个平台上会包含一个特定的嵌入层从而提供一个程序入口程序由此可以与底层操作系统进行协调访问诸如-surface-渲染-辅助功能和输入等服务并且管理事件循环队列-该嵌入层采用了适合当前平台的语言编写例如-android-使用的是-java-和-c-ios-和-macos-使用的是-objective-c-和-objective-cwindows-和-linux-使用的是-c-flutter-代码可以通过嵌入层以模块方式集成到现有的应用中也可以作为应用的主体-flutter-本身包含了各个常见平台的嵌入层同时也-存在一些其他的嵌入层\"><a class=\"markdownIt-Anchor\" href=\"#对于底层操作系统而言flutter-应用程序的包装方式与其他原生应用相同-在每一个平台上会包含一个特定的嵌入层从而提供一个程序入口程序由此可以与底层操作系统进行协调访问诸如-surface-渲染-辅助功能和输入等服务并且管理事件循环队列-该嵌入层采用了适合当前平台的语言编写例如-android-使用的是-java-和-c-ios-和-macos-使用的是-objective-c-和-objective-cwindows-和-linux-使用的是-c-flutter-代码可以通过嵌入层以模块方式集成到现有的应用中也可以作为应用的主体-flutter-本身包含了各个常见平台的嵌入层同时也-存在一些其他的嵌入层\">#</a> 对于底层操作系统而言，Flutter 应用程序的包装方式与其他原生应用相同。在每一个平台上，会包含一个特定的嵌入层，从而提供一个程序入口，程序由此可以与底层操作系统进行协调，访问诸如 surface 渲染、辅助功能和输入等服务，并且管理事件循环队列。该嵌入层采用了适合当前平台的语言编写，例如 Android 使用的是 Java 和 C++， iOS 和 macOS 使用的是 Objective-C 和 Objective-C++，Windows 和 Linux 使用的是 C++。 Flutter 代码可以通过嵌入层，以模块方式集成到现有的应用中，也可以作为应用的主体。 Flutter 本身包含了各个常见平台的嵌入层，同时也 <a href=\"https://hover.build/blog/one-year-in/\">存在一些其他的嵌入层</a>。</h6>\n<h6 id=\"flutter-引擎-毫无疑问是-flutter-的核心它主要使用-c-编写并提供了-flutter-应用所需的原语-当需要绘制新一帧的内容时引擎将负责对需要合成的场景进行栅格化-它提供了-flutter-核心-api-的底层实现包括图形在-ios-和-android-上通过-impeller在其他平台上通过-skia-文本布局-文件及网络-io-辅助功能支持-插件架构和-dart-运行环境及编译环境的工具链\"><a class=\"markdownIt-Anchor\" href=\"#flutter-引擎-毫无疑问是-flutter-的核心它主要使用-c-编写并提供了-flutter-应用所需的原语-当需要绘制新一帧的内容时引擎将负责对需要合成的场景进行栅格化-它提供了-flutter-核心-api-的底层实现包括图形在-ios-和-android-上通过-impeller在其他平台上通过-skia-文本布局-文件及网络-io-辅助功能支持-插件架构和-dart-运行环境及编译环境的工具链\">#</a> <strong>Flutter 引擎</strong> 毫无疑问是 Flutter 的核心，它主要使用 C++ 编写，并提供了 Flutter 应用所需的原语。当需要绘制新一帧的内容时，引擎将负责对需要合成的场景进行栅格化。它提供了 Flutter 核心 API 的底层实现，包括图形（在 iOS 和 Android 上通过 <a href=\"https://flutter.cn/docs/perf/impeller\">Impeller</a>，在其他平台上通过 <a href=\"https://skia.org/\">Skia</a>）、文本布局、文件及网络 IO、辅助功能支持、插件架构和 Dart 运行环境及编译环境的工具链。</h6>\n<h6 id=\"引擎将底层-c-代码包装成-dart-代码通过-dartui-暴露给-flutter-框架层-该库暴露了最底层的原语包括用于驱动输入-图形-和文本渲染的子系统的类\"><a class=\"markdownIt-Anchor\" href=\"#引擎将底层-c-代码包装成-dart-代码通过-dartui-暴露给-flutter-框架层-该库暴露了最底层的原语包括用于驱动输入-图形-和文本渲染的子系统的类\">#</a> <strong>引擎将底层 C++ 代码包装成 Dart 代码，通过 <a href=\"https://github.com/flutter/engine/tree/master/lib/ui\"> <code>dart:ui</code> </a> 暴露给 Flutter 框架层。该库暴露了最底层的原语，包括用于驱动输入、图形、和文本渲染的子系统的类。</strong></h6>\n<h5 id=\"应用结构app-anatomy\"><a class=\"markdownIt-Anchor\" href=\"#应用结构app-anatomy\">#</a> 应用结构：<img src=\"/%E5%88%9D%E6%8E%A2flutter/app-anatomy.svg\" alt=\"app-anatomy\"></h5>\n<h5 id=\"flutter构建的文件结构\"><a class=\"markdownIt-Anchor\" href=\"#flutter构建的文件结构\">#</a> flutter 构建的文件结构：</h5>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>tree .</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>.</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>├── arm64-v8a</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>│   ├── libapp.so</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>│   └── libflutter.so</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>└── armeabi-v7a</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    ├── libapp.so</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    └── libflutter.so</pre></td></tr></table></figure><p>Android apk 包中两个 libapp.so 文件，它们分别是作为 ELF 二进制文件的 a64 和 a32 快照。gen_snapshots 在此处输出 ELF / 共享对象可能会引起误解，它不会将 dart 方法公开为可以在外部调用的符号。相反，这些文件是 “cluster 化快照” 格式的容器，但在单独的可执行部分中包含编译的代码，以下是它们的结构：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ aarch64-linux-gnu-objdump -T libapp.so</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>libapp.so:     file format elf64-littleaarch64</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>DYNAMIC SYMBOL TABLE:</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>0000000000001000 g    DF .text  0000000000004ba0 _kDartVmSnapshotInstructions</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>0000000000006000 g    DF .text  00000000002d0de0 _kDartIsolateSnapshotInstructions</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>00000000002d7000 g    DO .rodata        0000000000007f10 _kDartVmSnapshotData</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>00000000002df000 g    DO .rodata        000000000021ad10 _kDartIsolateSnapshotData</pre></td></tr></table></figure><h5 id=\"dart-构建\"><a class=\"markdownIt-Anchor\" href=\"#dart-构建\">#</a> <a href=\"https://github.com/dart-lang/sdk/wiki/Building\">Dart 构建</a></h5>\n<h5 id=\"dart混淆\"><a class=\"markdownIt-Anchor\" href=\"#dart混淆\">#</a> <a href=\"https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code\">Dart 混淆</a></h5>\n<h5 id=\"dart-64的寄存器和函数调用约定\"><a class=\"markdownIt-Anchor\" href=\"#dart-64的寄存器和函数调用约定\">#</a> dart 64 的寄存器和函数调用约定：</h5>\n<pre><code>       r0 |     | Returns\nr0  -  r7 |     | Arguments\nr0  - r14 |     | General purpose\n      r15 | sp  | Dart stack pointer\n      r16 | ip0 | Scratch register\n      r17 | ip1 | Scratch register\n      r18 |     | Platform register\nr19 - r25 |     | General purpose\nr19 - r28 |     | Callee saved registers\n      r26 | thr | Current thread\n      r27 | pp  | Object pool\n      r28 | brm | Barrier mask\n      r29 | fp  | Frame pointer\n      r30 | lr  | Link register\n      r31 | zr  | Zero / CSP\n</code></pre>\n<h5 id=\"dart-32的寄存器和函数调用约定\"><a class=\"markdownIt-Anchor\" href=\"#dart-32的寄存器和函数调用约定\">#</a> dart 32 的寄存器和函数调用约定：</h5>\n<pre><code>r0 -  r1 |     | Returns\nr0 -  r9 |     | General purpose\nr4 - r10 |     | Callee saved registers\n      r5 | pp  | Object pool\n     r10 | thr | Current thread\n     r11 | fp  | Frame pointer\n     r12 | ip  | Scratch register\n     r13 | sp  | Stack pointer\n     r14 | lr  | Link register\n     r15 | pc  | Program counter\n</code></pre>\n<h5 id=\"example\"><a class=\"markdownIt-Anchor\" href=\"#example\">#</a> example：</h5>\n<figure class=\"highlight dart\"><figcaption data-lang=\"dart\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Hello, World!\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><pre><code class=\"language-asm\">Code for optimized function 'package:dectest/hello_world.dart_::_hello' &#123;\n        ;; B0\n        ;; B1\n        ;; Enter frame（保存当前函数帧指针和返回地址）\n0xf69ace60    e92d4800               stmdb sp!, &#123;fp, lr&#125;;stmdb sp!存储数据前递减寄存器(Store Multiple Decrement Before)\n0xf69ace64    e28db000               add fp, sp, #0\n        ;; CheckStackOverflow:8(stack=0, loop=0)将字段偏移表（限制个数为36）加载到ip中并检测栈溢出\n0xf69ace68    e59ac024               ldr ip, [thr, #+36]\n0xf69ace6c    e15d000c               cmp sp, ip\n0xf69ace70    9bfffffe               blls +0 ; 0xf69ace70\n        ;; PushArgument(v3)\n0xf69ace74    e285ca01               add ip, pp, #4096\n0xf69ace78    e59ccfa7               ldr ip, [ip, #+4007]\n0xf69ace7c    e52dc004               str ip, [sp, #-4]!\n        ;; StaticCall:12( print&lt;0&gt; v3)\n0xf69ace80    ebfffffe               bl +0 ; 0xf69ace80\n0xf69ace84    e28dd004               add sp, sp, #4\n        ;; ParallelMove r0 &lt;- C\n0xf69ace88    e59a0060               ldr r0, [thr, #+96]\n        ;; Return:16(v0)\n0xf69ace8c    e24bd000               sub sp, fp, #0\n0xf69ace90    e8bd8800               ldmia sp!, &#123;fp, pc&#125;\n0xf69ace94    e1200070               bkpt #0x0\n&#125;\n</code></pre>\n<h5 id=\"another-example\"><a class=\"markdownIt-Anchor\" href=\"#another-example\">#</a> another example:</h5>\n<pre><code class=\"language-asm\">// prologue, polymorphic entry\n000 | stmdb sp!, &#123;fp, lr&#125;\n004 | add fp, sp, #0\n008 | sub sp, sp, #4\n// optional parameter handling\n00c | ldr r0, [r4, #0x13] // arr[2] (positional arg count)\n010 | ldr r1, [r4, #0xf]  // arr[1] (argument count)\n014 | cmp r0, #0          // check if we have positional args\n018 | bgt 0x74            // jump to 08c\n// check named args\n01c | ldr r0, [r4, #0x17]  // arr[3] (first arg name)\n020 | add ip, pp, #0x2000  // \n024 | ldr ip, [ip, #0x4a7] // string &quot;x&quot;\n028 | cmp r0, ip           // check if arg present\n02c | bne 0x20             // jump to 04c\n030 | ldr r0, [r4, #0x1b]    // arr[4] (first arg position)\n034 | sub r2, r1, r0         // r2 = arg_count - position\n038 | add r0, fp, r2, lsl #1 // r0 = fp + r2 * 2\n    |                        // this is really r2 * 4 because it's an smi\n03c | ldr r0, [r0, #4]       // read arg\n040 | mov r2, r0             // \n044 | mov r0, #2             // \n048 | b 12                   // jump to 054\n04c | ldr r2, [thr, #0x68] // thr-&gt;objectNull\n050 | mov r0, #0           // \n054 | str r2, [fp, #-4] // store arg in local\n// done loading args\n058 | cmp r1, r0 // check if we have read all args\n05c | bne 0x30   // jump to 08c\n// continue prologe\n060 | ldr ip, [thr, #0x24] // thr-&gt;stackLimit\n064 | cmp sp, ip           //\n068 | blls -0x5af00        // stackOverflowStubWithoutFpuRegsStub\n// rest of function\n06c | ...\n// incompatible args path\n08c | ldr r6, [pp, #0x33] // Code* callClosureNoSuchMethod\n090 | sub sp, fp, #0      // \n094 | ldmia sp!, &#123;fp, lr&#125; // exit frame\n098 | ldr pc, [r6, #3]    // invoke stub\n</code></pre>\n<p>一些普遍做题思路：先 reflutter 然后对着 dump 出来的 offset 进行 hook / 恢复符号表</p>\n<p><s>大概流程懂了，等个环境先</s></p>\n<p>ARM 交叉编译工具链 (32 位)： <code>sudo apt-get install gcc-arm-linux-gnueabi binutils-arm-linux-gnueabi</code>  (64 位)： <code>sudo apt-get install gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu</code></p>\n<p>寻找 <code>SVC</code>  指令出现的地址： <code>aarch64-linux-gnu-objdump -D libapp.so | grep -B2 -A2 --color=always &quot;svc&quot;</code></p>\n<hr>\n<h6 id=\"leaves大哥带着在看这个babyanti2比赛的时候被他高速非预期了但是现在复盘感觉预期解难度有点离谱的\"><a class=\"markdownIt-Anchor\" href=\"#leaves大哥带着在看这个babyanti2比赛的时候被他高速非预期了但是现在复盘感觉预期解难度有点离谱的\">#</a> leaves 大哥带着在看这个 babyanti2，比赛的时候被他高速非预期了，但是现在复盘感觉预期解难度有点离谱的</h6>\n<h5 id=\"目前还没有完整复现但是大概记录一下\"><a class=\"markdownIt-Anchor\" href=\"#目前还没有完整复现但是大概记录一下\">#</a> 目前还没有完整复现，但是大概记录一下：</h5>\n<ul>\n<li>\n<p>最简单的先把 anti 里面的环境检测 hook 掉</p>\n</li>\n<li>\n<p>然后合理就去 gg 修改分数，但是发现有疑似内存检查</p>\n</li>\n<li>\n<p>flutter 的 libapp.so 恢复符号表（基本上就是我上面说的方法）发现有对内存进行的操作，进行 hook</p>\n</li>\n<li>\n<p>然后不够，libapp.so 里面有一个 <code>generateShellcodes</code> ，非常复杂；可以 hook  <code>mprotect</code> ，发现有一个传入 0x7（可读、写、执行）的调用，比较异常，对其操作的 0x1000 长度的地址 dump 下来分析，发现好几十个 SVC 调用</p>\n</li>\n<li>\n<p>后续： 结论是两层 shellcode 调用 mincore，检查是否有内存缺页更改的操作，确实难</p>\n</li>\n</ul>\n<hr>\n<h6 id=\"914-babyanti2完整复现\"><a class=\"markdownIt-Anchor\" href=\"#914-babyanti2完整复现\">#</a> 9.14: BabyAnti2 完整复现：</h6>\n<p>AntiCheatPlugin 的 Java 层几乎看不到东西，只能判断使用 flutter，那么必须继续看下去，找 dart 层和 native 层的逻辑</p>\n<p><img src=\"/%E5%88%9D%E6%8E%A2flutter/image-20230914083329468.png\" alt=\"image-20230914083329468\"></p>\n<p>直接看 native：</p>\n<p><img src=\"/%E5%88%9D%E6%8E%A2flutter/image-20230914083721077.png\" alt=\"image-20230914083721077\"></p>\n<p><code>libflutter.so</code> ：flutter 预编译的组件库（不会因为开发者的 Dart 而改变），flutter 引擎的主要组成部分，包含了 flutter 运行所需要的核心代码，负责渲染 Flutter widgets、处理事件、与 Dart VM 进行交互以及其他核心功能</p>\n<p><code>libapp.so</code> ：Dart 代码编译后的产物，包含所有 Dart 层的 native 逻辑、UI、Flutter plugins，当应用启动时， <code>libflutter.so</code>  会加载 <code>libapp.so</code>  并开始执行 Dart 代码</p>\n<p><code>libanticheat.so（其他）</code> ：通过 Android NDK 编写的 native 代码编译产物</p>\n<p>尝试通过<a href=\"https://github.com/rscloura/Doldrums\"> rscloura/Doldrums: A Flutter/Dart reverse engineering tool (github.com)</a><a href=\"http://xn--libapp-op2ju0ndo1a5qn.so\"> 工具提取 libapp.so</a>，失败，DartSDK 版本对不上</p>\n<p><img src=\"/%E5%88%9D%E6%8E%A2flutter/image-20230914094329393.png\" alt=\"image-20230914094329393\"></p>\n<p>寻找版本相关信息，可以得到这段，获取版本号 3.1.0（这里可以猜测这个是 dart 的版本）对应到<a href=\"https://docs.flutter.dev/release/archive?tab=windows\"> Flutter SDK archive | Flutter</a> 可以查找 flutter 的版本号 beta 版本的 3.13.0-0.4.pre（根据发布时间和 Dart version，不过 hash 号没有找到，还得看看）</p>\n<p><img src=\"/%E5%88%9D%E6%8E%A2flutter/image-20230914103350070.png\" alt=\"image-20230914103350070\"></p>\n<p>题目出的时候 <code>reflutter</code>  还没有更新到这个版本，可以认为，在比赛环境下这让做这道题的预期解难度陡然升高</p>\n<p>那也只能开始漫长学习，先看看这篇的原理：<a href=\"https://swarm.ptsecurity.com/fork-bomb-for-flutter/\">Fork Bomb for Flutter – PT SWARM (ptsecurity.com)</a></p>\n<p>安装应用： <code>adb push .apk /data/local/tmp </code></p>\n<p><code>pm install -r .apk</code></p>\n<p>签名工具：<a href=\"https://github.com/patrickfav/uber-apk-signer/releases/tag/v1.2.1\">Release v1.2.1 · patrickfav/uber-apk-signer (github.com)</a></p>\n<p><code>java -jar uber-apk-signer.jar --allowResign -**a** release.RE.apk</code></p>\n<p><code> adb logcat -e reflutter | ForEach-Object &#123; $_ -replace '.*DartVM', '' &#125; &gt;&gt; reflutter.txt</code></p>\n",
            "tags": [
                "re",
                "Android"
            ]
        },
        {
            "id": "https://demoyao100.github.io/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/",
            "url": "https://demoyao100.github.io/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/",
            "title": "hook某聊天软件lab",
            "date_published": "2023-08-09T09:35:45.000Z",
            "content_html": "<h6 id=\"起因是在学安卓逆向而且自己水平太低打算练练手-恰巧某友的校内lab做了类似的东西羡慕遂打算动手尝试复现\"><a class=\"markdownIt-Anchor\" href=\"#起因是在学安卓逆向而且自己水平太低打算练练手-恰巧某友的校内lab做了类似的东西羡慕遂打算动手尝试复现\">#</a> 起因是在学安卓逆向，而且自己水平太低，打算练练手。恰巧某友的校内 lab 做了类似的东西，羡慕，遂打算动手尝试复现</h6>\n<span id=\"more\"></span>\n<h4 id=\"一-某绿色软件防撤回\"><a class=\"markdownIt-Anchor\" href=\"#一-某绿色软件防撤回\">#</a> 一、某绿色软件防撤回</h4>\n<p>首先搜索相关字串 <code>revoke</code> ，找到一个 <code>RevokeMsgEvent</code> ，看起来很像，然后翻找代码，发现了这个 listener 用于接收一个撤回消息事件</p>\n<h5 id=\"image-20230809174202432\"><a class=\"markdownIt-Anchor\" href=\"#image-20230809174202432\">#</a> <img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230809174202432.png\" alt=\"image-20230809174202432\"></h5>\n<p>观察这里的 callback 函数，先赋值到一个叫做 <code>revokeMsgEvent2</code>  的 class 上（什么鬼命名… 但是看起来可能挺重要的，marked 一下）</p>\n<p>接着合法性检测，不需要管</p>\n<p>p0.D 的声明如下</p>\n<p><img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230809175148467.png\" alt=\"image-20230809175148467\"></p>\n<p>猜测这里是通知一栏，将原通知的属性修改为已撤回的属性，两者参数 string 声明如下：</p>\n<p><img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230809175818647.png\" alt=\"image-20230809175818647\"></p>\n<p><img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230809175830933.png\" alt=\"image-20230809175830933\"></p>\n<p>不好懂，接着往下看</p>\n<p>可以明确的是这里的 class h 是和撤回相关操作的类，结合下面的调用，猜测这里就是集中处理撤回用的函数（对本地数据库进行了一些操作与删除），查看一下其声明，均是 revoke 的相关操作，那合理来说不会影响正常的流程，直接 hook 就行。</p>\n<p><img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230809185208738.png\" alt=\"image-20230809185208738\"></p>\n<p>这里试一下 <code>frida</code>  脚本 hook 的操作。</p>\n<p>首先是这里只有 arm 的包，暂时没有物理机做测试，可以用的方案有三个：AS、qemu、商业模拟器</p>\n<table>\n<thead>\n<tr>\n<th>AS</th>\n<th>qemu</th>\n<th>商业模拟器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>开发必备</td>\n<td>比较折腾，但是稍微比 AS 效率好一点</td>\n<td>运行比较流畅，但是版本选择有限，而且还有很多版本和 hyperV 犯冲，选择更加有限</td>\n</tr>\n</tbody>\n</table>\n<p>这里选择先用 AS 尝试了一下，配置如下（一点点尝试可以运行起来的 arm 架构）：<img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810132624458.png\" alt=\"image-20230810132624458\"></p>\n<p>巨慢无比，还不支持 android studio 的一些便携操作，结果和绿色软件的 so 还不兼容… 麻了…</p>\n<p>尝试使用 mumuX（亲测只有 mumux 在本机可以和 WSL2 共存，其他声称支持 hyperV 的都会出问题，待修复），会被检测环境，来尝试配一下 qemu</p>\n<p>疑似不太行，毕竟 AS 也是基于 qemu 的，该卡照样卡（据说 mac 上用 as 模拟 android 非常流畅…）</p>\n<p>然后发现微软自家的 vs 有安卓模拟器，那来尝试一下下</p>\n<h6 id=\"-to-be-continue\"><a class=\"markdownIt-Anchor\" href=\"#-to-be-continue\">#</a> - to be continue</h6>\n<h4 id=\"二-某运动软件广告消除以及强制更新破解\"><a class=\"markdownIt-Anchor\" href=\"#二-某运动软件广告消除以及强制更新破解\">#</a> 二、某运动软件广告消除以及强制更新破解</h4>\n<h6 id=\"之前队里一直有跌说加了壳搞不了但是感觉好像么有点机会遂来看看这里是用的一个旧版本好像对root的检测没那么严格但是也能用后面有空再调一个新版本的\"><a class=\"markdownIt-Anchor\" href=\"#之前队里一直有跌说加了壳搞不了但是感觉好像么有点机会遂来看看这里是用的一个旧版本好像对root的检测没那么严格但是也能用后面有空再调一个新版本的\">#</a> <s>之前队里一直有跌说加了壳搞不了，但是感觉好像么有点机会，遂来看看，这里是用的一个旧版本，好像对 root 的检测没那么严格，但是也能用，后面有空再调一个新版本的</s></h6>\n<p>通过搜索引擎可以找到一个文档，<a href=\"https://www.csjplatform.com/supportcenter/5398\">开屏广告 - Android 集成文档 - 开发测试 - 穿山甲广告平台 (csjplatform.com)</a>，这个 app 的部分广告大概就是基于这个开发的</p>\n<p>大概定位到这个类上，是广告加载用的类</p>\n<h5 id=\"image-20230810164814274\"><a class=\"markdownIt-Anchor\" href=\"#image-20230810164814274\">#</a> <img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810164814274.png\" alt=\"image-20230810164814274\"></h5>\n<p>合理来说把这里 hook 一下</p>\n<p><img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810165617746.png\" alt=\"image-20230810165617746\"></p>\n<p>就能消掉大部分和 ad 相关的事件了</p>\n<p>但是接着看下去就感觉事情不对头了，这里的 <code>com.fighter.wrapper</code>  疑似只是一个 ad 的处理方法，仔细看左边的包还有一万个不同公司的 ad… 破软件没啥功能，集成的广告不少</p>\n<p><img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810171514620.png\" alt=\"image-20230810171514620\"></p>\n<p>而且后面很多广告用的不是这个方法，那就是不能在这层 hook 了，会累死自己，最好的解决方法还是在调用这 n 个广告类前就掐掉源头</p>\n<p>可以搜索发现 <code>com.zjwh</code>  应该是这软件自己的包，命名做的手动混淆，全都是 oO0 啥的…</p>\n<p>这里发现了反虚拟环境和反 hook 的操作，那看来后面有点点不好整的</p>\n<p><img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810173613500.png\" alt=\"image-20230810173613500\"></p>\n<p>另外，可以手动调试发现，apk 启动的时候会与 server 交互获取应用更新信息，然后触发强制更新，交互方法疑似使用的 <code>okhttp</code> , 但是 zjwh 包进行了混淆，与服务器也都用的 okhttp 交互，需要一定工作量找到</p>\n<p>进度记录：这里仔细找引用和具体的实现方式</p>\n<p><img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810212148480.png\" alt=\"image-20230810212148480\"></p>\n<p>检测 xposed 框架是否存在的方法，也需要 hook 掉</p>\n<p><img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810213654727.png\" alt=\"image-20230810213654727\"></p>\n<p>这个包看起来是比较重要的，下面还有检测攻击等等函数：</p>\n<p><img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810214035445.png\" alt=\"image-20230810214035445\"></p>\n<p>这个包的源码可以找到一个很类似的（虽然只有部分）：</p>\n<p><a href=\"https://mogua.co/view_file/?file=com/ijm/detect/drisk/DRiskNativeTool.java&amp;md5=746753952f66bd8794683d37ccdd2642&amp;type=apk&amp;appname=%E5%BE%97%E7%89%A9&amp;lines=84\">DRiskNativeTool.java - 得物.apk 源代码分析 - 摸瓜 (mogua.co)</a></p>\n<p>然后顺着搜，可以找到<a href=\"https://www.ijiami.cn/enindex\"> iJiami - Guarding the Smart World | mobile information security service provider</a> 这家公司，专门做安全的，这些安全相关的包就是它家做的了</p>\n<h5 id=\"image-20230810221152187\"><a class=\"markdownIt-Anchor\" href=\"#image-20230810221152187\">#</a> <img src=\"/hook%E6%9F%90%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6lab/image-20230810221152187.png\" alt=\"image-20230810221152187\"></h5>\n<p>到这里就要考虑放弃了，毕竟是商业级的加固，就算级别不高，破解再怎么说也要不小的工程量…</p>\n",
            "tags": [
                "re",
                "Android"
            ]
        },
        {
            "id": "https://demoyao100.github.io/%E5%AE%89%E5%8D%93%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/",
            "url": "https://demoyao100.github.io/%E5%AE%89%E5%8D%93%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/",
            "title": "安卓调试初探",
            "date_published": "2023-07-11T10:14:26.000Z",
            "content_html": "<h6 id=\"preface说是初探也不是很初探吧其实前面多多少少弄过完整的流程了但是由于hyperv这玄学东西后面搞的环境一团糟打算还是重新弄一个完整的调试方案出来顺便记录一些基础知识\"><a class=\"markdownIt-Anchor\" href=\"#preface说是初探也不是很初探吧其实前面多多少少弄过完整的流程了但是由于hyperv这玄学东西后面搞的环境一团糟打算还是重新弄一个完整的调试方案出来顺便记录一些基础知识\">#</a> preface：说是初探，也不是很初探吧其实，前面多多少少弄过完整的流程了，但是由于 hyperV 这玄学东西后面搞的环境一团糟，打算还是重新弄一个完整的调试方案出来，顺便记录一些基础知识</h6>\n<span id=\"more\"></span>\n<h6 id=\"初学配安卓环境挺痛苦的有几大原因还没准备可以root的真机在x86架构下跑arm的方案很少流畅的更少能比较流畅运行的大多是商业模拟器但是我的本地linux环境大多放在wsl2上商业模拟器很多与wsl2的hyperv冲突\"><a class=\"markdownIt-Anchor\" href=\"#初学配安卓环境挺痛苦的有几大原因还没准备可以root的真机在x86架构下跑arm的方案很少流畅的更少能比较流畅运行的大多是商业模拟器但是我的本地linux环境大多放在wsl2上商业模拟器很多与wsl2的hyperv冲突\">#</a> 初学配安卓环境挺痛苦的，有几大原因：还没准备可以 root 的真机；在 x86 架构下跑 arm 的方案很少，流畅的更少；能比较流畅运行的大多是商业模拟器，但是我的本地 linux 环境大多放在 wsl2 上，商业模拟器很多与 wsl2 的 hyperV 冲突</h6>\n<h5 id=\"几个尝试过或可以考虑的方案\"><a class=\"markdownIt-Anchor\" href=\"#几个尝试过或可以考虑的方案\">#</a> 几个尝试过<s>或可以考虑</s>的方案：</h5>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Android Studio</th>\n<th style=\"text-align:center\">mumu12</th>\n<th style=\"text-align:center\">qemu</th>\n<th style=\"text-align:center\">真机</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">选择多，但是 arm 调不动</td>\n<td style=\"text-align:center\">使用方便</td>\n<td style=\"text-align:center\">~~ 配置麻烦，~~ 多数时候没法用</td>\n<td style=\"text-align:center\"><s>准备尝试</s> <s>已配置，需要 root，略麻烦</s> 启动！</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"1-android-studio\"><a class=\"markdownIt-Anchor\" href=\"#1-android-studio\">#</a> 1、Android Studio</h5>\n<p>在 so 有 x86 支持时为比较优解，可以随意选择安卓版本来使用。仅支持 arm 时本机能成功运行的镜像仅有：<img src=\"/%E5%AE%89%E5%8D%93%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/image-20230811134825647.png\" alt=\"image-20230811134825647\">armeabi-v7a 的 Nougat，但很多新的 apk 都是 arm64-v8a，这里本机跑会报很多错，而且很慢很慢</p>\n<p>2、正常情况下可以用 nox 或者雷电模拟器，稳定性还行，但是有 wsl2 的情况下会出奇怪问题（雷电号称是有兼容的，但是实测用起来会卡死，懒得修了直接换个）之前一直用的 mumux，但是这两天连 adb 会触发强制更新，换成 mumu12 居然还可以用，属于比较惊喜的，在真机拿到前可以先用这个方案</p>\n<p>mumu12 用的 x86 的架构，但是实测是可以跑 arm64-v8a 的，具体原理不太懂，但是确实挺好用的，可以按照这篇操作，调试 so 层</p>\n<p><a href=\"https://www.cnblogs.com/ddms/p/8820044.html\">IDA 远程调试 Android 中 so 文件 - jKing777 - 博客园 (cnblogs.com)</a></p>\n<h5 id=\"3-qemu\"><a class=\"markdownIt-Anchor\" href=\"#3-qemu\">#</a> 3、qemu</h5>\n<p>搭建很麻烦，需要配置可视化，非常麻烦。</p>\n<h5 id=\"4-真机\"><a class=\"markdownIt-Anchor\" href=\"#4-真机\">#</a> 4、真机</h5>\n<p>理论上的最优解，但是不知道比起商业模拟器优多少呢</p>\n<hr>\n<h6 id=\"群开发高手那里收了个二手红米还得是小米\"><a class=\"markdownIt-Anchor\" href=\"#群开发高手那里收了个二手红米还得是小米\">#</a> <s>群开发高手那里收了个二手红米，还得是小米</s></h6>\n<p>简单记录一下：</p>\n<ul>\n<li>\n<p>收的手机是已经解了 bl 锁的，可以暂时跳过这一步（<a href=\"http://www.romleyuan.com/lec/read?id=83\">小米手机官方解锁 BootLoader 图文教程 - 适用于全部机型 20210925 更新 - ROM 乐园官网 (romleyuan.com)</a>）</p>\n<ul>\n<li>\n<p>” 我的设备 “-&gt; “全部参数” -&gt; 连续点击 “MIUI 版本” 进入开发者模式 -&gt; 在开发者模式中打开 adb 调试等选项</p>\n</li>\n<li>\n<p><code>adb devices</code>  检查设备</p>\n</li>\n<li>\n<p><code>adb shell</code>  进入</p>\n</li>\n</ul>\n</li>\n<li>\n<p>刷入 TWRP 进行 root（刷失败了就下音量 + 电源键重新进入 FASTBOOT，每次需要重新刷入）</p>\n<ul>\n<li><code>adb reboot bootloader</code>  转为 FASTBOOT 模式（<a href=\"https://www.hardreset.info/zh/devices/xiaomi/xiaomi-redmi-note-8-pro/faq/drivers/drivers-xiaomi/\">windows 缺少驱动在这里下载</a>）</li>\n<li><code>fastboot devices</code>  看到设备</li>\n<li><code>fastboot flash recovery D:\\android\\BRP3.5.2v3.1-Red-twrp\\recovery.img</code>  刷入 TWRP（[<a href=\"https://forum.xda-developers.com/t/recovery-unofficial-begonia-recovery-project-themed-twrp-3-5-0-v2-unified-begonia-begoniain.4242717/\">RECOVERY][UNOFFICIAL] Begonia Recovery Project Themed TWRP 3.5.0 V2 UNIFIED [begonia/begoniain] | XDA Forums (xda-developers.com)</a>）</li>\n<li><code>fastboot flash recover</code>  启动 TWRP（选择系统重启可以回到系统）</li>\n</ul>\n</li>\n<li>\n<p>刷入 Magisk（ <code>adb push D:\\android\\Magisk\\Magisk.v26.3.zip /sdcard/</code> ）</p>\n<ul>\n<li>\n<p>在手机上根据提示操作，adb 上 <code>su</code>  即可获得 root</p>\n<h5 id=\"大功告成\"><a class=\"markdownIt-Anchor\" href=\"#大功告成\">#</a> 大功告成！</h5>\n<p><img src=\"/%E5%AE%89%E5%8D%93%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/image-20230913202333767.png\" alt=\"image-20230913202333767\"></p>\n</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "re",
                "Android"
            ]
        }
    ]
}