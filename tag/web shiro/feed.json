{
    "version": "https://jsonfeed.org/version/1",
    "title": "Moyao の小屋 • All posts by \"web shiro\" tag",
    "description": "Write down something interesting I met<br />\nFeel free to mail me if you have something wanted to talk about, plz\nmail: &lt;moyaoxue@outlook.com&gt;\n",
    "home_page_url": "https://demoyao100.github.io",
    "items": [
        {
            "id": "https://demoyao100.github.io/2024/05/08/shiro%E5%AE%89%E5%85%A8%E6%B5%85%E6%8E%A2/",
            "url": "https://demoyao100.github.io/2024/05/08/shiro%E5%AE%89%E5%85%A8%E6%B5%85%E6%8E%A2/",
            "title": "shiro安全浅探",
            "date_published": "2024-05-07T16:26:13.000Z",
            "content_html": "<h6 id=\"preface渗透和awd里面都遇到了web手说这个容易那就看看呗反正也得多看java这把当个web手呗\"><a class=\"anchor\" href=\"#preface渗透和awd里面都遇到了web手说这个容易那就看看呗反正也得多看java这把当个web手呗\">#</a> PREFACE：渗透和 awd 里面都遇到了，web 手说这个容易… 那就看看呗，反正也得多看 java，这把当个 web 手呗</h6>\n<p>写很好，二进制也能看:&gt;，下面的基本上是扣这里的：<a href=\"https://www.freebuf.com/articles/web/367363.html\">https://www.freebuf.com/articles/web/367363.html</a></p>\n<h2 id=\"shiro-550反序列化漏洞cve-2016-4437\"><a class=\"anchor\" href=\"#shiro-550反序列化漏洞cve-2016-4437\">#</a> Shiro-550 反序列化漏洞（CVE-2016-4437）</h2>\n<h4 id=\"漏洞简介\"><a class=\"anchor\" href=\"#漏洞简介\">#</a> 漏洞简介</h4>\n<p>shiro-550 主要是由 shiro 的 rememberMe 内容反序列化导致的命令执行漏洞，造成的原因是<strong>默认加密密钥是硬编码在 shiro 源码中</strong>，任何有权访问源代码的人都可以知道默认加密密钥。于是攻击者可以创建一个恶意对象，对其进行序列化、编码，然后将其作为 cookie 的 rememberMe 字段内容发送，Shiro 将对其解码和反序列化，导致服务器运行一些恶意代码。</p>\n<p>特征： <code>cookie中含有rememberMe字段</code></p>\n<p>修复建议：</p>\n<ul>\n<li>更新 shiro 到 1.2.4 以上的版本。</li>\n<li>不使用默认的加密密钥，改为随机生成密钥。</li>\n</ul>\n<h4 id=\"漏洞原理\"><a class=\"anchor\" href=\"#漏洞原理\">#</a> 漏洞原理</h4>\n<p>在 Apache Shiro&lt;=1.2.4 版本中 AES 加密时采用的 key 是<strong>硬编码</strong>在代码中的，于是我们就可以构造 RememberMe 的值，然后让其反序列化执行。</p>\n<p><img src=\"/2024/05/08/shiro%E5%AE%89%E5%85%A8%E6%B5%85%E6%8E%A2/Untitled.png\" alt=\"Untitled\"></p>\n<p>Primary Cocnerns（基本关注点）:</p>\n<ul>\n<li>Authentication（认证）：经常和登录挂钩，是证明用户说他们是谁的一个工作</li>\n<li>Authorization（授权）：访问控制的过程，即，决定‘谁’可以访问‘什么</li>\n<li>Session Management（会话管理）：管理用户特定的会话，即使在非 web 或是 EJB 的应用中</li>\n<li>Crytography（加密）：通过加密算法保证数据的安全，且易于使用</li>\n</ul>\n<p>Supporting Features（辅助特性）:</p>\n<ul>\n<li>Web Support（网络支持）:web support API 可以帮助在 web 应用中方便的使用 shiro</li>\n<li>Caching（缓存）: 保证安全操作使用快速有效</li>\n<li>Concurrency（并发）: 支持多线程应用</li>\n<li>Testing（测试）：支持集成单元测试</li>\n<li>Run As（以.. 运行）：可以假定用户为另一个用户</li>\n<li>Remeber Me: 记住用户，无需再次登录</li>\n</ul>\n<h3 id=\"一-shiro服务器识别身份加解密处理的流程\"><a class=\"anchor\" href=\"#一-shiro服务器识别身份加解密处理的流程\">#</a> 一、Shiro 服务器识别身份加解密处理的流程</h3>\n<h4 id=\"1-加密\"><a class=\"anchor\" href=\"#1-加密\">#</a> <strong>1、加密</strong></h4>\n<ol>\n<li>用户使用账号密码进行登录，并勾选”Remember Me“。</li>\n<li>Shiro 验证用户登录信息，通过后，查看用户是否勾选了”Remember Me“。</li>\n<li>若勾选，则将用户身份序列化，并将序列化后的内容进行 AES 加密，再使用 base64 编码。</li>\n<li>最后将处理好的内容放于 cookie 中的 rememberMe 字段。</li>\n</ol>\n<h4 id=\"2-解密\"><a class=\"anchor\" href=\"#2-解密\">#</a> <strong>2、解密</strong></h4>\n<ol>\n<li>当服务端收到来自未经身份验证的用户的请求时，会在客户端发送请求中的 cookie 中获取 rememberMe 字段内容。</li>\n<li>将获取到的 rememberMe 字段进行 base64 解码，再使用 AES 解密。</li>\n<li>最后将解密的内容进行反序列化，获取到用户身份。</li>\n</ol>\n<h3 id=\"二-key\"><a class=\"anchor\" href=\"#二-key\">#</a> 二、Key</h3>\n<p>AES 加密的密钥 Key 被硬编码在代码里</p>\n<h2 id=\"shiro-721反序列化漏洞cve-2019-12422\"><a class=\"anchor\" href=\"#shiro-721反序列化漏洞cve-2019-12422\">#</a> Shiro-721 反序列化漏洞（CVE-2019-12422）</h2>\n<p><strong>Shiro550 和 Shiro721 的区别：</strong></p>\n<pre><code>Shiro550只需要通过碰撞key，爆破出来密钥，就可以进行利用\nShiro721的ase加密的key一般情况下猜不到，是系统随机生成的，并且当存在有效的用户信息时才会进入下一阶段的流程所以我们需要使用登录后的rememberMe Cookie，才可以进行下一步攻击\n</code></pre>\n<h3 id=\"漏洞指纹\"><a class=\"anchor\" href=\"#漏洞指纹\">#</a> 漏洞指纹</h3>\n<ul>\n<li>URL 中含有 Shiro 字段</li>\n<li>cookie 中含有 rememberMe 字段</li>\n<li>返回包中含有 rememberMe</li>\n</ul>\n<h3 id=\"漏洞介绍\"><a class=\"anchor\" href=\"#漏洞介绍\">#</a> 漏洞介绍</h3>\n<p>在 Shiro721 中，Shiro 通过 AES-128-CBC 对 cookie 中的 <code>rememberMe</code>  字段进行加密，所以用户可以通过 <code>Padding Oracle</code>  加密生成的攻击代码来构造恶意的 <code>rememberMe</code>  字段，进行反序列化攻击，需要执行的命令越复杂，生成 payload 需要的时间就越长。</p>\n<h3 id=\"漏洞原理-2\"><a class=\"anchor\" href=\"#漏洞原理-2\">#</a> 漏洞原理</h3>\n<p>由于 Apache Shiro cookie 中通过 AES-128-CBC 模式加密的 rememberMe 字段存在问题，用户可通过 Padding Oracle 加密生成的攻击代码来构造恶意的 rememberMe 字段，用有效的 RememberMe cookie 作为 Padding Oracle Attack 的前缀，然后制作精心制作的 RememberMe 来执行 Java 反序列化攻击</p>\n<h3 id=\"攻击流程\"><a class=\"anchor\" href=\"#攻击流程\">#</a> 攻击流程</h3>\n<p>登录网站，并从 cookie 中获取 RememberMe。使用 RememberMe cookie 作为 Padding Oracle Attack 的前缀。加密 syserial 的序列化有效负载，以通过 Padding Oracle Attack 制作精心制作的 RememberMe。请求带有新的 RememberMe cookie 的网站，以执行反序列化攻击。攻击者无需知道 RememberMe 加密的密码密钥。</p>\n<h4 id=\"aes-128-cbc\"><a class=\"anchor\" href=\"#aes-128-cbc\">#</a> <strong>AES-128-CBC</strong></h4>\n<p>属于 AES 加密算法的 CBC 模式，使用 128 位数据块为一组进行加密解密，即 16 字节明文，对应 16 字节密文，，明文加密时，如果数据不够 16 字节，则会将数据补全剩余字节</p>\n<ul>\n<li>若最后剩余的明文不够 16 字节，需要进行填充，通常采用 PKCS7 进行填充。比如最后缺 3 个字节，则填充 3 个字节的 0x03; 若最后缺 10 个字节，则填充 10 个字节的 0x0a;</li>\n<li>若明文正好是 16 个字节的整数倍，最后要再加入一个 16 字节 0x10 的组再进行加密</li>\n</ul>\n<h4 id=\"padding-oracle-attack原理\"><a class=\"anchor\" href=\"#padding-oracle-attack原理\">#</a> Padding Oracle Attack 原理</h4>\n<p>Padding Oracle 攻击可以在没有密钥的情况下加密或解密密文</p>\n<p>Shiro Padding Oracle Attack（Shiro 填充 Oracle 攻击）是一种针对 Apache Shiro 身份验证框架的安全漏洞攻击。Apache Shiro 是 Java 应用程序中广泛使用的身份验证和授权框架，用于管理用户会话、权限验证等功能。</p>\n<p>Padding Oracle Attack（填充 Oracle 攻击）是一种针对加密算法使用填充的安全漏洞攻击。在加密通信中，填充用于将明文数据扩展到加密算法块大小的倍数。在此攻击中，攻击者利用填充的响应信息来推断出加密算法中的秘密信息。</p>\n<p>Shiro Padding Oracle Attack 利用了 Shiro 框架中的身份验证过程中的一个漏洞，该漏洞允许攻击者通过填充信息的不同响应时间来确定身份验证过程中的错误。通过不断尝试不同的填充方式，攻击者可以逐步推断出加密秘钥，并最终获取访问权限。</p>\n<p>这种攻击利用了填充错误的身份验证响应来获取关于秘密信息的信息泄漏，然后根据这些信息进行进一步的攻击。为了防止 Shiro Padding Oracle Attack，建议及时更新 Apache Shiro 版本，确保已修复该漏洞，并采取其他安全措施，如使用安全的加密算法和密钥管理策略。</p>\n<h2 id=\"shiro-认证绕过漏洞cve-2020-1957\"><a class=\"anchor\" href=\"#shiro-认证绕过漏洞cve-2020-1957\">#</a> Shiro 认证绕过漏洞（CVE-2020-1957）</h2>\n<h3 id=\"漏洞原理-3\"><a class=\"anchor\" href=\"#漏洞原理-3\">#</a> 漏洞原理</h3>\n<p>在 Apache Shiro 1.5.2 以前的版本中，在使用 Spring 动态控制器时，攻击者通过构造 <code>..;</code>  这样的跳转，可以绕过 Shiro 中对目录的权限限制。</p>\n<p>URL 请求过程：</p>\n<ul>\n<li>客户端请求 URL: <code>/xxx/..;/admin/</code></li>\n<li>Shrio 内部处理得到校验 URL 为 <code>/xxxx/..</code> , 校验通过</li>\n<li>SpringBoot 处理 <code>/xxx/..;/admin/</code> , 最终请求 <code>/admin/</code> , 成功访问了后台请求。</li>\n</ul>\n<h2 id=\"shiro-身份验证绕过-cve-2020-13933\"><a class=\"anchor\" href=\"#shiro-身份验证绕过-cve-2020-13933\">#</a> Shiro 身份验证绕过 （CVE-2020-13933）</h2>\n<h3 id=\"漏洞简介-2\"><a class=\"anchor\" href=\"#漏洞简介-2\">#</a> 漏洞简介</h3>\n<p>CVE-2020-11989 的修复补丁存在缺陷，在 1.5.3 及其之前的版本，由于 shiro 在处理 url 时与 spring 仍然存在差异，依然存在身份校验绕过漏洞由于处理身份验证请求时出错，远程攻击者可以发送特制的 HTTP 请求，绕过身份验证过程并获得对应用程序的未授权访问。</p>\n<p>该漏洞产生的原因主要是 <code>shiro</code>  层在处理 <code>url</code>  上和 <code>spring</code>  上存在差异，主要是在处理 <code>;</code>  上的问题，通过构造含有 <code>;</code>  符号的 <code>url</code>  即可绕过 <code>shiro</code>  在权限上的处理，而 <code>spring</code>  不负责权限管控，所以最终会导致权限绕过。 <code>ant</code>  风格的路径仅出现一个 <code>*</code>  时才能成功，而 <code>**</code>  无法绕过， <code>*</code> ：匹配一个或者多个任意的字符。</p>\n<ul>\n<li><code>*</code> ：匹配零个或者多个目录。</li>\n</ul>\n<h2 id=\"shiro-授权绕过-cve-2022-32532\"><a class=\"anchor\" href=\"#shiro-授权绕过-cve-2022-32532\">#</a> Shiro 授权绕过 （CVE-2022-32532）</h2>\n<h3 id=\"漏洞简介-3\"><a class=\"anchor\" href=\"#漏洞简介-3\">#</a> 漏洞简介</h3>\n<p>Apache Shiro 是一个强大且易用的 Java 安全框架，执行身份验证、授权、密码和会话管理。</p>\n<p>1.9.1 之前的 Apache Shiro，RegexRequestMatcher 可能被错误配置为在某些 servlet 容器上被绕过。在正则表达式中使用带有 <code>.</code>  的 RegExPatternMatcher 的应用程序可能容易受到授权绕过。</p>\n<h3 id=\"漏洞概述\"><a class=\"anchor\" href=\"#漏洞概述\">#</a> 漏洞概述</h3>\n<p>2022 年 6 月 29 日，Apache 官方披露 Apache Shiro 权限绕过漏洞 (CVE-2022-32532)，当 Apache Shiro 中使用 RegexRequestMatcher 进行权限配置，且正则表达式中携带 “.” 时，未经授权的远程攻击者可通过构造恶意数据包绕过身份认证。</p>\n<p>参考文章：<a href=\"https://www.freebuf.com/articles/web/367363.html\">https://www.freebuf.com/articles/web/367363.html</a></p>\n",
            "tags": [
                "web shiro"
            ]
        }
    ]
}