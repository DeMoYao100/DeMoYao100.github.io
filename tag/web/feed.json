{
    "version": "https://jsonfeed.org/version/1",
    "title": "Moyao の小屋 • All posts by \"web\" tag",
    "description": "Write down something interesting I met<br />\nFeel free to mail me if you have something wanted to talk about, plz\nmail: &lt;moyaoxue@outlook.com&gt;\n",
    "home_page_url": "https://demoyao100.github.io",
    "items": [
        {
            "id": "https://demoyao100.github.io/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%9D%E6%8E%A2/",
            "url": "https://demoyao100.github.io/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%9D%E6%8E%A2/",
            "title": "反序列化初探",
            "date_published": "2024-05-07T16:31:13.000Z",
            "content_html": "<h6 id=\"preface\"><a class=\"markdownIt-Anchor\" href=\"#preface\">#</a> PREFACE：</h6>\n<span id=\"more\"></span>\n<h3 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h3>\n<blockquote>\n<p>序列化：把对象转换为字节序列的过程，即把对象转换为可以存储或传输的数据的过程。例如将内存中的对象转换为二进制数据流或文件，在网络传输过程中，可以是字节或是 XML 等格式。</p>\n<p><strong>反序列化</strong>：把字节序列恢复为对象的过程，即把可以存储或传输的数据转换为对象的过程。例如将二进制数据流或文件加载到内存中还原为对象。</p>\n</blockquote>\n<h3 id=\"漏洞成因\"><a class=\"markdownIt-Anchor\" href=\"#漏洞成因\">#</a> <strong>漏洞成因</strong></h3>\n<p>在身份验证，文件读写，数据传输等功能处，在未对反序列化接口做访问控制，未对序列化数据做加密和签名，加密密钥使用硬编码（如 Shiro 1.2.4），使用不安全的反序列化框架库（如 Fastjson 1.2.24）或函数的情况下，由于序列化数据可被用户控制，攻击者可以精心构造恶意的序列化数据（执行特定代码或命令的数据）传递给应用程序，在应用程序反序列化对象时执行攻击者构造的恶意代码，达到攻击者的目的。</p>\n<h3 id=\"漏洞可能出现的位置\"><a class=\"markdownIt-Anchor\" href=\"#漏洞可能出现的位置\">#</a> <strong>漏洞可能出现的位置</strong></h3>\n<p>1. 解析认证 token、session 的位置</p>\n<p>2. 将序列化的对象存储到磁盘文件或存入数据库后反序列化时的位置，如读取 json 文件，xml 文件等</p>\n<p>3. 将对象序列化后在网络中传输，如传输 json 数据，xml 数据等</p>\n<p>4. 参数传递给程序</p>\n<p>5. 使用 RMI 协议，被广泛使用的 RMI 协议完全基于序列化</p>\n<p>6. 使用了不安全的框架或基础类库，如 JMX 、Fastjson 和 Jackson 等</p>\n<p>7. 定义协议用来接收与发送原始的 java 对象</p>\n<p>询问了 web 手相关事宜，反序列化大概考点是 python、php、java 三种语言</p>\n<p>在 Python 和 PHP 中，一般通过构造一个包含魔术方法（在发生特定事件或场景时被自动调用的函数，通常是构造函数或析构函数）的类，然后在魔术方法中调用命令执行或代码执行函数，接着实例化这个类的一个对象并将该对象序列化后传递给程序，当程序反序列化该对象时触发魔术方法从而执行命令或代码。</p>\n<p>在 Java 中没有魔术方法，但是有<a href=\"https://xz.aliyun.com/t/7029/\">反射（reflection）机制</a>：在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法，这种动态获取程序信息以及动态调用对象的功能称为 Java 语言的反射机制。一般利用反射机制来构造一个执行命令的对象或直接调用一个具有命令执行或代码执行功能的方法实现任意代码执行。</p>\n<p>python：pickle 模块</p>\n<p>php：serialize 函数</p>\n<h2 id=\"php\"><a class=\"markdownIt-Anchor\" href=\"#php\">#</a> php</h2>\n<p>php class 序列化后：</p>\n<p>public：属性被序列化的时候属性值会变成  <code>属性名</code></p>\n<p>protected：属性被序列化的时候属性值会变成  <code>\\\\x00*\\\\x00属性名</code></p>\n<p>private：属性被序列化的时候属性值会变成  <code>\\\\x00类名\\\\x00属性名</code></p>\n<p>php 魔术方法：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>__construct<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>            //类的构造函数，创建对象时触发</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>__destruct<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>             //类的析构函数，对象被销毁时触发</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>__call<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                 //在对象上下文中调用不可访问的方法时触发</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>__callStatic<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>           //在静态上下文中调用不可访问的方法时触发</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>__get<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                  //读取不可访问属性的值时，这里的不可访问包含私有属性或未定义</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>__set<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                  //在给不可访问属性赋值时触发</pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>__isset<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                //当对不可访问属性调用 isset<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 或 empty<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 时触发</pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>__unset<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                //在不可访问的属性上使用unset<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>时触发</pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>__invoke<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>               //当尝试以调用函数的方式调用一个对象时触发</pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>__sleep<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                //执行serialize<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>时，先会调用这个方法</pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>__wakeup<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>               //执行unserialize<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>时，先会调用这个方法</pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>__toString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>             //当反序列化后的对象被输出在模板中的时候（转换成字符串的时候）自动调用</pre></td></tr></table></figure><p>serialize () 函数会检查类中是否存在一个魔术方法。如果存在，该方法会先被调用，然后才执行序列化操作。</p>\n<p>从序列化到反序列化这几个函数的执行过程是：</p>\n<pre><code>__construct()` -&gt;`__sleep()` -&gt; `__wakeup()` -&gt; `__toString()` -&gt; `__destruct()\n</code></pre>\n<p><code>_sleep</code>  方法在一个对象被序列化时调用， <code>_wakeup</code>  方法在一个对象被反序列化时调用</p>\n<p>__tostring () 触发时机：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1</span>.  echo<span class=\"token punctuation\">(</span><span class=\"token variable\">$obj</span><span class=\"token punctuation\">)</span>/print<span class=\"token punctuation\">(</span><span class=\"token variable\">$obj</span><span class=\"token punctuation\">)</span>打印时会触发 </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2</span>.  反序列化对象与字符串连接时 </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">3</span>.  反序列化对象参与格式化字符串时 </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">4</span>.  反序列化对象与字符串进行<span class=\"token operator\">==</span>比较时（PHP进行<span class=\"token operator\">==</span>比较的时候会转换参数类型） </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">5</span>.  反序列化对象参与格式化SQL语句，绑定参数时 </pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">6</span>.  反序列化对象在经过php字符串处理函数，如strlen<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>、strops<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>、strcmp<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>、addslashes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>等 </pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">7</span>.  在in_array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法中，第一个参数时反序列化对象，第二个参数的数组中有__toString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>返回的字符串的时候__toString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>会被调用 </pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token number\">8</span>.  反序列化的对象作为class_exists<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>的参数的时候</pre></td></tr></table></figure><p>PHP 序列化需注意以下几点：</p>\n<p>1、序列化只序列属性，不序列方法 2、因为序列化不序列方法，所以反序列化之后如果想正常使用这个对象的话我们必须要依托这个类要在当前作用域存在的条件 3、我们能控制的只有类的属性，攻击就是寻找合适能被控制的属性，利用作用域本身存在的方法，基于属性发动攻击</p>\n<p>4、PHP 对象是存放在<strong>内存的堆空间段</strong>上的，PHP 文件在<strong>执行结束的时候会将对象销毁</strong>。</p>\n<h3 id=\"cve-2016-7124\"><a class=\"markdownIt-Anchor\" href=\"#cve-2016-7124\">#</a> CVE-2016-7124</h3>\n<p>CVE-2016-7124：当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup 的执行</p>\n<h2 id=\"java反序列化\"><a class=\"markdownIt-Anchor\" href=\"#java反序列化\">#</a> java 反序列化</h2>\n<p>Java 中通常使用 <code>Java.io.ObjectOutputStream</code>  类中的 <code>writeObject</code>  方法进行序列化， <code>java.io.ObjectInputStream</code>  类中的 <code>readObject</code>  方法进行反序列化。使用下面代码将字符串进行序列化和反序列化：</p>\n<pre><code>package com.company;\n\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileInputStream;\n\npublic class Main&#123;\n\n    public static void main(String args[]) throws Exception &#123;\n        String obj = &quot;hello&quot;;\n\n        // 将序列化后的数据写入文件a.ser中，当序列化一个对象到文件时， 按照 Java 的标准约定是给文件一个 .ser 扩展名\n        FileOutputStream fos = new FileOutputStream(&quot;a.ser&quot;);\n        ObjectOutputStream os = new ObjectOutputStream(fos);\n        os.writeObject(obj);\n        os.close();\n\n        // 从文件a.ser中读取数据\n        FileInputStream fis = new FileInputStream(&quot;a.ser&quot;);\n        ObjectInputStream ois = new ObjectInputStream(fis);\n\n        // 通过反序列化恢复字符串\n        String obj2 = (String)ois.readObject();\n        System.out.println(obj2);\n        ois.close();\n    &#125;\n&#125;\n</code></pre>\n<p>程序执行后生成 a.ser 文件</p>\n<p>以十六进制查看 a.ser 文件内容，如图：</p>\n<p><img src=\"/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%9D%E6%8E%A2/image-20240508003638454.png\" alt=\"image-20240508003638454\"></p>\n<p><code>ac ed 00 05</code>  是 java 序列化内容的特征，如果经过 base64 编码，那么相对应的是 <code>rO0AB</code> ：</p>\n<p>一个 Java 类的对象要想序列化成功，必须满足两个条件：</p>\n<p>1. 该类必须实现 <code>java.io.Serializable</code>  接口。</p>\n<p>2. 该类的所有属性必须是可序列化的，如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</p>\n<h2 id=\"java反序列化漏洞成因\"><a class=\"markdownIt-Anchor\" href=\"#java反序列化漏洞成因\">#</a> <strong>java 反序列化漏洞成因</strong></h2>\n<p>暴露或间接暴露反序列化 API ，导致用户可以操作传入数据，攻击者可以精心构造反序列化对象并执行恶意代码</p>\n<p>反序列化时会调用 readObject () 函数，如果重写了 readObject 函数，并且里面含有恶意代码，那么在反序列化时调用这个函数就会直接执行恶意代码。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">import</span> java.io.*<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>class MyObject implements Serializable<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    public String name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    //重写readObject<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    private void readObject<span class=\"token punctuation\">(</span>java.io.ObjectInputStream <span class=\"token keyword\">in</span><span class=\"token punctuation\">)</span> throws IOException, ClassNotFoundException, IOException <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        //执行默认的readObject<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        in.defaultReadObject<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        //执行打开计算器程序命令</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        Runtime.getRuntime<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>.exec<span class=\"token punctuation\">(</span><span class=\"token string\">\"calc.exe\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>public class testSerialize <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    public static void main<span class=\"token punctuation\">(</span>String args<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> throws Exception<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        //定义myObj对象</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        MyObject myObj <span class=\"token operator\">=</span> new MyObject<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        myObj.name <span class=\"token operator\">=</span> <span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        //创建一个包含对象进行反序列化信息的”object”数据文件</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        FileOutputStream fos <span class=\"token operator\">=</span> new FileOutputStream<span class=\"token punctuation\">(</span><span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        ObjectOutputStream os <span class=\"token operator\">=</span> new ObjectOutputStream<span class=\"token punctuation\">(</span>fos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        //writeObject<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法将myObj对象写入object文件</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        os.writeObject<span class=\"token punctuation\">(</span>myObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        os.close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        //从文件中反序列化obj对象</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        FileInputStream fis <span class=\"token operator\">=</span> new FileInputStream<span class=\"token punctuation\">(</span><span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        ObjectInputStream ois <span class=\"token operator\">=</span> new ObjectInputStream<span class=\"token punctuation\">(</span>fis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        //恢复对象</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        MyObject objectFromDisk <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>MyObject<span class=\"token punctuation\">)</span>ois.readObject<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        System.out.println<span class=\"token punctuation\">(</span>objectFromDisk.name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        ois.close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><strong>这里定义了一个 Myobject 类并继承了 Serializable 接口，并且重写了 readObject 方法。在反序列化时会执行 readObject 方法。在 readObject () 方法中写入了 Runtime.getRuntime ().exec (“calc.exe”)，在反序列化时就会执行相应的命令。</strong></p>\n<p>这么看起来原理挺简单的，不过实际上就没有这种运气了，都得靠自己构造链子，不过这里先不探讨了，这里只是入个门…</p>\n<p>这篇打算来看看，用工具比较多：<a href=\"https://blog.csdn.net/miuzzx/article/details/128221385\">CTFSHOW web 入门 java 反序列化篇（更新中）_ctfshow java 反序列化 - CSDN 博客</a></p>\n<p>参考：</p>\n<p><a href=\"https://blog.csdn.net/Hardworking666/article/details/122373938\">PHP 反序列化漏洞详解（万字分析、由浅入深）_php 反序列化漏洞原理 - CSDN 博客</a></p>\n<p><a href=\"https://www.freebuf.com/articles/web/276624.html\">常见的 Web 漏洞 —— 反序列化漏洞 - FreeBuf 网络安全行业门户</a></p>\n<p><a href=\"https://www.freebuf.com/articles/web/367585.html\">java 反序列化漏洞详解 - FreeBuf 网络安全行业门户</a></p>\n",
            "tags": [
                "web"
            ]
        },
        {
            "id": "https://demoyao100.github.io/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/",
            "url": "https://demoyao100.github.io/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/",
            "title": "pickle反序列化",
            "date_published": "2023-09-18T06:28:10.000Z",
            "content_html": "<h6 id=\"preface-就是看看~\"><a class=\"markdownIt-Anchor\" href=\"#preface-就是看看~\">#</a> PREFACE: 就是看看～</h6>\n<span id=\"more\"></span>\n<p><a href=\"https://zhuanlan.zhihu.com/p/89132768\">从零开始 python 反序列化攻击：pickle 原理解析 &amp; 不用 reduce 的 RCE 姿势 - 知乎 (zhihu.com)</a></p>\n",
            "tags": [
                "web"
            ]
        }
    ]
}